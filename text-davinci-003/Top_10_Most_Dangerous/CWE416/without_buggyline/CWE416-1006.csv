Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; if ( ! __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; } else { ret = - EADDRINUSE ; } write_unlock_bh ( & l2tp_ip_lock ) ; if ( ret == 0 ) { sock_reset_flag ( sk , SOCK_ZAPPED ) ; } else { goto out ; } out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }",723,-19.318606883162396,-0.026720064845314518
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { write_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",726,-6.766365665582827,-0.009320062900251827
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","

static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; }",639,-6.7600861692044925,-0.010579164584044589
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",651,-2.6043688694945306,-0.004000566619807267
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; 
lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",601,-11.929052292423954,-0.019848672699540687
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; read_lock_bh ( & l2tp_ip_lock ) ; ret = - EADDRINUSE ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : sk_del_node_init ( sk ) ; release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }",649,-9.676692689961554,-0.014910158227983904
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { int result = __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ; read_unlock_bh ( & l2tp_ip_lock ) ; if ( result == 0 ) ret = 0 ; else goto out_in_use ; } else read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",713,-27.2181974626521,-0.038174189989694386
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; 
if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; 
if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; 
if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; 
ret = - EADDRINUSE ; 
read_lock_bh ( & l2tp_ip_lock ) ; 
if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return - EADDRINUSE ; } 
read_unlock_bh ( & l2tp_ip_lock ) ; 
lock_sock ( sk ) ; 
if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return - EINVAL ; } 
chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; 
ret = - EADDRNOTAVAIL ; 
if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; return - EADDRNOTAVAIL ; } 
if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; 
if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; 
sk_dst_reset ( sk ) ; 
l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; 
write_lock_bh ( & l2tp_ip_lock ) ; 
sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; 
sk_del_node_init ( sk ) ; 
write_unlock_bh ( & l2tp_ip_lock ) ; 
ret = 0 ; 
sock_reset_flag ( sk , SOCK_ZAPPED ) ; 
release_sock ( sk ) ; 
return ret ; 
}",722,-14.208863435788311,-0.019679866254554448
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; }",638,-3.6428161097249836,-0.005709743118691197
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return - EADDRINUSE ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; }",643,-4.7163887635404365,-0.00733497474889648
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return - EINVAL ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; return ret ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return ret ; }",659,-4.335671427007369,-0.006579167567537737
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",651,-2.6043688694945306,-0.004000566619807267
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; // Added read lock read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { // Added read unlock read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; // Added write lock write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; // Added write unlock write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",667,-15.59107643297661,-0.023374927185871978
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock(sk); goto out; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock(sk); goto out ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }",659,-7.685666863224247,-0.011662620429778827
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return ret ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; return ret ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return ret ; }",656,-5.9878125524099355,-0.009127763037210267
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; write_unlock_bh ( & l2tp_ip_lock ) ; sk_del_node_init ( sk ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",651,-5.7959656305956315,-0.008903173011667636
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) || !uaddr ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return - EINVAL ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; return ret ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return ret ; }",663,-14.158908617630011,-0.02135581993609353
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return - EADDRINUSE ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return - EINVAL ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; return - EADDRNOTAVAIL ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return ret ; }",651,-6.476592429143341,-0.009948682686856131
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",651,-2.7415224369844653,-0.004211247983079056
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; 

ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { 
    read_unlock_bh ( & l2tp_ip_lock ) ; 
    return - EADDRINUSE ; 
} 

lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; 

ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; 
out : release_sock ( sk ) ; return ret ;
}",646,-23.11783251194444,-0.03578611843954248
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",651,-2.7415224369844653,-0.004211247983079056
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; goto out ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; goto out ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; out : return ret ; out_in_use : return ret ; }",671,-6.289318788019927,-0.009373053335350115
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:"," 
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",652,-5.530310128568615,-0.008482070749338367
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; /* Acquire the lock before accessing the bind table */ read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; /* Release the lock before proceeding */ read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; /* Acquire the lock before modifying the bind table */ write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; /* Release the lock after modifying the bind table */ write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : /* Release the lock after accessing the bind table */ read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }",698,-24.53499801115215,-0.03515042695007471
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","

static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len) {
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *)uaddr;
	struct net *net = sock_net(sk);
	int ret;
	int chk_addr_ret;

	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
	if (addr_len < sizeof(struct sockaddr_l2tpip))
		return -EINVAL;
	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	write_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	write_unlock_bh(&l2tp_ip_lock);

	lock_sock(sk);
	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
		goto out;

	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;
	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;

	sk_dst_reset(sk);
	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);
	return ret;

out_in_use:
	write_unlock_bh(&l2tp_ip_lock);
	return ret;
}",717,-25.116182492327184,-0.03502954322500305
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { ret = - EADDRNOTAVAIL ; goto out ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { ret = - EADDRNOTAVAIL ; goto out ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }",664,-7.733825536040819,-0.011647327614519306
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",651,-2.7415224369844653,-0.004211247983079056
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; 

if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) {
    kfree(addr->l2tp_addr.s_addr);
    goto out_in_use;
} 

read_unlock_bh ( & l2tp_ip_lock ) ;
lock_sock ( sk ) ;
if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ;
chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ;
ret = - EADDRNOTAVAIL ;
if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ;
if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ;
if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ;
sk_dst_reset ( sk ) ;
l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ;
write_lock_bh ( & l2tp_ip_lock ) ;
sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ;
sk_del_node_init ( sk ) ;
write_unlock_bh ( & l2tp_ip_lock ) ;
ret = 0 ;
sock_reset_flag ( sk , SOCK_ZAPPED ) ;
out : release_sock ( sk ) ;
return ret ;
out_in_use :
return ret ;
}",665,-32.888985390274186,-0.04945712088763036
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; read_lock_bh ( & l2tp_ip_lock ) ; ret = - EADDRINUSE ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return - EINVAL ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; return ret ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return ret ; }",659,-6.5132876064240355,-0.00988359272598488
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; }",638,-3.6520590998993234,-0.005724230564105523
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:"," 
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",652,-5.530310128568615,-0.008482070749338367
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",651,-2.6597742898597154,-0.004085674792411237
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( ! __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { // Prevent use after free by adding a reference to the socket sk_refcnt_debug_inc ( sk ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : // Prevent use after free with this release sk_refcnt_debug_release ( sk ) ; read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }",698,-45.15292167698341,-0.06468899953722551
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }",638,-8.08309657264154,-0.012669430364641913
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( ! __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state == TCP_CLOSE && addr_len >= sizeof ( struct sockaddr_l2tpip ) ) { chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret == RTN_LOCAL ) { if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; } } release_sock ( sk ) ; } else { read_unlock_bh ( & l2tp_ip_lock ) ; } return ret ; }",606,-11.35709860993358,-0.018741086815071913
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; read_lock_bh ( & l2tp_ip_lock ) ; ret = - EADDRINUSE ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { ret = - EINVAL ; goto out ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }",647,-8.943563327044375,-0.013823127244272605
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *)uaddr;
	struct net *net = sock_net(sk);
	int ret;
	int chk_addr_ret;

	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
	if (addr_len < sizeof(struct sockaddr_l2tpip))
		return -EINVAL;
	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip_lock);

	lock_sock(sk);
	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip)) {
		ret = -EINVAL;
		goto out;
	}

	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;
	sk_dst_reset(sk);
	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	write_unlock_bh(&l2tp_ip_lock);

	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);
	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);
	return ret;
}",717,-18.838657321648064,-0.026274277993930353
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return ret ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; return ret ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return ret ; }",656,-5.940955123187023,-0.00905633402924851
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",651,-2.719641982498409,-0.004177637453914607
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { 	read_unlock_bh ( & l2tp_ip_lock ) ; 	return ret ; 	} read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; }",644,-12.193328448618491,-0.018933739827047345
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; read_lock_bh ( & l2tp_ip_lock ) ; ret = - EADDRINUSE ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return - EINVAL ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; goto out ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : return ret ; out_in_use : return ret ; }",666,-7.988396363408826,-0.011994589134247486
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) {  read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; }",639,-9.276254267584333,-0.014516829839725092
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { /* Add ref count to prevent an use after free attack */ sock_hold(sk); read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; /* Add ref count to prevent an use after free attack */ sock_hold(sk); sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; }",674,-31.42148540156182,-0.046619414542376586
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return - EINVAL ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; return - EADDRNOTAVAIL ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
The vulnerability in the original code was that the return statement inside the out label was missing. This meant that when the code was reached, the sock structure was not being properly released and could be used after being freed, leading to a Use After Free vulnerability. The fixed code adds a return statement to the out label which properly releases the sock structure, preventing the vulnerability.",751,-68.86879860997901,-0.09170279442074436
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; read_lock_bh ( & l2tp_ip_lock ) ; ret = - EADDRINUSE ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }",649,-9.370033406351702,-0.014437647775580435
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","

static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; read_lock_bh ( & l2tp_ip_lock ) ; ret = - EADDRINUSE ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return - EINVAL ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; return ret ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return ret ; }",660,-9.189035059449447,-0.013922780393105223
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; goto out ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; goto out ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : return ret ; out_in_use : return ret ; }",663,-4.180403863298586,-0.006305284861687158
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; return - EADDRINUSE ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) { release_sock ( sk ) ; return - EINVAL ; } chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) { release_sock ( sk ) ; return ret ; } if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return ret ; }",655,-7.146455104947595,-0.010910618480836022
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",651,-2.780298018346769,-0.004270811088090275
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
Fixed code:","
static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) { read_unlock_bh ( & l2tp_ip_lock ) ; goto out_in_use ; } read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : return ret ; }",651,-2.698235302578427,-0.004144754689060564
