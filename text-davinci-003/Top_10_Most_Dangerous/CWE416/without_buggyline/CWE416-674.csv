Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } } 
In the fixed code, the allocated memory for the class_hash HashTable is freed using the efree() function instead of the FREE_HASHTABLE() macro. This change ensures that the memory is properly freed after it is no longer used, which prevents a potential use-after-free vulnerability.",749,-41.52918811027683,-0.055446179052439024
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = (HashTable*)emalloc(sizeof(HashTable)); zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree(class_hash); } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree(class_hash); } }",687,-7.398577597486108,-0.010769399705219954
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = ( HashTable * ) emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }
The code has been fixed by replacing FREE_HASHTABLE() with efree() when freeing class_hash. This makes sure that the memory is correctly deallocated and no dangling pointer can be left behind, thus avoiding any use-after-free vulnerability.",745,-51.206753579842506,-0.0687338974226074
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }",686,-3.664296753586831,-0.005341540457123661
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; efree(class_hash); // Added line to prevent use after free } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; efree(class_hash); // Added line to prevent use after free } }",720,-15.107949623862634,-0.02098326336647588
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { // Add this line before PHP_VAR_UNSERIALIZE_DESTROY to prevent use after free zval_ptr_dtor ( return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",726,-19.243140675893148,-0.02650570341032114
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; // FREE_HASHTABLE(class_hash); // Free the hash table here to prevent a Use After Free vulnerability efree(class_hash); } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; // FREE_HASHTABLE(class_hash); // Free the hash table here to prevent a Use After Free vulnerability efree(class_hash); } }",730,-25.05602215644943,-0.03432331802253347
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { 	zend_hash_destroy ( class_hash ) ; 	FREE_HASHTABLE ( class_hash ) ; } }
The code was fixed by moving the line “PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;” to after the call to “RETURN_FALSE”. This ensures that the memory associated with “var_hash” is freed before returning false.",743,-51.54638331194867,-0.06937602060827545
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:"," 
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { if (class_hash) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",722,-7.3060920257925,-0.010119241032953601
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",721,-5.001263857969193,-0.00693656568372981
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { if (class_hash) { zend_hash_destroy(class_hash); efree(class_hash); } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }",682,-12.084609935592656,-0.017719369407027355
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; return_value = NULL; /* FREE the return_value before RETURN_FALSE */ if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",709,-27.80914867912929,-0.0392230587857959
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; zval_ptr_dtor ( return_value ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
The fixed code removes the potentially vulnerable FREE_HASHTABLE call outside of the if statement, and instead places it inside the if statement, ensuring that the memory is only freed if it was successfully allocated.",732,-42.86210847541755,-0.058554792999204304
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } zval_dtor(return_value); //Add this line to prevent use after free RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",709,-16.519003881293173,-0.023299018168255532
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { zval_ptr_dtor ( return_value ) ; php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } for ( zend_string * lcname ; lcname ; lcname = NULL ) { zend_string_release ( lcname ) ; } }",653,-25.139953892993404,-0.03849916369524258
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { if (class_hash) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",690,-6.628675523956534,-0.009606776121676135
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { if (class_hash != NULL) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",723,-5.124607284703892,-0.0070879768806416206
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { zval_ptr_dtor ( return_value ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }

The code has been fixed by moving the zval_ptr_dtor() function call to before the PHP_VAR_UNSERIALIZE_DESTROY() function call. This ensures that the return_value is properly released before the PHP_VAR_UNSERIALIZE_DESTROY() function is called, which prevents the use-after-free vulnerability.",770,-35.728499798606975,-0.046400649089099966
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { 
    char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; 
    if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { 
        RETURN_FALSE ; 
    } 
    if ( buf_len == 0 ) { 
        RETURN_FALSE ; 
    } 
    p = ( const unsigned char * ) buf ; 
    PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; 
    if ( options != NULL ) { 
        classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; 
        if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { 
            ALLOC_HASHTABLE ( class_hash ) ; 
            zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; 
        } 
        if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { 
            zval * entry ; zend_string * lcname ; 
            ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { 
                convert_to_string_ex ( entry ) ; 
                lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; 
                if ( zend_hash_add_empty_element ( class_hash , lcname ) == NULL ) {
                    zend_string_release ( lcname ) ; 
                }
            } 
            ZEND_HASH_FOREACH_END ( ) ; 
        } 
    } 
    if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { 
        PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; 
        if ( class_hash ) { 
            zend_hash_destroy ( class_hash ) ; 
            FREE_HASHTABLE ( class_hash ) ; 
        } 
        zval_ptr_dtor ( return_value ) ; 
        if ( ! EG ( exception ) ) { 
            php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; 
        } 
        RETURN_FALSE ; 
    } 
    var_push_dtor ( & var_hash , return_value ) ; 
    PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; 
    if ( class_hash ) { 
        zend_hash_destroy ( class_hash ) ; 
        FREE_HASHTABLE ( class_hash ) ; 
    } 
}",831,-21.921835270754126,-0.026380066511136134
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; 
size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }

The vulnerability has been fixed by replacing the line FREE_HASHTABLE(class_hash); with efree(class_hash);. This ensures that the memory allocated is freed, instead of just being marked as free, which can lead to the use after free vulnerability.",741,-52.89988386655532,-0.07138985676998019
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { if (class_hash != NULL) { zend_hash_destroy(class_hash); FREE_HASHTABLE(class_hash); } ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",721,-6.856972108485836,-0.009510363534654419
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; if ( Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }",681,-8.33425915017444,-0.012238266006129867
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { if (class_hash) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",721,-5.136722327067349,-0.0071244415077217045
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } if(buf != NULL) { p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
else { RETURN_FALSE; } }",708,-14.241972197630695,-0.02011577994015635
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; //FREE_HASHTABLE is replaced by efree } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }",695,-17.382082293105455,-0.025010190349792023
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { /* Allocate class_hash using emalloc() to prevent use after free */ class_hash = emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; /* Free class_hash using efree() to prevent use after free */ efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; /* Free class_hash using efree() to prevent use after free */ if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }",732,-23.560943035342312,-0.03218708064937474
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; if (class_hash) { zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",698,-11.057097021327017,-0.015841113211070224
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { // Allocate memory for the HashTable and check if successful. class_hash = (HashTable *) safe_emalloc ( sizeof ( HashTable ) , 1 , 0 ) ; if ( class_hash == NULL ) { // Free memory and return false if unsuccessful. PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; efree ( class_hash ) ; RETURN_FALSE ; } zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { // Free memory and return false if unsuccessful. PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }",770,-45.29061985132577,-0.0588189868199036
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }
The vulnerability has been fixed by replacing the ALLOC_HASHTABLE and FREE_HASHTABLE functions with the emalloc and efree functions, respectively. This prevents the potential for a use-after-free attack by ensuring that the memory is properly allocated and freed.",742,-33.04945466561151,-0.044541044023735196
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; zval_ptr_dtor(entry); //FIX: Add a zval_ptr_dtor() to destroy the entry after use. } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",720,-28.215826077029273,-0.03918864732920732
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; }",689,-8.51452640009443,-0.012357803193170437
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }

The vulnerability has been fixed by replacing the FREE_HASHTABLE() call with efree(), which allows for the memory allocated for class_hash to be freed safely.",722,-28.544335098066053,-0.03953509016352639
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION(unserialize) {
  char *buf = NULL;
  size_t buf_len;
  const unsigned char *p;
  php_unserialize_data_t var_hash;
  zval *options = NULL, *classes = NULL;
  HashTable *class_hash = NULL;
  void* allocated_buf = NULL;
  
  if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
    RETURN_FALSE;
  }
  
  if (buf_len == 0) {
    RETURN_FALSE;
  }
  
  //Allocate memory
  allocated_buf = emalloc(buf_len);
  memcpy(allocated_buf, buf, buf_len);
  p = (const unsigned char*)allocated_buf;
  
  PHP_VAR_UNSERIALIZE_INIT(var_hash);
  
  if (options != NULL) {
    classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
    if (classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
      ALLOC_HASHTABLE(class_hash);
      zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY) ? zend_hash_num_elements(Z_ARRVAL_P(classes)) : 0, NULL, NULL, 0);
    }
    
    if (class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
      zval *entry;
      zend_string *lcname;
      
      ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
        convert_to_string_ex(entry);
        lcname = zend_string_tolower(Z_STR_P(entry));
        zend_hash_add_empty_element(class_hash, lcname);
        zend_string_release(lcname);
      } ZEND_HASH_FOREACH_END();
    }
  }
  
  if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
    PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
    if (class_hash) {
      zend_hash_destroy(class_hash);
      FREE_HASHTABLE(class_hash);
    }
    zval_ptr_dtor(return_value);
    if (!EG(exception)) {
      php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"", (zend_long)((char*)p-buf), buf_len);
    }
    //Free allocated memory
    efree(allocated_buf);
    RETURN_FALSE;
  }
  
  var_push_dtor(&var_hash, return_value);
  PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
  if (class_hash) {
    zend_hash_destroy(class_hash);
    FREE_HASHTABLE(class_hash);
  } 
  //Free allocated memory
  efree(allocated_buf);
}",847,-50.92484929325311,-0.06012378901210521
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; zval_dtor(entry); //Added to fix the vulnerability } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",704,-13.008280860122793,-0.018477671676310786
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }",686,-3.901177929204006,-0.0056868482933003
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }

The fixed code prevents the vulnerability by replacing the FREE_HASHTABLE() function with the efree() function. The FREE_HASHTABLE() function can be used to free dynamic memory, which could potentially be freed after it has already been freed, leading to a use after free vulnerability. The efree() function provides protection against this, as it also checks that the memory being freed has not already been freed. This prevents the vulnerability.",775,-76.36758431688442,-0.09853881847339925
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , zend_string_release , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zend_string_release(lcname); // added line to fix Use After Free vulnerability }",702,-18.279752611199758,-0.02603953363418769
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } // Added: PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } var_push_dtor ( & var_hash , return_value ) ; }",643,-16.530475028755735,-0.025708359298220428
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } zend_refcounted *ref = EG(garbage_ptr); if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } EG(garbage_ptr) = ref; RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } } 

The above code fixes the vulnerability by adding a line of code to store the current value of the EG(garbage_ptr). This prevents the code from accessing memory that has been freed if the unserialize fails.",763,-66.83558832142856,-0.08759579072271109
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = ( HashTable * ) emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }
The vulnerability has been fixed by replacing the FREE_HASHTABLE function with the efree function. The FREE_HASHTABLE function is vulnerable to CWE-416 as it does not always free allocated memory correctly. The efree function is safer than FREE_HASHTABLE as it checks for null pointers and ensures that the memory is properly freed.",763,-54.68631725954556,-0.07167276180805447
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = emalloc ( sizeof ( HashTable ) ) ; if ( class_hash == NULL ) { RETURN_FALSE ; } zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }

The fixed code eliminates the vulnerability by initializing the class_hash with emalloc(), instead of ALLOC_HASHTABLE(), and freeing it later with efree(), instead of FREE_HASHTABLE(). This ensures that the memory allocated for the class_hash is properly freed when the function is finished, preventing a use-after-free vulnerability.",775,-55.267156983294235,-0.07131246062360547
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { if (class_hash) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",720,-6.858456191171632,-0.009525633598849488
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { if(Z_TYPE_P(entry) == IS_STRING) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } else { php_error_docref ( NULL , E_WARNING , ""allowed_classes can only contain strings"" ) ; zval_ptr_dtor ( return_value ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } RETURN_FALSE ; } } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",785,-25.21618664713965,-0.032122530760687454
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }
The original code uses the function FREE_HASHTABLE to free the class_hash, however this function does not set the pointer to NULL, leaving the possibility of the class_hash pointer being used after it has been freed, creating a Use After Free vulnerability. The fixed code changes the function FREE_HASHTABLE to efree, which sets the pointer to NULL after it has been freed.",765,-50.21555104557841,-0.06564124319683452
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { if ( class_hash != NULL ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",723,-5.825620314835,-0.008057566133934992
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { if (class_hash) { zend_hash_destroy (class_hash); FREE_HASHTABLE (class_hash); } ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",719,-9.067157345765512,-0.012610789076169002
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { // Release class_hash to prevent use after free if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; }",669,-16.041406492429306,-0.023978186087338274
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { class_hash = emalloc ( sizeof ( HashTable ) ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; efree ( class_hash ) ; } }",686,-3.9847182849497806,-0.005808627237536124
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { if (class_hash) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",721,-5.023439399668504,-0.0069673223296373155
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
Fixed code:","
PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } zval * return_value ; //Add initialization to avoid Use After Free vulnerability if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } zval_ptr_dtor ( return_value ) ; if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } var_push_dtor ( & var_hash , return_value ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }",706,-27.75858154837997,-0.039318104176175594
