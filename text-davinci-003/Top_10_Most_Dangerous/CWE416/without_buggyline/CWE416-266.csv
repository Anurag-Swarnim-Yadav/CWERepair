Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { key_put ( ci -> ci_keyring_key ) ; ci -> ci_keyring_key = NULL ; ci = NULL ; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",381,-6.013524722048033,-0.01578352945419431
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { 
    struct dentry * dir ; 
    struct fscrypt_info * ci ; 
    int dir_has_key , cached_with_key ; 
    if ( flags & LOOKUP_RCU ) return - ECHILD ; 
    dir = dget_parent ( dentry ) ; 
    if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { 
        dput ( dir ) ; 
        return 0 ; 
    } 
    ci = d_inode ( dir ) -> i_crypt_info ; 
    if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) {
        ci = NULL ;
        key_put ( ci -> ci_keyring_key ) ;
    } 
    spin_lock ( & dentry -> d_lock ) ; 
    cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; 
    spin_unlock ( & dentry -> d_lock ) ; 
    dir_has_key = ( ci != NULL ) ; 
    dput ( dir ) ; 
    if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; 
    return 1 ; 
}",428,-16.076571172794146,-0.037562082179425575
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { dput ( dir ) ; return - ECHILD ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",357,-9.868012118260383,-0.02764149052734001
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { /* Add a reference to the key to prevent it from being freed */ key_get ( ci -> ci_keyring_key ) ; ci = NULL ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",380,-16.82083550709586,-0.04426535659762069
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { key_put ( ci -> ci_keyring_key ) ; ci = NULL ; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",368,-5.724865792865743,-0.015556700524091693
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if ( ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put ( ci -> ci_keyring_key ) ; ci = NULL ; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
The fixed code adds a call to key_put() to release the ci->ci_keyring_key reference when the key is invalidated, revoked, or dead. This ensures that the key is released in a timely manner, and prevents the potential use after free vulnerability.",428,-39.6673398667385,-0.0926807006232208
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci = NULL ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { ci = NULL ; free_fscrypt_info ( ci ) ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",364,-12.296660833904259,-0.03378203525797873
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci ) { if ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put(ci->ci_keyring_key); ci = NULL; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",367,-6.234683444185446,-0.016988238267535274
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if(ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ){ key_put(ci->ci_keyring_key); ci = NULL; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",364,-10.35256030133123,-0.028441099728931954
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci = NULL ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = fscrypt_get_info ( d_inode ( dir ) ) ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { fscrypt_put_info ( ci ) ; ci = NULL ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) { fscrypt_put_info ( ci ) ; return 0 ; } return 1 ; }",381,-9.288198457877304,-0.02437847364272258
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { ci = NULL; kfree(ci->ci_keyring_key); } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",362,-7.132453030737332,-0.01970290892468876
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put(ci->ci_keyring_key); ci = NULL; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",363,-3.811613131600428,-0.010500311657301455
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci ) { if ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put ( ci -> ci_keyring_key ) ; ci = NULL ; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
The fixed code correctly frees the ci_keyring_key when it is no longer needed to prevent a use after free vulnerability. The key_put() function is used to free the key from memory.",414,-35.957947869251335,-0.08685494654408535
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put ( ci -> ci_keyring_key ) ; ci = NULL ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",366,-4.5716551834179375,-0.01249086115687961
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { key_put ( ci -> ci_keyring_key ) ; ci -> ci_keyring_key = NULL ; ci = NULL ; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",381,-6.083850363942482,-0.015968111191450085
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci = NULL ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = kmalloc(sizeof(struct fscrypt_info), GFP_KERNEL); if ( !ci ) { dput ( dir ) ; return -ENOMEM; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { kfree(ci); ci = NULL; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) { kfree(ci); return 0 ; } kfree(ci); return 1 ; }",411,-17.4317350981889,-0.042412980774182235
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci , * ci_copy ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; ci_copy = kmemdup ( ci , sizeof ( * ci ) , GFP_KERNEL ) ; if ( ci_copy && ci_copy -> ci_keyring_key && ( ci_copy -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci_copy = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci_copy != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) { kfree ( ci_copy ) ; return 0 ; } kfree ( ci_copy ) ; return 1 ; }",412,-11.54067685119646,-0.028011351580573933
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if( ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put(ci->ci_keyring_key); ci = NULL; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",367,-9.4322171690523,-0.025700864220850956
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci ) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { ci = NULL ; } else { ci = kmemdup ( ci , sizeof ( * ci ) , GFP_KERNEL ) ; if ( ! ci ) { dput ( dir ) ; return - ENOMEM ; } } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) { kfree ( ci ) ; return 0 ; } return 1 ; }",399,-21.731907862905246,-0.054465934493496855
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci ) { if (ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { ci = NULL; // added line } else { // added block ref_get(ci->ci_keyring_key); } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) { if (ci && ci -> ci_keyring_key) { // added block key_put(ci->ci_keyring_key); } return 0 ; } return 1 ; }",410,-33.241452040558435,-0.08107671229404496
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci = NULL ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = kmalloc ( sizeof ( struct fscrypt_info ) , GFP_KERNEL ) ; if ( ! ci ) return - ENOMEM ; if ( d_inode ( dir ) -> i_crypt_info && d_inode ( dir ) -> i_crypt_info -> ci_keyring_key && ( d_inode ( dir ) -> i_crypt_info -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { kfree ( ci ) ; ci = NULL ; } else { memcpy ( ci , d_inode ( dir ) -> i_crypt_info , sizeof ( struct fscrypt_info ) ) ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) { kfree ( ci ) ; return 0 ; } kfree ( ci ) ; return 1 ; }",462,-15.025819993553107,-0.0325234198994656
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } // CWE-416 Added condition to check for NULL ci if (d_inode(dir)->i_crypt_info != NULL) { ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",381,-33.293837344000046,-0.08738539985301849
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if ((ci->ci_keyring_key->flags & (1 << KEY_FLAG_INVALIDATED)) || (ci->ci_keyring_key->flags & (1 << KEY_FLAG_REVOKED)) || (ci->ci_keyring_key->flags & (1 << KEY_FLAG_DEAD))) { key_put(ci->ci_keyring_key); ci = NULL; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",384,-10.448646338093338,-0.027210016505451403
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put(ci -> ci_keyring_key); ci = NULL; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",364,-7.514215116969898,-0.020643448123543677
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { key_put ( ci -> ci_keyring_key ) ; ci -> ci_keyring_key = NULL ; ci = NULL ; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",381,-6.053247139739488,-0.015887787768345114
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { //free ci before returning ci = NULL ; kfree(ci); } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",361,-17.101059527660603,-0.04737135603230084
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { ci = NULL ; kfree ( ci ) ; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",359,-9.857772822888945,-0.02745897722253188
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { dput ( dir ) ; ci = NULL ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) { dput ( dir ) ; return 0 ; } dput ( dir ) ; return 1 ; }",364,-9.251324823766598,-0.025415727537820326
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put(ci->ci_keyring_key); ci = NULL; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",363,-3.934471619722228,-0.010838764792623218
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { ci = NULL ; } else { refcount_acquire ( & ci -> ci_refcount ) ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; refcount_release ( & ci -> ci_refcount ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",386,-20.027150218683616,-0.0518838088566933
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir = NULL ; struct fscrypt_info * ci = NULL ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci ) { if (ci->ci_keyring_key) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { key_put(ci->ci_keyring_key); // free ci->ci_keyring_key ci = NULL; } } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",382,-27.416970430045957,-0.07177217390064387
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","

static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { kfree(ci->ci_keyring_key); ci = NULL; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",363,-9.383471869063623,-0.02584978476326067
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { ci -> ci_keyring_key = NULL; ci = NULL; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",363,-8.629611553934787,-0.023773034583842386
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci ) { if ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put ( ci -> ci_keyring_key ) ; ci = NULL ; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }

The fixed code eliminates the potential Use-After-Free vulnerability by adding a call to the key_put() function in order to properly release the ci->ci_keyring_key handle. This ensures that the associated memory is not freed before it is no longer being used, avoiding any potential issues with accessing freed memory.",438,-68.93843469636994,-0.15739368652139255
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci = NULL ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { // Release the reference on the keyring key key_put ( ci -> ci_keyring_key ) ; ci = NULL ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",377,-19.495011938417118,-0.0517109069984539
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { kfree(ci); ci = NULL; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }

The issue with the original code is that the variable ci is not freed after it is used before its next use. This can cause a Use After Free vulnerability, as the memory that ci points to may have been freed or reused by another process.

The fixed code addresses this issue by explicitly freeing the memory pointed to by ci after it is used, using the kfree() function. This ensures that the memory can no longer be accessed and prevents the Use After Free vulnerability.",456,-80.88623335207396,-0.17738209068437272
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { 
struct dentry * dir ; 
struct fscrypt_info * ci ; 
int dir_has_key , cached_with_key ; 

if ( flags & LOOKUP_RCU ) return - ECHILD ; 

dir = dget_parent ( dentry ) ; 
if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { 
dput ( dir ) ; 
return 0 ; 
} 

ci = d_inode ( dir ) -> i_crypt_info ; 
if ( ci != NULL && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) {
    dput (dir);
    return -ECHILD;
} 

spin_lock ( & dentry -> d_lock ) ; 
cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; 
spin_unlock ( & dentry -> d_lock ) ; 

dir_has_key = ( ci != NULL ) ; 
dput ( dir ) ; 

if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; 

return 1 ; 
}",407,-28.066271927847588,-0.06895889908562061
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci ) { if ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { ci = NULL; kfree(ci->ci_keyring_key); } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",366,-9.554572991365044,-0.026105390686789735
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put(ci->ci_keyring_key); ci = NULL; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",363,-4.507424642086184,-0.012417147774342104
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; 
if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } 

ci = kzalloc(sizeof(struct fscrypt_info), GFP_KERNEL);
if (!ci) {
    dput(dir);
    return -EINVAL;
}

if ( d_inode ( dir ) -> i_crypt_info ) {
    ci->ci_keyring_key = d_inode ( dir ) -> i_crypt_info -> ci_keyring_key ; 
    if ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) {
        kfree(ci);
        ci = NULL;
    }
}

spin_lock ( & dentry -> d_lock ) ; 
cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; 
spin_unlock ( & dentry -> d_lock ) ; 
dir_has_key = ( ci != NULL ) ; 
dput ( dir ) ; 
if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) {
    if (ci)
        kfree(ci);
    return 0 ; 
} 

if (ci)
    kfree(ci);

return 1 ; 
}",500,-44.17617187638949,-0.08835234375277898
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) { // Add references to the dentry that have been acquired through the dget_parent() call. dget(dentry); dput(dentry); return 0 ; } return 1 ; }",382,-40.40193758053509,-0.10576423450401856
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { ci = NULL ; key_put ( ci -> ci_keyring_key ) ; // Added to prevent Use-After-Free } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",375,-16.763284980688987,-0.044702093281837295
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { //Added key_put() to free the key. key_put(ci->ci_keyring_key); ci = NULL; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",376,-21.491169969424654,-0.05715736693995919
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci ) { if ( ci -> ci_keyring_key ) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { 
key_put(ci->ci_keyring_key); 
ci = NULL; 
} } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; } }",374,-24.281610659001494,-0.06492409267112699
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; struct fscrypt_info * ci_temp ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; ci_temp = kmalloc ( sizeof ( * ci_temp ) , GFP_KERNEL ) ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { ci_temp = ci ; ci = NULL ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; kfree ( ci_temp ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",404,-20.481647574913158,-0.05069714746265633
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { key_put(ci->ci_keyring_key); ci = NULL; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",363,-4.453884397009079,-0.012269653986250907
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { key_put ( ci -> ci_keyring_key ) ; ci = NULL ; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; 
} 

The vulnerability is fixed by adding a key_put() call to the conditional statement block that checks if the keyring key flags are invalidated, revoked, or dead. This ensures that the key object is released, preventing the Use After Free vulnerability.",423,-54.507946198905444,-0.1288603929052138
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci , *ci_ref = NULL; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci_ref = ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) { kfree(ci_ref); ci_ref = NULL; return 0 ; } 
kfree(ci_ref); ci_ref = NULL;
return 1 ; 
}",395,-24.493294412244303,-0.06200834028416279
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key ) { if ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) { key_put ( ci -> ci_keyring_key ) ; ci = NULL ; } } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",368,-5.749185371682446,-0.015622786336093604
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
Fixed code:","
static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } ci = d_inode ( dir ) -> i_crypt_info ; if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) { dput ( dir ) ; return 0 ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }",354,-6.524126903804503,-0.018429737016396903
