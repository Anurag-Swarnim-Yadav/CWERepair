Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; // Add check to ensure that total_len is not greater than the size of buffer if (total_len > MAX_BUFFER_LENGTH) return - EINVAL; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; // Add check to ensure that total_len does not underflow for ( i = 0 ; i < num ; i ++ ) { // Add check to ensure that length is not greater than total_len if (length > total_len) break; buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",833,-41.61201345208719,-0.049954397901665296
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && i < MAX_DEVICE_CAPS; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",769,-9.044555415363764,-0.011761450475115428
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; 
if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; if (total_len < length) { kfree ( bos ) ; return - EINVAL ; } dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) { kfree ( bos ) ; return - ENOMEM ; } kfree ( bos ) ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } 
if ( total_len < length ) {
  usb_release_bos_descriptor ( dev ) ;
  return - EINVAL ;
  } 
} 
return 0 ; 

err : usb_release_bos_descriptor ( dev ) ; return ret ;
}",822,-52.70205950291362,-0.06411442761911633
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; //Added a limit to the length of the descriptor to prevent out-of-bounds read ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , min(USB_DT_BOS_SIZE, bos->bLength) ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; //Added a limit to the length of the descriptor to prevent out-of-bounds read ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , min ( total_len , buffer -> bLength ) ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",813,-38.453538162375935,-0.04729832492297163
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; if (num > 0) { dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",766,-12.257083194702588,-0.01600141409230103
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length || total_len > USB_DT_BOS_SIZE ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; //added bounds check if(buffer + length > total_len) break; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",788,-22.657883217944633,-0.028753658906021107
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && total_len >= length; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",765,-6.275432406518068,-0.008203179616363488
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && i < total_len; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",765,-4.635327362412782,-0.006059251454134355
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; // added if statement to check if dev->bos is NULL if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { // added check to make sure index stays within bounds of buffer if (i >= total_len) break; buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",793,-36.27019091120927,-0.04573794566356781
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { if (i >= total_len) break; //Add bounds check on i. buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",776,-22.138054731580326,-0.028528421045850936
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length || total_len > USB_DT_BOS_SIZE ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; if ( total_len < cap -> bLength ) break ; length = cap -> bLength ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",775,-9.275690347034828,-0.011968632705851391
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","

int usb_get_bos_descriptor ( struct usb_device * dev ) { 
  struct device * ddev = & dev -> dev ; 
  struct usb_bos_descriptor * bos ; 
  struct usb_dev_cap_header * cap ; 
  unsigned char * buffer ; 
  int length , total_len , num , i ; 
  int ret ; 
  bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; 
  if ( ! bos ) return - ENOMEM ; 
  ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; 
  if ( ret < USB_DT_BOS_SIZE ) { 
    dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; 
    if ( ret >= 0 ) ret = - ENOMSG ; 
    kfree ( bos ) ; 
    return ret ; 
  } 
  length = bos -> bLength ; 
  total_len = le16_to_cpu ( bos -> wTotalLength ) ; 
  num = bos -> bNumDeviceCaps ; 
  kfree ( bos ) ; 
  if ( total_len < length ) return - EINVAL ; 
  dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; 
  if ( ! dev -> bos ) return - ENOMEM ; 
  if (total_len > 0) { 
    buffer = kzalloc ( total_len , GFP_KERNEL ) ; 
    if ( ! buffer ) { 
      ret = - ENOMEM ; 
      goto err ; 
    } 
  } 
  dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; 
  ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; 
  if ( ret < total_len ) { 
    dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; 
    if ( ret >= 0 ) ret = - ENOMSG ; 
    goto err ; 
  } 
  total_len -= length ; 
  for ( i = 0 ; i < num ; i ++ ) { 
    if (total_len <= 0) {
      break;
    }
    buffer += length ; 
    cap = ( struct usb_dev_cap_header * ) buffer ; 
    length = cap -> bLength ; 
    if ( total_len < length ) break ; 
    total_len -= length ; 
    if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { 
      dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; 
      continue ; 
    } 
    switch ( cap -> bDevCapabilityType ) { 
      case USB_CAP_TYPE_WIRELESS_USB : break ; 
      case USB_CAP_TYPE_EXT : 
        dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; 
        break ; 
      case USB_SS_CAP_TYPE : 
        dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; 
        break ; 
      case USB_SSP_CAP_TYPE : 
        dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; 
        break ;
      case CONTAINER_ID_TYPE : 
        dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; 
        break ; 
      case USB_PTM_CAP_TYPE : 
        dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; 
      default : 
        break ; 
    } 
  } 
  return 0 ; 
err : 
  usb_release_bos_descriptor ( dev ) ; 
  return ret ; 
",1000,-36.48208062224492,-0.03648208062224492
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && i < total_len ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",765,-6.621692337509231,-0.008655806977136249
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { if (i >= num) { break; } buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",769,-9.720365623827808,-0.012640267391193508
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && length <= total_len ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",765,-10.903482706157927,-0.014252918570141082
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && total_len > 0; i ++ ) { buffer += length ; if (total_len < sizeof(struct usb_dev_cap_header)) { break; } cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",786,-9.67753546999902,-0.012312386094146336
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && i < total_len; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",765,-4.552575058548422,-0.005951078507906434
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { 
struct device * ddev = & dev -> dev ; 
struct usb_bos_descriptor * bos ; 
struct usb_dev_cap_header * cap ; 
unsigned char * buffer ; 
int length , total_len , num , i ; 
int ret ; 

bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; 
if ( ! bos ) return - ENOMEM ; 

ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; 
if ( ret <= 0 ) { 
dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; 
if ( ret >= 0 ) ret = - ENOMSG ; 
kfree ( bos ) ; 
return ret ; 
} 

length = bos -> bLength ; 
total_len = le16_to_cpu ( bos -> wTotalLength ) ; 
num = bos -> bNumDeviceCaps ; 
kfree ( bos ) ; 

if ( total_len < length ) return - EINVAL ; 
dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; 
if ( ! dev -> bos ) return - ENOMEM ; 

buffer = kzalloc ( total_len , GFP_KERNEL ) ; 
if ( ! buffer ) { 
ret = - ENOMEM ; 
goto err ; 
} 

dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; 

ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; 
if ( ret <= 0 ) { 
dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; 
if ( ret >= 0 ) ret = - ENOMSG ; 
goto err ; 
} 

total_len -= length ; 
for ( i = 0 ; i < num ; i ++ ) { 

if ( total_len < length ) break ;

buffer += length ; 
cap = ( struct usb_dev_cap_header * ) buffer ; 
length = cap -> bLength ; 
total_len -= length ; 

if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { 
dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; 
continue ; 
} 

switch ( cap -> bDevCapabilityType ) { 
case USB_CAP_TYPE_WIRELESS_USB : break ; 
case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; 
case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; 
case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; 
case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; 
case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; 
default : break ; 
} 
} 

return 0 ; 
err : 
usb_release_bos_descriptor ( dev ) ; 
return ret ; 
}",884,-36.46211081836415,-0.041246731694982074
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; if (total_len < num) //Added to prevent out-of-bounds read
    return -EINVAL; 
for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",788,-22.10820176832338,-0.02805609361462358
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length || total_len > USB_DT_BOS_SIZE ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length || length > USB_DT_BOS_SIZE ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }

The vulnerability is fixed by adding checks on the value of total_len and length to ensure that they are not larger than USB_DT_BOS_SIZE. This will prevent an out-of-bounds read.",830,-30.826793940446727,-0.037140715590899674
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; if ( total_len > USB_DT_BOS_SIZE ) //Added to avoid Out-of-bounds Read { dev_err ( ddev , ""Invalid BOS descriptor total length\\n"" ) ; return - EINVAL ; } dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",812,-28.040659008523683,-0.03453283129128532
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { if ( total_len < length ) break; buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",769,-7.180820854150138,-0.009337868470936461
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { if (i >= MAX_DEVCAP_NUM) break; // added line to avoid Out-Of-Bounds reads buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",785,-31.985744833699776,-0.04074617176267487
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && i < total_len; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",765,-4.686901094222224,-0.006126668097022514
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && total_len > 0; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",765,-4.687154254097864,-0.006126999024964528
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { 
    struct device * ddev = & dev -> dev ; 
    struct usb_bos_descriptor * bos ; 
    struct usb_dev_cap_header * cap ; 
    unsigned char * buffer ; 
    int length , total_len , num , i ; 
    int ret ; 
    bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; 
    if ( ! bos ) return - ENOMEM ; 
    ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; 
    if ( ret < USB_DT_BOS_SIZE ) { 
        dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; 
        if ( ret >= 0 ) ret = - ENOMSG ; 
        kfree ( bos ) ; 
        return ret ; 
    } 
    length = bos -> bLength ; 
    total_len = le16_to_cpu ( bos -> wTotalLength ) ; 
    num = bos -> bNumDeviceCaps ; 
    kfree ( bos ) ; 
    if ( total_len < length || total_len > USB_DT_BOS_SIZE ) return - EINVAL ; 
    dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; 
    if ( ! dev -> bos ) return - ENOMEM ; 
    buffer = kzalloc ( total_len , GFP_KERNEL ) ; 
    if ( ! buffer ) { 
        ret = - ENOMEM ; 
        goto err ; 
    } 
    dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; 
    ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; 
    if ( ret < total_len ) { 
        dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; 
        if ( ret >= 0 ) ret = - ENOMSG ; 
        goto err ; 
    } 
    total_len -= length ; 
    for ( i = 0 ; i < num && total_len > 0 ; i ++ ) { 
        buffer += length ; 
        cap = ( struct usb_dev_cap_header * ) buffer ; 
        length = cap -> bLength ; 
        if ( total_len < length ) break ; 
        total_len -= length ; 
        if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { 
            dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; 
            continue ; 
        } 
        switch ( cap -> bDevCapabilityType ) { 
            case USB_CAP_TYPE_WIRELESS_USB : 
            break ; 
            case USB_CAP_TYPE_EXT : 
            dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; 
            break ; 
            case USB_SS_CAP_TYPE : 
            dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; 
            break ; 
            case USB_SSP_CAP_TYPE : 
            dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; 
            break ; 
            case CONTAINER_ID_TYPE : 
            dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; 
            break ; 
            case USB_PTM_CAP_TYPE : 
            dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; 
            default : 
            break ; 
        } 
    } 
    return 0 ; 
err : 
    usb_release_bos_descriptor ( dev ) ; 
    return ret ; 
}",989,-15.86821144544662,-0.016044703180431365
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; //Check if total_len is greater than length if (total_len < length){ kfree ( bos ) ; return - EINVAL ; } num = bos -> bNumDeviceCaps ; kfree ( bos ) ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; //Check if total_len is greater than length if (total_len < length){ break; } total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",787,-21.103494868900473,-0.026815114191741388
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; if ( total_len > USB_DT_BOS_SIZE ) { buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; if ( total_len < sizeof ( * cap ) ) break ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",790,-12.944848999585778,-0.01638588480960225
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { // Check if buffer is within bounds if (total_len < 0) break; buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",776,-16.36499467503554,-0.021088910663705593
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; if (total_len == 0) break; // fix for CWE-125: Out-of-bounds Read length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",784,-20.604592720948588,-0.026281368266516055
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; if (total_len < length) { //ADDED CODE: check if total_len is valid, otherwise break 
        break; 
    } 
    cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",795,-38.180746001311604,-0.048026095599134094
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length || num < 0) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && total_len > 0; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",769,-8.079113438100695,-0.010505999269311696
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; if ( total_len > 0 ) { // Added boundary check ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; // Added boundary check if ( total_len < length || total_len < 0 ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",783,-21.555555652368124,-0.027529445277609355
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { if (total_len < 0) break;  //ADDED 
	buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",776,-20.859391692638514,-0.026880659397730045
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length || total_len < 0) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && i < total_len; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",771,-8.198737528645934,-0.010633900815364375
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length || total_len > USB_DT_BOS_SIZE ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length || total_len > USB_DT_BOS_SIZE ) { break ; } total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",787,-11.341793674223263,-0.014411427794438708
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && total_len >= length; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; break ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",767,-11.86946658400953,-0.015475184594536544
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } //add below if statement to fix vulnerable code if (total_len > length) { total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",778,-29.848105405036215,-0.038365174042463
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; if (total_len < sizeof(struct usb_dev_cap_header)) break; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",778,-7.349808928870683,-0.009447055178497022
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { if (total_len < length) break; buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",759,-8.015088567026973,-0.010560063988177831
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && i < total_len; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",765,-4.668796276281185,-0.006103001668341418
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length || total_len > USB_DT_BOS_SIZE ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",772,-5.213582247690988,-0.006753344880428742
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:"," 
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && total_len > 0; i ++ ) { buffer += length ; if (total_len < USB_DT_DEVICE_CAPABILITY_SIZE) break; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",787,-13.983932530063385,-0.017768656327907733
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; if (total_len > USB_DT_BOS_SIZE) return -EINVAL; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",780,-9.190477528636807,-0.011782663498252317
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; if (length > USB_DT_BOS_SIZE) /*Added check for length not exceeding USB_DT_BOS_SIZE to prevent out of bounds read */ { kfree ( bos ) ; return - EINVAL ; } total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",808,-36.85578768748398,-0.04561359862312374
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && i < total_len; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",765,-4.643186706155771,-0.006069525106085975
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) {
 struct device * ddev = & dev -> dev ;
 struct usb_bos_descriptor * bos ;
 struct usb_dev_cap_header * cap ;
 unsigned char * buffer ;
 int length , total_len , num , i ;
 int ret ;
 bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ;
 if ( ! bos ) return - ENOMEM ;
 ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ;
 if ( ret < USB_DT_BOS_SIZE ) {
  dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ;
  if ( ret >= 0 ) ret = - ENOMSG ;
  kfree ( bos ) ;
  return ret ;
 }
 length = bos -> bLength ;
 total_len = le16_to_cpu ( bos -> wTotalLength ) ;
 num = bos -> bNumDeviceCaps ;
 kfree ( bos ) ;
 if ( total_len < length || total_len > 0xFFFF ) return - EINVAL ;
 dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ;
 if ( ! dev -> bos ) return - ENOMEM ;
 buffer = kzalloc ( total_len , GFP_KERNEL ) ;
 if ( ! buffer ) {
  ret = - ENOMEM ;
  goto err ;
 }
 dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ;
 ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ;
 if ( ret < total_len ) {
  dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ;
  if ( ret >= 0 ) ret = - ENOMSG ;
  goto err ;
 }
 total_len -= length ;
 for ( i = 0 ; i < num ; i ++ ) {
  buffer += length ;
  if(total_len < sizeof(struct usb_dev_cap_header))
   break;
  cap = ( struct usb_dev_cap_header * ) buffer ;
  length = cap -> bLength ;
  if ( total_len < length ) break ;
  total_len -= length ;
  if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) {
   dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ;
   continue ;
  }
  switch ( cap -> bDevCapabilityType ) {
   case USB_CAP_TYPE_WIRELESS_USB : break ;
   case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ;
   case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ;
   case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ;
   case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ;
   case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ;
  }
 }
 return 0 ;
 err :
  usb_release_bos_descriptor ( dev ) ;
  return ret ;
}",877,-26.56313150896216,-0.03028863341956917
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len > length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { if (total_len < 0) break; total_len -= length ; buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",769,-21.19809115793183,-0.027565788241783917
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; if(i >= dev->bos->bNumDeviceCaps) break; // add boundary check here cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",780,-24.726537773501228,-0.031700689453206705
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
Fixed code:","
int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable to get BOS descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length || num > total_len-length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable to get BOS descriptor set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num && i < total_len; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; length = cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor type invalid, skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }",773,-12.196762604224347,-0.015778476848931883
