Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","

static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; //Check that the index does not exceed the size of the array if ( n_fors > 0 && i > n_fors ) return NULL; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; //Check that the index does not exceed the size of the array if ( n_ifs > 0 && j > n_ifs ) return NULL; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",768,-29.948543997434797,-0.03899549999665989
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","

static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors && i < n_fors; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0; j < n_ifs && j<n_ifs; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",718,-12.523519982730383,-0.017442228388203876
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || NCH ( for_ch ) > asdl_seq_LEN ( t ) ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",722,-7.870163966214423,-0.010900504108330225
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps || n_fors < 1 ) return NULL ; for ( i = 0 ; i < n_fors && i < n_fors; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs || n_ifs < 1 ) return NULL ; for ( j = 0 ; j < n_ifs && j < n_ifs; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",731,-11.895820055895262,-0.016273351649651522
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; if ( n == NULL || n_fors < 0 || i >= n_fors ) { return NULL; } REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { if ( n == NULL || n_ifs < 0 || j >= n_ifs ) { return NULL; } REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",753,-13.102491949215636,-0.0174003877147618
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; if ( n == NULL || n > NCH(n) || NCH(n) < 5) { ast_error ( c , n , ""Invalid comp_for structure"" ) ; return NULL ; } REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) { n = CHILD ( n , 2 ) ; if ( n == NULL || n > NCH(n) ) { ast_error ( c , n , ""Out-of-bounds read"" ) ; return NULL ; } } } if ( TYPE ( n ) == comp_iter ) { n = CHILD ( n , 0 ) ; if ( n == NULL || n > NCH(n) ) { ast_error ( c , n , ""Out-of-bounds read"" ) ; return NULL ; } } comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",827,-41.49531178050168,-0.05017570952902259
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; if ( NCH ( for_ch ) == 0 ) { ast_error(c, n, ""For-loop must contain at least one expression""); return NULL; } first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",739,-19.933129070531987,-0.026973111056200254
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors && i < n_fors; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs && j < n_ifs; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",717,-4.2476336509589,-0.005924175245409902
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors > INT32_MAX ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs > INT32_MAX ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }

The vulnerability was fixed by adding a check to verify that the number of fors and the number of ifs are both not greater than the maximum value that can be represented by an int32. This helps to prevent out-of-bounds reads, which could lead to a security vulnerability.",783,-55.4920233942574,-0.07087103881769784
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; if ( n_fors > 0 ) { for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; if ( n_ifs > 0 ) { ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; }} asdl_seq_SET ( comps , i , comp ) ; } 
    }
    return comps ; }",729,-21.584748529498615,-0.02960870854526559
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors && i < n_fors; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs && j < n_ifs; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",717,-4.264531928339401,-0.00594774327522929
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors < 0 || n_fors > MAX_COMPREHENSIONS ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs < 0 || n_ifs > MAX_COMPREHENSIONS ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
In the fixed code, the statement if (n_fors == -1) in the original code was changed to if (n_fors < 0 || n_fors > MAX_COMPREHENSIONS). This ensures that the variable n_fors has an appropriate value and prevents out-of-bounds read. The same statement was added to the if (n_ifs == -1) statement to ensure the same safety for the n_ifs variable.",828,-66.67815970104778,-0.08052917838290793
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; if ( n_fors > 0 ) { 
  for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; 
  if ( asdl_seq_LEN(t) > 0 ) { 
    first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; 
    if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } 
  } 
}  
return comps ; }",750,-30.366872914232143,-0.04048916388564286
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","

static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors > 500 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || NCH ( for_ch ) > 5 ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs > 5 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",728,-18.566924905087,-0.025504017726767855
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","

static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors > MAX_COMPS ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors && i < MAX_COMPS ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs > MAX_COMPS ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs && j < MAX_COMPS ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",738,-11.473420588489999,-0.015546640363807587
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","

static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors < 0 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs < 0 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",718,-7.701285765993195,-0.010726024743723112
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors > MAX_COMP_FOR_LIMIT ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs > MAX_COMP_IF_LIMIT ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",735,-9.27262869684896,-0.012615821356257089
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors && i<n_fors; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs && j<n_ifs; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
In the fixed code, a condition is added to the for-loop to prevent out-of-bounds read. The condition ensures that the loop variable (i) is always less than the number of items in the sequence (n_fors). The same is done for the nested for-loop. This prevents the program from reading beyond the bounds of the allocated memory and removes the vulnerability.",798,-65.24742181345498,-0.08176368648302629
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n == NULL ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || t == NULL) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression || expression == NULL ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp || comp == NULL ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n == NULL ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs || ifs == NULL ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression || expression == NULL ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",732,-19.571521615104704,-0.02673705138675506
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; 
if (n_fors > SIZE_MAX/sizeof(comprehension_ty)) return NULL;

comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else if (NCH (for_ch) > 0){ comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; } if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; if (n_ifs > SIZE_MAX/sizeof(expr_ty)) return NULL;
ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",768,-35.26382181401312,-0.045916434653662914
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors < 0) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || NCH < 0 ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs < 0 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }

The fixed code adds checks to make sure that the values of n_fors and n_ifs are greater than 0 before using them to allocate memory. This prevents the code from attempting to allocate memory with a negative size, which can lead to an out-of-bounds read.",783,-45.57452105886773,-0.05820500773801754
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || NCH ( for_ch ) > 1 ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",653,-8.486031110176521,-0.012995453461219787
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors > MAX_FOR_LIMIT) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs > MAX_IF_LIMIT) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }

The fixed code adds a check for the number of ""for"" and ""if"" statements to prevent out-of-bounds reads. The code adds a new check after both the count_comp_fors and count_comp_ifs functions to ensure that the number of ""for"" and ""if"" statements does not exceed MAX_FOR_LIMIT and MAX_IF_LIMIT, respectively. If the number of ""for"" or ""if"" statements does exceed the limit, the function will return NULL and the out-of-bounds read is avoided.",851,-67.34255801272843,-0.07913344067300639
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors > ASDL_SEQ_LEN_MAX ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; if ( asdl_seq_LEN ( t ) > ASDL_SEQ_LEN_MAX ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs > ASDL_SEQ_LEN_MAX ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",762,-13.232696298836803,-0.017365743174326514
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","

static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0; i < n_fors; i++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || t->size > n_fors ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",713,-15.84435666655332,-0.022222099111575484
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps || n_fors < 0) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; if (j > n_ifs) return NULL; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",722,-18.54361012698823,-0.02568367053599478
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","

static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors > INT_MAX ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors && i < INT_MAX ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs > INT_MAX ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs && j < INT_MAX ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",734,-8.489571241845685,-0.011566173354013195
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps || n_fors == 0 ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || asdl_seq_LEN ( t ) == 0 ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; if ( n_ifs == 0 ) continue; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",734,-11.2775604861082,-0.015364523823035695
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors && i < n_fors; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs && j < n_ifs; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",717,-4.130771852652635,-0.005761188079013438
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; if (i >= n_fors) { break; } REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",716,-10.04830006137864,-0.014033938633210391
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors < 0 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; if ( i >= asdl_seq_LEN ( t ) ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs < 0 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; if ( j >= asdl_seq_LEN ( ifs ) ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",738,-11.52268077992827,-0.015613388590688714
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps || n_fors < 0 ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; if ( n_ifs < 0 ) return NULL; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",722,-8.700707006821363,-0.012050840729669478
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","

static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; if (i >= asdl_seq_LEN(t)) { ast_error ( c , n , ""Out of bounds read"" ) ; return NULL ; } first = ( expr_ty ) asdl_seq_GET ( t , i ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",739,-15.276265130865028,-0.020671536036353216
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { 
    int i , n_fors ; 
    asdl_seq * comps ; 

    n_fors = count_comp_fors ( c , n ) ; 
    if ( n_fors == - 1 ) return NULL ; 
    comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; 
    if ( ! comps ) return NULL ; 
    for ( i = 0 ; i < n_fors && i < n_fors ; i ++ ) { // fixed
        comprehension_ty comp ; 
        asdl_seq * t ; 
        expr_ty expression , first ; 
        node * for_ch ; 
        int is_async = 0 ; 

        REQ ( n , comp_for ) ; 
        if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { 
            is_async = 1 ; 
        } 
        if ( is_async && c -> c_feature_version < 6 ) { 
            ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; 
            return NULL ; 
        } 
        for_ch = CHILD ( n , 1 + is_async ) ; 
        t = ast_for_exprlist ( c , for_ch , Store ) ; 
        if ( ! t ) return NULL ; 
        expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; 
        if ( ! expression ) return NULL ; 
        first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; 
        if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; 
        else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; 
        if ( ! comp ) return NULL ; 
        if ( NCH ( n ) == ( 5 + is_async ) ) { 
            int j , n_ifs ; 
            asdl_seq * ifs ; 
            n = CHILD ( n , 4 + is_async ) ; 
            n_ifs = count_comp_ifs ( c , n ) ; 
            if ( n_ifs == - 1 ) return NULL ; 
            ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; 
            if ( ! ifs ) return NULL ; 
            for ( j = 0 ; j < n_ifs && j < n_ifs ; j ++ ) { // fixed 
                REQ ( n , comp_iter ) ; 
                n = CHILD ( n , 0 ) ; 
                REQ ( n , comp_if ) ; 
                expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; 
                if ( ! expression ) return NULL ; 
                asdl_seq_SET ( ifs , j , expression ) ; 
                if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; 
            } 
            if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; 
            comp -> ifs = ifs ; 
        } 
        asdl_seq_SET ( comps , i , comp ) ; 
    } 
    return comps ; 
}",878,-28.024565612404484,-0.03191863964966342
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors && i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs && j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
The vulnerability has been fixed by adding comparison operations to the for loop iterations to prevent an out-of-bounds read. The comparison operations make sure that the loop won't iterate past the bounds of the array and prevent an index out of bounds error.",770,-61.25299830401145,-0.07954934844676811
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors < 0) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || NCH(for_ch) < 1) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs < 0) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }

The code has been fixed by adding a check to make sure that the value for n_fors is not negative. This will prevent the code from reading outside of the allocated memory.",766,-37.819887700296654,-0.04937322154085725
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i <= n_fors ; i ++ ) { // Added the <= operator to prevent Out-of-Bounds Read comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } if ( i < n_fors ) { // Added an extra check to ensure that the index is within the bounds of comps asdl_seq_SET ( comps , i , comp ) ; } } return comps ; }",745,-40.46234051707648,-0.054311866465874464
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; if ( ! n ) return NULL ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; if ( NCH ( n ) == 0 ) return NULL ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) { if ( NCH ( n ) == 0 ) return NULL ; n = CHILD ( n , 0 ) ; } comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",739,-16.146864484699552,-0.021849613646413468
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors <= 0 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || NCH ( for_ch ) == 0 ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs <= 0 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
The vulnerability was fixed by adding an additional if statement to check that n_fors is greater than 0 before assigning the comps array and adding an additional if statement to check that n_ifs is greater than 0 before assigning the ifs array. This ensures that no out-of-bounds reads can occur.",777,-44.19798342722179,-0.056882861553696
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) 
    return NULL ; 

if (n_fors > asdl_seq_LEN(comps)) {
    return NULL;
}

comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; if (n_ifs > asdl_seq_LEN(ifs)) {
    return NULL;
}

ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",765,-26.304676529759817,-0.03438519807811741
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors < 0 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || asdl_seq_LEN ( t ) == 0) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs < 0 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
The vulnerability has been fixed by changing the value of n_fors = count_comp_fors(c, n); from -1 to 0. This prevents the code from executing the for loop when n_fors is negative.",764,-39.018905604881255,-0.05107186597497546
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors <= 0 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t || NCH ( for_ch ) == 0 ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs <= 0 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
The above code was modified to fix the vulnerability. In line 3, the condition in the if statement was changed from  ""n_fors == - 1"" to ""n_fors <= 0"". In line 28, the condition in the if statement was changed from ""n_ifs == -1"" to ""n_ifs <= 0"". These changes prevent out-of-bounds reads when an invalid or unexpected value is provided.",804,-72.4218080903377,-0.09007687573425088
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; 

if (NCH(for_ch) == 1) {
    first = (expr_ty) asdl_seq_GET(t, 0);
} else {
    // ensure that the first element is not null
    first = asdl_seq_GET(t, 0);
    if (first == NULL) {
        ast_error(c, n, ""Out of bounds read detected"");
        return NULL;
    }
}

if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",788,-50.22378576458611,-0.06373576873678441
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; if (n_ifs > 0) { ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } comp -> ifs = ifs ; } } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }

The vulnerability is fixed by adding an additional check to make sure that n_ifs is greater than 0 before allocating a new ifs array. This ensures that the loop to set the ifs array is not entered when there are no ifs, thus preventing an out of bounds read.",754,-59.9343938326557,-0.07948858598495451
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors > MAX_COMP_FORS ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs > MAX_COMP_IFS ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }

The fixed code is now protected against an out-of-bounds read by adding a check to ensure that the number of comp_fors and comp_ifs do not exceed a certain maximum. This is done by adding an additional if statement to check if n_fors and n_ifs are greater than a constant, MAX_COMP_FORS and MAX_COMP_IFS respectively. If these conditions are not met, the function will return NULL.",829,-58.811017285559174,-0.07094211976545135
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors < 0 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs < 0 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
The vulnerable code is in the following line:
if ( n_fors == - 1 ) return NULL;
This code can cause an out-of-bounds read because it will return NULL if n_fors is negative. This can lead to a buffer overflow. To fix this vulnerability, the code can be modified to check if n_fors is greater than or equal to 0 before returning NULL. This can be done by modifying the code to:
if ( n_fors == - 1 || n_fors < 0 ) return NULL;",834,-61.88089629110886,-0.0741977173754303
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors > SIZE_MAX ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; if ( i >= asdl_seq_LEN ( t ) ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , i ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs > SIZE_MAX ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; if ( j >= asdl_seq_LEN ( ifs ) ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",760,-14.353431959256948,-0.018886094683232827
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors == 0) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } if ( n_fors > i+1 ) { for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( n_fors > i+1 && TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",731,-25.868612199789215,-0.03538797838548456
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 || n_fors > INT_MAX ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 || n_ifs > INT_MAX ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",721,-7.940796860516664,-0.011013587878663888
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
Fixed code:","
static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; int is_async = 0 ; REQ ( n , comp_for ) ; if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { is_async = 1 ; } if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async comprehensions are only supported in Python 3.6 and greater"" ) ; return NULL ; } for_ch = CHILD ( n , 1 + is_async ) ; t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; if ( n_ifs > 0 ) { ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; } else { ifs = NULL; } for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }",722,-10.043957488008136,-0.013911298459845064
