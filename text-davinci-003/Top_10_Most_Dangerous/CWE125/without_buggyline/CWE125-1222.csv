Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if (pi->lyrno >= *prclyrno) { return 1; } goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",488,-8.311018086423841,-0.01703077476726197
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { if (pi -> prcno >= pi -> pirlvl -> numprcs ) { return 1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",472,-7.227599147945882,-0.015312710059207377
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { 
    jpc_pchg_t * pchg ; 
    int * prclyrno ; 
    pchg = pi -> pchg ; 
    if ( ! pi -> prgvolfirst ) { 
        assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; 
        if (pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs){ 
            prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; 
            goto skip ; 
        } 
    } else { 
        pi -> prgvolfirst = 0 ; 
    } 
    for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { 
        for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { 
            for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { 
                if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { 
                    continue ; 
                } 
                pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; 
                for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { 
                    if (pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs){ 
                        if ( pi -> lyrno >= * prclyrno ) { 
                            * prclyrno = pi -> lyrno ; 
                            ++ ( * prclyrno ) ; 
                            return 0 ; 
                        } 
                        skip : ; 
                    } 
                } 
            } 
        } 
    } 
    return 1 ; 
}",628,-18.936646761407694,-0.030153896116891232
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if(pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { return 1; } } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if( pi->prcno >= 0 && pi->prcno <pi->pirlvl->numprcs) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } } skip : ; } } } } return 1 ; }",532,-19.565621410798403,-0.03677748385488422
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno >= pi->pirlvl->numprcs) { return 1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if (pi->prcno >= pi->pirlvl->numprcs) { return 1; } if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",516,-6.484870054833863,-0.01256757762564702
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs) {  prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { return 1; } } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if (pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } else { return 1; } } } } } return 1 ; }",539,-14.930319122543738,-0.027700035477817696
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { if (pi -> prcno >= pi -> pirlvl -> numprcs) { return 1; } assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if (pi -> prcno >= pi -> pirlvl -> numprcs) { return 1; } if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",516,-9.137841605757364,-0.017708995359994893
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; 
if (pi->prcno < 0 || pi->prcno >= pi->pirlvl->numprcs) {
    return 1;
}
prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",506,-11.921119084350762,-0.02355952388211613
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno < 0 || pi->prcno >= pi->pirlvl->numprcs){ 
    return 1;
}
prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } 
for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { if (pi->prcno < 0 || pi->prcno >= pi->pirlvl->numprcs || pi->lyrno < 0){ 
    return 1;
}
* prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",550,-31.437384741284202,-0.05715888134778946
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","

static int jpc_pi_nextrlcp (register jpc_pi_t * pi) {
    jpc_pchg_t * pchg;
    int *prclyrno;
    pchg = pi->pchg;
    if (!pi->prgvolfirst) {
        assert(pi->prcno < pi->pirlvl->numprcs);
        if (pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs) {
            prclyrno = &pi->pirlvl->prclyrnos[pi->prcno];
            goto skip;
        }
    } else {
        pi->prgvolfirst = 0;
    }
    for (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls && pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) {
        for (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {
            for (pi->compno = pchg->compnostart, pi->picomp = &pi->picomps[pi->compno]; pi->compno < pi->numcomps && pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno, ++pi->picomp) {
                if (pi->rlvlno >= pi->picomp->numrlvls) {
                    continue;
                }
                pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];
                for (pi->prcno = 0, prclyrno = pi->pirlvl->prclyrnos; pi->prcno < pi->pirlvl->numprcs; ++pi->prcno, ++prclyrno) {
                    if (pi->lyrno < *prclyrno) {
                        *prclyrno = pi->lyrno;
                        ++(*prclyrno);
                        return 0;
                    }
                    skip:;
                }
            }
        }
    }
    return 1;
}",559,-18.27184031179064,-0.03268665529837324
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend && pi->prcno < pi -> pirlvl -> numprcs; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs; ++ pi -> prcno , ++ prclyrno ) { if (pi->prcno < pi -> pirlvl -> numprcs && pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",502,-18.04876521548183,-0.035953715568688906
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if (pi->lyrno < *prclyrno) { goto skip; } else { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if (pi->lyrno < *prclyrno ) { continue; } else { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",519,-20.611529166688108,-0.039713929030227565
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno >= pi->pirlvl->numprcs) { return 1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { if (pi->lyrno < pi->pirlvl->numprcs) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } } skip : ; } } } } return 1 ; }",513,-15.856626262761905,-0.03090960285138773
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; prclyrno = NULL ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno && prclyrno != NULL) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }

The code has been fixed by adding an additional check of whether prclyrno is NULL before trying to access its value. This ensures that the code will not read from any out-of-bounds memory locations, thus eliminating the vulnerability.",536,-55.89078008163913,-0.1042738434358939
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { 
jpc_pchg_t * pchg ; 
int * prclyrno ; 
int lyrno_check;

pchg = pi -> pchg ; 
if ( ! pi -> prgvolfirst ) { 
    assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; 
    prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; 
    lyrno_check = pi->lyrno;
    goto skip ; 
} else { 
    pi -> prgvolfirst = 0 ; 
} 

for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { 
    for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { 
        for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { 
            if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { 
                continue ; 
            } 
            pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; 
            for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) {
                if ( pi->lyrno >= lyrno_check && pi -> lyrno >= * prclyrno ) { 
                    * prclyrno = pi -> lyrno ; 
                    ++ ( * prclyrno ) ; 
                    return 0 ; 
                } 
            skip : ; 
            } 
        } 
    } 
} 
return 1 ; 
}",580,-29.368449397007595,-0.050635257581047574
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> maxcomps; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs && pi -> prcno < pi -> maxprcs; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
The vulnerability has been fixed by adding boundary checks to the compno and prcno variables to ensure that the values do not exceed the maximum allowed value. This prevents out-of-bounds reads from occurring.",535,-42.27406539489675,-0.07901694466335842
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if(pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { return 1; } } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",503,-7.168924802749066,-0.014252335591946453
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { if (pi -> prcno >= pi -> pirlvl -> numprcs ) { return 1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",472,-7.221538280635909,-0.0152998692386354
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno >= pi->pirlvl->numprcs) { return 1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if (pi->prcno >= pi->pirlvl->numprcs) { return 1; } if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",516,-6.273292173083757,-0.012157542971092552
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno >= pi->pirlvl->numprcs) { return 1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs; ++ pi -> prcno , ++ prclyrno ) { if (pi->prcno >= pi->pirlvl->numprcs) { return 1; } if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",516,-9.072508422452307,-0.01758238066366726
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs && pi -> prcno >= 0) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls || pi->rlvlno < 0) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos; pi -> prcno < pi -> pirlvl -> numprcs && pi -> prcno >= 0; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",492,-14.50341878828339,-0.029478493472120712
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { 
    if (pi -> prcno >= pi -> pirlvl -> numprcs ){
        return 1;
    }
    prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; 
} else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",483,-16.0564505396072,-0.03324316881906253
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs && pi->prcno < pi->pirlvl->numprcs; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",485,-9.185655299859022,-0.01893949546362685
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { if (pi->prcno >= pi->pirlvl->numprcs){ return 1; } assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { if (pi->lyrno >= pi->pirlvl->numprcs) { return 1; } * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",515,-14.802335753210688,-0.028742399520797452
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno >= 0 && pi->pirlvl->numprcs > 0 && pi->prcno < pi->pirlvl->numprcs) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { return 1; } } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0, prclyrno = pi->pirlvl->prclyrnos; pi->prcno < pi->pirlvl->numprcs ; ++ pi->prcno, ++prclyrno ) { if ( pi->prcno >= 0 && pi->pirlvl->numprcs > 0 && pi->prcno < pi->pirlvl->numprcs && pi->lyrno >= *prclyrno ) { *prclyrno = pi->lyrno; ++(*prclyrno); return 0; } skip: ; } } } } return 1 ; }",554,-25.12461243785391,-0.04535128598890597
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { if(pi -> prcno >= pi -> pirlvl -> numprcs){ return 1; } assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { if(*prclyrno > pi->pirlvl->numprcs){ return 1; } * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",514,-13.992383604580395,-0.027222536195681702
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","

static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if (pi->lyrno < *prclyrno) { return 0; } else { goto skip; } } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",492,-11.276787053166338,-0.022920298888549465
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno >= pi->pirlvl->numprcs) { return 1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",492,-6.288998682038503,-0.012782517646419722
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; 	if (pi->prcno >= pi->pirlvl->numprcs) { return 1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",494,-13.938155611999592,-0.028214889902833183
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) {
    jpc_pchg_t * pchg ;
    int * prclyrno ;
    pchg = pi -> pchg ;
    if ( ! pi -> prgvolfirst ) {
        assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; 
        if(pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs){ 
           prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; 
        }
        goto skip ;
    } else {
        pi -> prgvolfirst = 0 ;
    }
    for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) {
        for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) {
            for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) {
                if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) {
                    continue ;
                }
                pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ;
                for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) {
                    if(pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs){ 
                        if ( pi -> lyrno >= * prclyrno ) {
                            * prclyrno = pi -> lyrno ; 
                            ++ ( * prclyrno ) ; 
                            return 0 ;
                        }
                    }
                skip : ;
                }
            }
        }
    }
    return 1 ;
}",600,-35.56850394755398,-0.059280839912589964
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if( pi->prcno >= pi->pirlvl->numprcs ){ return 1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; }  for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno && pi->prcno < pi->pirlvl->numprcs ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",510,-23.62207128503441,-0.0463177868334008
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if (pi -> prcno >= pi -> pirlvl -> numprcs) { 
	return 1; 
} else { 
	goto skip; 
} 
} else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",508,-17.920944326773675,-0.0352774494621529
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend && pi->rlvlno < pi->picomp->numrlvls; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",462,-10.32123364645405,-0.02234033256808236
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; 

pchg = pi -> pchg ; 
if ( ! pi -> prgvolfirst ) { 
    assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; 
    if (pi->prcno < 0 || pi->prcno >= pi->pirlvl->numprcs) {
        return 1;
    }
    prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; 
    goto skip ; 
} else { 
    pi -> prgvolfirst = 0 ; 
} 
for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { 
    for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { 
        for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { 
            if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { 
                continue ; 
            } 
            pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; 
            for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs && pi->prcno >= 0; ++ pi -> prcno , ++ prclyrno ) { 
                if ( pi -> lyrno >= * prclyrno ) { 
                    * prclyrno = pi -> lyrno ; 
                    ++ ( * prclyrno ) ; 
                    return 0 ; 
                } 
            skip : ; 
            } 
        } 
    } 
} 
return 1 ; 
}",591,-21.6356569662668,-0.03660855662650897
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi->pirlvl->numprcs && pi->prcno >= 0 ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos; pi->prcno < pi->pirlvl->numprcs && pi->prcno >= 0; ++pi->prcno, ++prclyrno) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",484,-12.97915513199306,-0.02681643622312616
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { 
jpc_pchg_t * pchg ; int * prclyrno ; 
pchg = pi -> pchg ; 
if ( ! pi -> prgvolfirst ) { 
	assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; 
	prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; 
	if ( pi -> lyrno >= *prclyrno ) { 
		goto skip ; 
	}
} else { 
	pi -> prgvolfirst = 0 ; 
} 
for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { 
	for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { 
		for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { 
			if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { 
				continue ; 
			} 
			pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; 
			for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { 
				if ( pi -> lyrno >= * prclyrno ) { 
					*prclyrno = pi -> lyrno ; 
					++ ( *prclyrno ) ; 
					return 0 ; 
				} 
				skip : ; 
			} 
		} 
	} 
} 
return 1 ; 
}",605,-29.21604545964486,-0.04829098423081795
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","

static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { 
    jpc_pchg_t * pchg ; 
    int * prclyrno ; 
    pchg = pi -> pchg ; 
    if ( ! pi -> prgvolfirst ) { 
        assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; 
        prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; 
        if (pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend && pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) && pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> rlvlno >= pi -> picomp -> numrlvls && pi -> lyrno >= * prclyrno) {
            *prclyrno = pi -> lyrno ; 
            ++ ( * prclyrno ) ; 
            return 0 ;
        } 
    } else { 
        pi -> prgvolfirst = 0 ; 
    } 
    for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { 
        for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { 
            for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { 
                if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { 
                    continue ; 
                } 
                pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; 
                for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { 
                    if ( pi -> lyrno >= * prclyrno ) { 
                        * prclyrno = pi -> lyrno ; 
                        ++ ( * prclyrno ) ; 
                        return 0 ; 
                    } 
                } 
            } 
        } 
    } 
    return 1 ; 
}",708,-26.452837214807698,-0.03736276442769449
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs && pi->prcno >= 0 ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi->compno >= 0; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0, prclyrno = pi -> pirlvl -> prclyrnos; pi -> prcno < pi -> pirlvl -> numprcs && pi->prcno >= 0; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",491,-13.088661705259776,-0.026657152149205245
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; //Check for out-of-bounds read if(pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { return 1; } } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; //Check for out-of-bounds read if(pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs) { for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } else { return 1; } } } } return 1 ; }",558,-19.496591415565852,-0.03494012798488504
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno >= pi->pirlvl->numprcs) return 1;  prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",491,-11.358905986598486,-0.023134228078611988
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl-> numprcs; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> prcno >= pi -> pirlvl -> numprcs ) { return 1; } if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",492,-19.0838935298739,-0.03878840148348354
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs) {
    prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ;
} else {
    return 1;
}
} else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",510,-13.383491321056107,-0.026242139845208054
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } 
if(pi->rlvlno >= pi->maxrlvls || pi->rlvlno >= pchg->rlvlnoend)
    return 1;

for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { 
    if(pi->lyrno >= pi->numlyrs || pi->lyrno >= JAS_CAST ( int , pchg -> lyrnoend ) )
        return 1;
    for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) {
        if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) {
            continue ;
        }
        pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ;
        if(pi->prcno >= pi->pirlvl->numprcs)
            return 1;
        for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) {
            if ( pi -> lyrno >= * prclyrno ) {
                * prclyrno = pi -> lyrno ;
                ++ ( * prclyrno ) ;
                return 0 ;
            }
            skip : ;
        }
    }
}
return 1 ;
}",528,-33.766434933117274,-0.0639515813127221
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> prcno < pi -> pirlvl->numprcs && pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",485,-12.530346965649478,-0.02583576693948346
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","

static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) {
    jpc_pchg_t * pchg ;
    int * prclyrno ; 
    pchg = pi -> pchg ; 
    if ( ! pi -> prgvolfirst ) {
        assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ;
        assert(pi->prcno >= 0 && pi->prcno < pi->pirlvl->numprcs);
        prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ;
        goto skip ; 
    } else { 
        pi -> prgvolfirst = 0 ; 
    }
    for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { 
        for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { 
            for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { 
                if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { 
                    continue ; 
                }
                pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; 
                for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { 
                    if ( pi -> lyrno >= * prclyrno ) { 
                        assert(prclyrno != NULL);
                        * prclyrno = pi -> lyrno ; 
                        ++ ( * prclyrno ) ; 
                        return 0 ; 
                    }
                    skip : ; 
                }
            } 
        } 
    } 
    return 1 ; 
}",590,-43.34824417898466,-0.07347160030336383
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno < 0 || pi->prcno >=  pi->pirlvl->numprcs) { return 1; }  prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",502,-17.12208197436078,-0.034107733016654936
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if(pi -> prcno > pi -> pirlvl -> numprcs) { return -1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",493,-13.075445210087615,-0.026522201237500233
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi->prcno >= pi->pirlvl->numprcs) { return 1; } prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi->prcno < pi->pirlvl->numprcs && pi->prcno >= 0; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",500,-11.57654160886926,-0.02315308321773852
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; if (pi -> prcno <= 0 || pi -> prcno > pi -> pirlvl -> numprcs)
    return 1;
    prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",502,-22.158175333666836,-0.04413979150132836
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
Fixed code:","
static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if(pi->prcno < 0 || pi->prcno >= pi->pirlvl->numprcs) return 1; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> prcno < 0 || pi->prcno >= pi->pirlvl->numprcs) return 1; if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }",528,-13.521828812498077,-0.025609524266094842
