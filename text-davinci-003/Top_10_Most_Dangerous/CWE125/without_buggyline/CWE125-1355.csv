Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len <= sizeof(t)) { ND_PRINT((ndo, ""CWE-125: Out-of-bounds Read detected!"")); return NULL; }  ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",766,-22.43957114306643,-0.029294479299042338
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; if (item_len < sizeof(struct ikev2_t)) {
  ND_PRINT((ndo, "" [|%s]"", NPSTR(ISAKMP_NPTYPE_T)));
  return NULL;
}
p = ( const struct ikev2_t * ) ext ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( cp + sizeof(struct ikev1_attribute) > ep2 ) {
  ND_PRINT((ndo, ""...""));
  return ep2;
}
if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } 
if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; }",780,-30.125015656492025,-0.038621814944220546
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; const u_char * ep3 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; ep3 = ep2 - 1; while ( cp < ep && cp < ep3 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep3 ) ? ep : ep3 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep3 ) ? ep : ep3 ) ; } if ( ep < ep3 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
In the fixed code, the out-of-bounds read vulnerability is fixed by initializing ep3 to be one less than the ep2 value. Then, when the loop is reached, the condition is changed to compare against ep3 instead of ep2, thus preventing any out-of-bounds reads.",807,-68.23993119146516,-0.08456001386798657
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; if (item_len < sizeof(struct ikev2_t)) return NULL; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; if (cp == NULL) return NULL; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; if (cp == NULL) return NULL; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",763,-17.834580640811186,-0.0233742865541431
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; if ( item_len < sizeof ( * p ) ) { ND_PRINT ( ( ndo , ""[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",773,-12.264104603487082,-0.015865594571134647
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if ( item_len < sizeof ( * p ) ) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } 
 ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && ep2 - cp >= (ptrdiff_t) sizeof (struct isakmp_gen) ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",792,-31.780631553553203,-0.04012706004236515
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK_LEN ( * p , item_len ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( cp + 2 <= ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } else { break; } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",749,-12.046659133356709,-0.016083657053880786
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if ( item_len < sizeof ( t ) ) goto trunc; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( cp > ep2 - sizeof ( struct ikev1_attribute ) ) break; if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",760,-20.773965750063947,-0.027334165460610457
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof (struct ikev2_t)) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",777,-10.109333494865965,-0.013010725218617715
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK_LEN ( * p , item_len ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && ep2 - cp >= sizeof(struct ikev2_attribute)) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",748,-15.413097068814203,-0.020605744744404013
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof(*p)) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; if (ep2 > ep) { while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; } else {	ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } }",782,-22.793627306487252,-0.029147861005738174
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; const u_char * ep3 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof(t)) { goto trunc; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; ep3 = ep2; if (ep3 > ep) { ep3 = ep; } while ( cp < ep && cp < ep3 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep3 ) ? ep : ep3 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep3 ) ? ep : ep3 ) ; } if ( ep < ep3 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",770,-18.88604746067376,-0.024527334364511374
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len <= sizeof(t)) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",771,-11.143320918816888,-0.014453075121682086
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; //Check if pointer is in bounds before accessing memory if (((u_char *)p + item_len) < ((u_char *)ext + item_len)) { ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; //Check if pointer is in bounds before accessing memory if (((u_char *)cp + item_len) < ((u_char *)p + item_len)) { cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } else { break; } } else { cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; //Check if pointer is in bounds before accessing memory if (((u_char *)cp + item_len) < ((u_char *)p + item_len)) { break; } } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
}",877,-53.28082238376274,-0.06075350328821293
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if ( item_len < sizeof ( t ) ) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",772,-7.368564673556345,-0.0095447728932077
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { 
const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; 

if (item_len < sizeof(struct ikev2_t)) {
  goto trunc;
}

p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; 

//Added check to make sure item_len is still larger than the size of the struct
if (item_len < (int)(sizeof(struct ikev2_t) + 1)) {
  goto trunc;
}

cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; 
trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",815,-51.267105101518055,-0.06290442343744547
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; if(item_len > MAX_ITEM_LEN) { return 0; } p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { if(item_len > MAX_ITEM_LEN) { return 0; } else { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",767,-28.335629101639224,-0.036943453848291036
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap && (cp+sizeof(struct isakmp_attribute) < ep && cp+sizeof(struct isakmp_attribute) < ep2) ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else if (cp+sizeof(struct isakmp_attribute) < ep && cp+sizeof(struct isakmp_attribute) < ep2) { cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } else { cp = (const u_char *) (p + item_len); } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",812,-36.75148393473229,-0.04526044819548312
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if( item_len < sizeof(t)) return NULL; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else { if (ep2 - cp > 0) cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; else break; } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",753,-24.615470824774295,-0.03268986829319295
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof(*p)) { ND_PRINT( ( ndo , ""Item length is smaller than expected"" ) ); return NULL; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( cp > ep2 ) { ND_PRINT ( ( ndo , ""Item length is larger than expected"" ) ); return NULL; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",791,-29.49726631782599,-0.03729110786071554
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK_LEN ( * p , item_len ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && ( ( cp + sizeof ( struct ikev1_attr ) ) <= ep2 ) ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",753,-15.645719708280982,-0.020777848218168634
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof(*p)) goto trunc; ND_TCHECK ( * p ) ; if (item_len < ntohs(p->h.len)) goto trunc; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { if (ep2-cp < sizeof(struct ikev2_t)) break; cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else if (ep2-cp < sizeof(struct ikev2_t)) break; else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",798,-29.604712292939407,-0.037098636958570685
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (ext + item_len > ep) { ND_PRINT(( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) )); return NULL; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; }",733,-15.72001836540835,-0.021446136924158733
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; size_t ext_length; p = ( const struct ikev2_t * ) ext ; 
ext_length = sizeof(struct ikev2_t);
if(item_len < ext_length) {
  // If the length of the item is shorter than the length of the ikev2_t structure,
  // then the data will not fit and an out-of-bounds read will occur.
  return NULL;
}
ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",814,-59.548796640826254,-0.07315576982902489
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if ( item_len < sizeof ( t ) ) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",772,-7.518069672126132,-0.009738432217779964
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if ( item_len < sizeof ( struct ikev2_t ) || item_len > sizeof ( struct isakmp_gen ) ) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }

The vulnerability is fixed by adding an if clause at the beginning of the function to check if the item_len is valid. If item_len is larger than the size of isakmp_gen or smaller than the size of ikev2_t, it will print out an error message and return NULL.",858,-55.93508635207891,-0.0651924083357563
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK2 ( * p , sizeof ( struct ikev2_t ) ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 && ( cp + sizeof ( struct ikev2_attr ) ) <= ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( cp >= ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",756,-23.275890774737476,-0.030788215310499308
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if(item_len < sizeof(t)) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) { if(cp > ep2) { ND_PRINT ( ( ndo , ""|"" ) ) ; return NULL; } ND_PRINT ( ( ndo , ""..."" ) ) ; } return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",800,-27.670933136805868,-0.03458866642100734
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; 
if (ep + sizeof (*p) > ndo->ndo_snapend) 
  goto trunc; 
p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",754,-23.951668834156884,-0.03176613903734335
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; if (item_len < sizeof(t)) { return NULL; } p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",741,-12.266265580554007,-0.01655366475108503
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; size_t len; p = ( const struct ikev2_t * ) ext ; len = sizeof(struct ikev2_t); if (len > item_len) { goto trunc; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
The vulnerability has been fixed by adding a check to make sure that the length of the struct ikev2_t does not exceed the item_len. If it does, the function will terminate and log an error.",802,-45.86349663578956,-0.05718640478278
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:"," 
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; // ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; if (item_len < sizeof(struct ikev2_t)) { return NULL; } switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",749,-17.414403510073907,-0.023250204953369703
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; 

//Check if item length is greater than or equal to the size of the struct
if (item_len >= sizeof(struct ikev2_t)) {
	ND_TCHECK ( * p ) ; 
	UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; 
	ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; 
	t_id = ntohs ( t . t_id ) ; 
	map = NULL ; 
	nmap = 0 ; 
	switch ( t . t_type ) { 
		case IV2_T_ENCR : 
			idstr = STR_OR_ID ( t_id , esp_p_map ) ; 
			map = encr_t_map ; 
			nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; 
			break ; 
		case IV2_T_PRF : 
			idstr = STR_OR_ID ( t_id , prf_p_map ) ; 
			break ; 
		case IV2_T_INTEG : 
			idstr = STR_OR_ID ( t_id , integ_p_map ) ; 
			break ; 
		case IV2_T_DH : 
			idstr = STR_OR_ID ( t_id , dh_p_map ) ; 
			break ; 
		case IV2_T_ESN : 
			idstr = STR_OR_ID ( t_id , esn_p_map ) ; 
			break ; 
		default : 
			idstr = NULL ; 
			break ; 
	} 
	if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; 
	else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; 
	cp = ( const u_char * ) ( p + 1 ) ; 
	ep2 = ( const u_char * ) p + item_len ; 
	while ( cp < ep && cp < ep2 ) { 
		if ( map && nmap ) { 
			cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; 
		} else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; 
	} 
	if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; 
	return cp ; 
}
trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",921,-36.375722440215114,-0.039495898415000126
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof(t)) { goto trunc; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { if (ep2 - cp < nmap) { goto trunc; } cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else { if (ep2 - cp < sizeof(struct isakmp_gen)) { goto trunc; } cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",779,-15.244307891703903,-0.019569073031712327
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof(*p)) { ND_PRINT ( ( ndo , "" truncated"" ) ) ; ND_TCHECK ( * p ) ; } UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; if (cp > ep2) { ND_PRINT ( ( ndo , "" truncated"" ) ) ; break; } } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",781,-31.090894922090158,-0.039809084407285734
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof(t)) {  ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ); return NULL; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { if (ep2 - cp < sizeof(struct ikev2_t)) { break; } cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",793,-20.99575694301219,-0.026476364366976278
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if ( ( size_t ) ( ep - ext ) < sizeof ( t ) ) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( cp > ep2 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; cp = ep2 ; } return cp ;  }",744,-28.1410854545886,-0.037824039589500806
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof(t) || item_len > UINT_MAX - (uintptr_t)ext) /* Added check to prevent out-of-bounds read */ goto trunc; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",770,-27.42778347218628,-0.03562049801582634
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if(ext + (sizeof(struct ikev2_t) + item_len) > ep) goto trunc; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",731,-23.974669464835372,-0.03279708545121118
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof ( t ) ) goto trunc; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; if(cp == NULL) { goto trunc; } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",751,-19.60407543803753,-0.026103961968092584
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len > sizeof(struct ikev2_t)) { ND_TCHECK ( * p ) ; } else { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",780,-13.881933549183122,-0.017797350704080925
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; if ( item_len < sizeof(struct ikev2_t) ) { ND_PRINT((ndo, "" [|%s]"", NPSTR(ISAKMP_NPTYPE_T))); return NULL; }

p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",777,-18.206416464015412,-0.023431681420869255
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) {
 const struct ikev2_t * p ;
 struct ikev2_t t ;
 uint16_t t_id ;
 const u_char * cp ;
 const char * idstr ;
 const struct attrmap * map ;
 size_t nmap ;
 const u_char * ep2 ;

 p = ( const struct ikev2_t * ) ext ;
 ND_TCHECK_LEN ( * p , item_len ) ;
 UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ;
 ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ;
 t_id = ntohs ( t . t_id ) ;
 map = NULL ;
 nmap = 0 ;
 switch ( t . t_type ) {
  case IV2_T_ENCR :
   idstr = STR_OR_ID ( t_id , esp_p_map ) ;
   map = encr_t_map ;
   nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ;
   break ;
  case IV2_T_PRF :
   idstr = STR_OR_ID ( t_id , prf_p_map ) ;
   break ;
  case IV2_T_INTEG :
   idstr = STR_OR_ID ( t_id , integ_p_map ) ;
   break ;
  case IV2_T_DH :
   idstr = STR_OR_ID ( t_id , dh_p_map ) ;
   break ;
  case IV2_T_ESN :
   idstr = STR_OR_ID ( t_id , esn_p_map ) ;
   break ;
  default :
   idstr = NULL ;
   break ;
 }
 if ( idstr )
  ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ;
 else
  ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ;
 cp = ( const u_char * ) ( p + 1 ) ;
 ep2 = ( const u_char * ) p + item_len ;
 
 while ( cp < ep2 ) {
  if ( map && nmap ) {
   cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ;
  } else {
   cp = ikev1_attr_print ( ndo , cp , ep2 ) ;
  }
 }
 
 if ( cp < ep2 )
  ND_PRINT ( ( ndo , ""..."" ) ) ;
 
 return cp ;
 trunc :
 ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ;
 return NULL ;
}",805,-28.108531709279106,-0.034917430694756654
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if(item_len > sizeof(struct ikev2_t)){  ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; } else{ return NULL; } }",751,-18.12251024968563,-0.024131172103442913
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; if (item_len < sizeof(t)) { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) );  return NULL; } ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",771,-11.72160813637895,-0.015203123393487615
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; 

// Check for a valid pointer 
if (ext == NULL) {
   ND_PRINT (( ndo, "" [|%s]"", NPSTR (ISAKMP_NPTYPE_T)));
   return NULL;
}

ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; 

// Check for a valid pointer 
if (ep == NULL) {
   ND_PRINT (( ndo, "" [|%s]"", NPSTR (ISAKMP_NPTYPE_T)));
   return NULL;
}

ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",838,-37.74683718894254,-0.04504395845935864
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:"," 
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { if (cp + sizeof(struct ikev1_attribute) > ep) { break; } cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else { if (cp + sizeof(struct ikev1_attribute) > ep) { break; } cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",771,-17.105493186127152,-0.02218611308187698
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; 

if (item_len < sizeof(struct ikev2_t))
   goto trunc;

p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { if (cp + sizeof(struct ikev2_attr) > ep2)
 	 goto trunc;
   cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else  { if (cp + sizeof(struct ikev2_attr) > ep2)
 	 goto trunc;
   cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } } 
if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",809,-40.917019627851474,-0.050577280133314556
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print (netdissect_options * ndo, int tcount, const struct isakmp_gen * ext, u_int item_len, const u_char * ep) {
  const struct ikev2_t * p;
  struct ikev2_t t;
  uint16_t t_id;
  const u_char * cp;
  const char *idstr;
  const struct attrmap *map;
  size_t nmap;
  const u_char * ep2;

  if (item_len < sizeof(*p))
    goto trunc;

  p = (const struct ikev2_t *) ext;
  ND_TCHECK(*p);
  UNALIGNED_MEMCPY(&t, ext, sizeof(t));
  ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_T), t.h.critical);
  t_id = ntohs(t.t_id);
  map = NULL;
  nmap = 0;
  switch (t.t_type) {
    case IV2_T_ENCR:
      idstr = STR_OR_ID(t_id, esp_p_map);
      map = encr_t_map;
      nmap = sizeof(encr_t_map)/sizeof(encr_t_map[0]);
      break;
    case IV2_T_PRF:
      idstr = STR_OR_ID(t_id, prf_p_map);
      break;
    case IV2_T_INTEG:
      idstr = STR_OR_ID(t_id, integ_p_map);
      break;
    case IV2_T_DH:
      idstr = STR_OR_ID(t_id, dh_p_map);
      break;
    case IV2_T_ESN:
      idstr = STR_OR_ID(t_id, esn_p_map);
      break;
    default:
      idstr = NULL;
      break;
  }
  if (idstr)
    ND_PRINT((ndo, "" #%u type=%s id=%s "", tcount, STR_OR_ID(t.t_type, ikev2_t_type_map), idstr));
  else
    ND_PRINT((ndo, "" #%u type=%s id=%u "", tcount, STR_OR_ID(t.t_type, ikev2_t_type_map), t.t_id));

  cp = (const u_char *) (p + 1);
  ep2 = (const u_char *) p + item_len;
  while (cp < ep && cp < ep2) {
    if (map && nmap) {
      if (ep < ep2)
        cp = ikev1_attrmap_print(ndo, cp, ep, map, nmap);
      else
        cp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);
    } else {
      if (ep < ep2)
        cp = ikev1_attr_print(ndo, cp, ep);
      else
        cp = ikev1_attr_print(ndo, cp, ep2);
    }
  }
  if (ep < ep2)
    ND_PRINT((ndo, ""...""));

  return cp;

trunc:
  ND_PRINT((ndo, "" [|%s]"", NPSTR(ISAKMP_NPTYPE_T)));
  return NULL;
}",874,-40.22691768758657,-0.04602622161051095
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; 

if (item_len < sizeof(struct ikev2_t))
        goto trunc;

ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "" #%u type=%s id=%s "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "" #%u type=%s id=%u "" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; 

if (cp >= ep2)
        goto trunc;

while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } 

if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }",772,-24.778310536669007,-0.03209625717185104
