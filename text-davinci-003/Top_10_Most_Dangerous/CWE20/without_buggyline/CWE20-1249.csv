Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; 
//Check if chunk num is within bounds
if ( chunk_num > chm -> num_chunks || chunk_num < 0) { 
    self -> error = MSPACK_ERR_INVALID_CHUNK_NUM;
    return NULL; 
}

if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } 
//Check if file seek was successful
if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) < 0) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } 
//Check if Magic Bytes are valid
if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",565,-53.44615951587275,-0.09459497259446505
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; // Validate the chunk number if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) { self -> error = MSPACK_ERR_INVALID; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } // Validate the buffer if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",527,-14.632910240233242,-0.02776643309342171
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0) return NULL ; // Added check if chunk_num is invalid if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
",509,-26.574880427573312,-0.05220998119366073
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; // Validate the chunk number before proceeding if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) { self -> error = MSPACK_ERR_INVALID_ARGUMENT ; return NULL ; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",529,-16.36602165934064,-0.03093765909138117
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","

static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; // validate input if ( chunk_num > chm->num_chunks || chunk_num < 0) { self->error = MSPACK_ERR_INVALID_INPUT; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",523,-15.689326708854251,-0.0299987126364326
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",499,-5.258493697893879,-0.010538063522833424
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0) { self->error = MSPACK_ERR_INVALID; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",516,-6.237240862693738,-0.01208767609049174
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:"," 
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { 
 struct mspack_system * sys = self -> system ; 
 unsigned char * buf ; 

 //Check for valid chunk_num
 if ( chunk_num > chm -> num_chunks || chunk_num < 0 ){
   self -> error = MSPACK_ERR_INVALID_CHUNK;
   return NULL;
 }
 
 if ( ! chm -> chunk_cache ) {
   size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; 
   if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) {
     self -> error = MSPACK_ERR_NOMEMORY ; 
     return NULL ;
   } 
   memset ( chm -> chunk_cache , 0 , size ) ;
 } 
 if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; 
 if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) {
   self -> error = MSPACK_ERR_NOMEMORY ; 
   return NULL ;
 } 
 if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) {
   self -> error = MSPACK_ERR_SEEK ; 
   sys -> free ( buf ) ; 
   return NULL ;
 } 
 if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) {
   self -> error = MSPACK_ERR_READ ; 
   sys -> free ( buf ) ; 
   return NULL ;
 } 
 //Check for valid bytes
 if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) {
   self -> error = MSPACK_ERR_INVALID_BYTES;
   sys -> free ( buf ) ; 
   return NULL ;
 } 
 return chm -> chunk_cache [ chunk_num ] = buf ; 
}",616,-44.71793105069408,-0.07259404391346441
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","

static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) {
  struct mspack_system * sys = self -> system ; 
  unsigned char * buf ; 
  if (chunk_num == 0 || chunk_num > chm -> num_chunks) {
    self - > error = MSPACK_ERR_INVALID; 
    return NULL;
  }
  if ( ! chm -> chunk_cache ) {
    size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; 
    if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) {
      self -> error = MSPACK_ERR_NOMEMORY ; 
      return NULL ; 
    } 
    memset ( chm -> chunk_cache , 0 , size ) ; 
  }
  if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; 
  if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) {
    self -> error = MSPACK_ERR_NOMEMORY ; 
    return NULL ; 
  } 
  if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) {
    self -> error = MSPACK_ERR_SEEK ; 
    sys -> free ( buf ) ; 
    return NULL ; 
  } 
  if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) {
    self -> error = MSPACK_ERR_READ ; 
    sys -> free ( buf ) ; 
    return NULL ; 
  } 
  if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) {
    self -> error = MSPACK_ERR_SEEK ; 
    sys -> free ( buf ) ; 
    return NULL ; 
  }
  return chm -> chunk_cache [ chunk_num ] = buf ; 
}",614,-34.89224242697078,-0.05682775639571789
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) { self -> error = MSPACK_ERR_INVALID; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if (chunk_num < 0) { self -> error = MSPACK_ERR_INVALID; sys -> free ( buf ) ; return NULL; } return chm -> chunk_cache [ chunk_num ] = buf ; }",546,-11.134587914088161,-0.020393018157670625
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || !chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) && (chunk_num < chm->num_chunks)) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",516,-16.894231087153067,-0.032740757920839275
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || !chunk_num ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if (chunk_num > 0 && chunk_num <= chm->num_chunks){ return chm -> chunk_cache [ chunk_num ] = buf ; } else { sys->free(buf); return NULL; } }",533,-16.538707605182747,-0.031029470178579262
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:"," 
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; //Validate the chunk number if ( chunk_num >= chm -> num_chunks ) { self -> error = MSPACK_ERR_INVALID_PARAM; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } //Validate the content of the chunk if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_INVALID_DATA; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",531,-24.780042296610343,-0.04666674632130008
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ;
if (chunk_num > chm->num_chunks || chunk_num < 0) { self->error = MSPACK_ERR_SEEK; return NULL; }
if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",518,-15.217996750992109,-0.029378372106162374
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { 
struct mspack_system * sys = self -> system ; 
unsigned char * buf ; 

//Added: Validate input
if ( chunk_num == 0 || chunk_num > chm->num_chunks ) { 
    self->error = MSPACK_ERR_BADPARAM; 
    return NULL; 
}

if ( ! chm -> chunk_cache ) { 
    size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; 
    if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { 
        self -> error = MSPACK_ERR_NOMEMORY ; 
        return NULL ; 
    } 
    memset ( chm -> chunk_cache , 0 , size ) ; 
} 
if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; 
if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { 
    self -> error = MSPACK_ERR_NOMEMORY ; 
    return NULL ; 
} 
if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { 
    self -> error = MSPACK_ERR_SEEK ; 
    sys -> free ( buf ) ; 
    return NULL ; 
} 
if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { 
    self -> error = MSPACK_ERR_READ ; 
    sys -> free ( buf ) ; 
    return NULL ; 
} 
if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { 
    self -> error = MSPACK_ERR_SEEK ; 
    sys -> free ( buf ) ; 
    return NULL ; 
} 
return chm -> chunk_cache [ chunk_num ] = buf ; 
}",616,-30.457708087087262,-0.0494443313102066
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { 
struct mspack_system * sys = self -> system ; unsigned char * buf ; 

//Validate the input 
if ( chunk_num > chm -> num_chunks || !chm || !fh ){ 
   self->error = MSPACK_ERR_INVALID_INPUT; 
   return NULL; 
} 

if ( ! chm -> chunk_cache ) { 
   size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; 
   if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { 
      self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; 
   } 
   memset ( chm -> chunk_cache , 0 , size ) ; 
} 

if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; 
if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { 
   self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; 
} 

if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { 
   self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; 
} 

if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { 
   self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; 
} 

//Validate the type of content 
if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { 
   self -> error = MSPACK_ERR_INVALID_DATA ; sys -> free ( buf ) ; return NULL ; 
} 
return chm -> chunk_cache [ chunk_num ] = buf ; 
}",611,-55.359263324164885,-0.09060435895935333
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } 
//Added validation to check for negative chunk numbers
if (chunk_num < 0) {
    self->error = MSPACK_ERR_READ;
    sys->free(buf);
    return NULL;
}
return chm -> chunk_cache [ chunk_num ] = buf ; }",552,-24.81283928261915,-0.044950795801846286
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk(struct mschm_decompressor_p *self, struct mschmd_header *chm, 
struct mspack_file *fh, unsigned int chunk_num) {
    struct mspack_system *sys = self->system;
    unsigned char *buf;
    if ((chunk_num > chm->num_chunks) || (chunk_num < 0)) {
        self->error = MSPACK_ERR_SEEK;
        return NULL;
    }
    if (!chm->chunk_cache) {
        size_t size = sizeof(unsigned char *) * chm->num_chunks;
        if (!(chm->chunk_cache = (unsigned char **)sys->alloc(sys, size))) {
            self->error = MSPACK_ERR_NOMEMORY;
            return NULL;
        }
        memset(chm->chunk_cache, 0, size);
    }
    if (chm->chunk_cache[chunk_num])
        return chm->chunk_cache[chunk_num];
    if (!(buf = (unsigned char *)sys->alloc(sys, chm->chunk_size))) {
        self->error = MSPACK_ERR_NOMEMORY;
        return NULL;
    }
    if (sys->seek(fh, (off_t)(chm->dir_offset + (chunk_num * chm->chunk_size)), MSPACK_SYS_SEEK_START)) {
        self->error = MSPACK_ERR_SEEK;
        sys->free(buf);
        return NULL;
    }
    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {
        self->error = MSPACK_ERR_READ;
        sys->free(buf);
        return NULL;
    }
    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) && ((buf[3] == 0x4C) || (buf[3] == 0x49)))) {
        self->error = MSPACK_ERR_SEEK;
        sys->free(buf);
        return NULL;
    }
    return chm->chunk_cache[chunk_num] = buf;
}",582,-22.77149140605517,-0.039126273893565586
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; // Verify that the chunk number is valid if ( chunk_num > chm -> num_chunks ) { self->error = MSPACK_ERR_BADPARAM; return NULL; } // Allocate memory for the cache if necessary if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } // Check if the chunk is already cached if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; // Allocate memory for the chunk if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } // Seek to the start of the chunk if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } // Read the chunk if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } // Validate the chunk to ensure it is valid before caching if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",567,-40.03173783577276,-0.07060271223240346
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) { self-> error = MSPACK_ERR_SEEK; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",515,-10.11389396700708,-0.01963862906214967
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || !chm->chunk_size) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) && (chm->chunk_size > 0) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",514,-13.77445854373421,-0.026798557478082123
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) { self->error = MSPACK_ERR_ARGS; return NULL; } 

if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",518,-14.016464885466462,-0.027058812520205526
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:"," 
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; //input validation if (chunk_num > chm->num_chunks || !chm->num_chunks) { return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",509,-23.113014985571898,-0.04540867384198801
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","

static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { 
struct mspack_system * sys = self -> system ; 
unsigned char * buf ; 

// Add input validation
if (chunk_num >= chm->num_chunks || chunk_num < 0) {
    self->error = MSPACK_ERR_INVALID_INPUT;
    return NULL;
}


if ( ! chm -> chunk_cache ) { 
    size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; 
    if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { 
        self -> error = MSPACK_ERR_NOMEMORY ; 
        return NULL ; 
    } 
    memset ( chm -> chunk_cache , 0 , size ) ; 
} 
if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; 
if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { 
    self -> error = MSPACK_ERR_NOMEMORY ; 
    return NULL ; 
} 
if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { 
    self -> error = MSPACK_ERR_SEEK ; 
    sys -> free ( buf ) ; 
    return NULL ; 
} 
if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { 
    self -> error = MSPACK_ERR_READ ; 
    sys -> free ( buf ) ; 
    return NULL ; 
} 

// Add input validation
if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { 
    self -> error = MSPACK_ERR_INVALID_INPUT; 
    sys -> free ( buf ) ; 
    return NULL ; 
} 
return chm -> chunk_cache [ chunk_num ] = buf ; 
}",625,-30.44308194246062,-0.04870893110793699
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) { self -> error = MSPACK_ERR_INVALID_ARG; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if (chunk_num == 0) { // add check to ensure chunk_num is valid self -> error = MSPACK_ERR_INVALID_ARG; sys -> free ( buf ) ; return NULL; } return chm -> chunk_cache [ chunk_num ] = buf ; }",562,-25.804496294122472,-0.04591547383295814
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","

static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) { self -> error = MSPACK_ERR_SEEK ; return NULL ; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",516,-10.189413048028653,-0.019746924511683438
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; // Added check to make sure chunk_num is valid if (chunk_num > chm->num_chunks || chunk_num < 0) { self->error = MSPACK_ERR_INVALID; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } // Added checks to make sure the header bytes are valid if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) && ((buf[3] == 0x4C) || (buf[3] == 0x49)))) { self->error = MSPACK_ERR_INVALID; sys->free(buf); return NULL; } return chm->chunk_cache[chunk_num] = buf; }",535,-30.92399919695735,-0.05780186765786421
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; //check that chunk number is within range if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } //validate data before reading if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",507,-28.15076907965421,-0.05552419936815426
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; 

//validate input
if (chunk_num <= 0 || chunk_num > chm->num_chunks) {
    self->error = MSPACK_ERR_BADARG;
    return NULL;
}

if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",533,-16.818561118470228,-0.031554523674428195
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0) { self->error = MSPACK_ERR_INVALID; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",516,-6.237575729085476,-0.012088325056367201
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) {
  struct mspack_system * sys = self -> system ;
  
  unsigned char * buf ;
  if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) {
    self -> error = MSPACK_ERR_INVALID_ARGS ;
    return NULL ;
  }
  if ( ! chm -> chunk_cache ) {
    size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ;
    if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) {
      self -> error = MSPACK_ERR_NOMEMORY ;
      return NULL ;
    }
    memset ( chm -> chunk_cache , 0 , size ) ;
  }
  if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ;
  if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) {
    self -> error = MSPACK_ERR_NOMEMORY ;
    return NULL ;
  }
  if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) {
    self -> error = MSPACK_ERR_SEEK ;
    sys -> free ( buf ) ;
    return NULL ;
  }
  if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) {
    self -> error = MSPACK_ERR_READ ;
    sys -> free ( buf ) ;
    return NULL ;
  }
  if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) {
    self -> error = MSPACK_ERR_SEEK ;
    sys -> free ( buf ) ;
    return NULL ;
  }
  return chm -> chunk_cache [ chunk_num ] = buf ;
}",592,-26.662596289357584,-0.04503816940769862
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) { self -> error = MSPACK_ERR_INVALID_INPUT; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",513,-7.977308192899627,-0.015550308368225393
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num >= chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } 
if (chunk_num > chm->num_chunks) {
    self->error = MSPACK_ERR_INVALID;
    return NULL;
}
return chm->chunk_cache[chunk_num] = buf;
}",539,-18.379680199430055,-0.034099592206734794
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) {
 struct mspack_system * sys = self -> system ;
 unsigned char * buf ; 
 if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) {
  self->error = MSPACK_ERR_INVALID;
  return NULL;
 }
 
 if ( ! chm -> chunk_cache ) {
  size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ;
  if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) {
   self -> error = MSPACK_ERR_NOMEMORY ;
   return NULL ;
  }
  memset ( chm -> chunk_cache , 0 , size ) ;
 }
 
 if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ;
 if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) {
  self -> error = MSPACK_ERR_NOMEMORY ;
  return NULL ;
 }
 if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) {
  self -> error = MSPACK_ERR_SEEK ;
  sys -> free ( buf ) ;
  return NULL ;
 }
 if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) {
  self -> error = MSPACK_ERR_READ ;
  sys -> free ( buf ) ;
  return NULL ;
 }
 if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) {
  self -> error = MSPACK_ERR_SEEK ;
  sys -> free ( buf ) ;
  return NULL ;
 }
 return chm -> chunk_cache [ chunk_num ] = buf ;
}",576,-22.90450305379878,-0.03976476224617844
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; 

//Added check for valid input
if (chunk_num > chm->num_chunks || chunk_num < 0) {
  self->error = MSPACK_ERR_INVALID;
  return NULL;
}

if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } 

//Added check for valid input
if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { 
  self -> error = MSPACK_ERR_INVALID; 
  sys->free(buf);
  return NULL;
}

return chm -> chunk_cache [ chunk_num ] = buf ; }",555,-29.348855569213143,-0.05288082084542908
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0) { self->error = MSPACK_ERR_INVALID_CHUNK; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",520,-8.340737631737136,-0.016039880061032956
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","

static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; 
//Add validation to check if chunk_num is less than or equal to the number of chunks
if (chunk_num > chm->num_chunks || chunk_num < 0) {
    self->error = MSPACK_ERR_INVALID;
    return NULL;
}

if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",547,-26.21693776130402,-0.04792858822907499
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; 
//add validation check for 'chunk_num' 
if ( chunk_num > chm -> num_chunks || chunk_num < 0) return NULL ; 

if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } //add validation check for 'dir_offset' 
if (chm -> dir_offset < 0) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; }

if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",568,-40.79368624151848,-0.07181987014351845
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; int valid_input = 0; // Added input validation check 

if ( chunk_num > chm -> num_chunks || chunk_num < 0) { // Added check to ensure the input is valid 
  valid_input = 1; 
} 

if (valid_input == 1) { 
  return NULL; 
} 

if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",557,-39.51522624386285,-0.0709429555545114
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if (chunk_num > chm->num_chunks || chunk_num < 0) { self->error = MSPACK_ERR_INVALID; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",517,-7.471747547740979,-0.014452122916326846
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; 

if (chunk_num > chm -> num_chunks || !chunk_num) {
    self -> error = MSPACK_ERR_INPUT;
    return NULL;
}

if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } 

if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; 

if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } 

if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } 

if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } 

if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } 

return chm -> chunk_cache [ chunk_num ] = buf ; 
}",546,-23.50525045298319,-0.04304990925454797
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","

static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) {  self->error = MSPACK_ERR_INVALID_ARG;  return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",522,-15.058389580545297,-0.028847489617902868
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { 
	struct mspack_system * sys = self -> system ; unsigned char * buf ; 
	
	// check if chunk_num is within bounds
	if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) return NULL ; 
	
	if ( ! chm -> chunk_cache ) { 
		size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; 
		if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { 
			self -> error = MSPACK_ERR_NOMEMORY ; 
			return NULL ; 
		} 
		memset ( chm -> chunk_cache , 0 , size ) ; 
	} 
	if ( chm -> chunk_cache [ chunk_num ] ) 
		return chm -> chunk_cache [ chunk_num ] ; 
	if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { 
		self -> error = MSPACK_ERR_NOMEMORY ; 
		return NULL ; 
	} 
	if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { 
		self -> error = MSPACK_ERR_SEEK ; 
		sys -> free ( buf ) ; 
		return NULL ; 
	} 
	if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { 
		self -> error = MSPACK_ERR_READ ; 
		sys -> free ( buf ) ; 
		return NULL ; 
	} 
	if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { 
		self -> error = MSPACK_ERR_SEEK ; 
		sys -> free ( buf ) ; 
		return NULL ; 
	} 
	
	return chm -> chunk_cache [ chunk_num ] = buf ; 
}",634,-32.873486900338605,-0.05185092571031326
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { 
    struct mspack_system * sys = self -> system ; unsigned char * buf ; 
    
    // Validate input
    if (chunk_num == NULL || chunk_num > chm->num_chunks){ 
        return NULL; 
    }
    
    if ( ! chm -> chunk_cache ) { 
        size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; 
        if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { 
            self -> error = MSPACK_ERR_NOMEMORY ; 
            return NULL ; 
        } 
        memset ( chm -> chunk_cache , 0 , size ) ; 
    } 
    
    if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; 
    
    if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { 
        self -> error = MSPACK_ERR_NOMEMORY ; 
        return NULL ; 
    } 
    
    if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { 
        self -> error = MSPACK_ERR_SEEK ; 
        sys -> free ( buf ) ; 
        return NULL ; 
    } 
    
    if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { 
        self -> error = MSPACK_ERR_READ ; 
        sys -> free ( buf ) ; 
        return NULL ; 
    } 
    
    // Validate output
    if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { 
        self -> error = MSPACK_ERR_SEEK ; 
        sys -> free ( buf ) ; 
        return NULL ; 
    }
    
    return chm -> chunk_cache [ chunk_num ] = buf ; 
}",628,-32.69111146053405,-0.05205590996900327
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) { self->error = MSPACK_ERR_INVALID_INDEX; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; }  return chm -> chunk_cache [ chunk_num ] = buf ; }",520,-16.229878274038814,-0.031211304373151564
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if (chunk_num == 0 || chunk_num > chm -> num_chunks ) { self->error = MSPACK_ERR_INVALID; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",517,-9.976696288505094,-0.01929728489072552
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks || chunk_num < 0 ) { self -> error = MSPACK_ERR_SEEK ; return NULL ; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",515,-8.193151637073841,-0.01590903230499775
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; // Add input validation to avoid CWE-20 vulnerability  if (chunk_num >= chm->num_chunks || chunk_num < 0) { self->error = MSPACK_ERR_INVALID_INPUT; return NULL; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",532,-21.987925474681084,-0.04133068698248324
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; 
//Check for invalid input 
if (chunk_num <= 0 || chunk_num > chm->num_chunks) { self->error = MSPACK_ERR_INVALID; return NULL; } 

if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } 

//Check if the file is valid
if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_INVALID; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",541,-30.850591395187585,-0.05702512272677927
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
Fixed code:","
static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) { self->error = MSPACK_ERR_INVALID_INPUT; return NULL ; } if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_INVALID_INPUT; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }",517,-9.886140907396733,-0.019122129414693875
