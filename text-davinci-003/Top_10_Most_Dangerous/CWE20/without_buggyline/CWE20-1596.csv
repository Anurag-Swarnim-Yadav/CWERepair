Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; int valid_token = 0; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { valid_token = 0; switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; valid_token = 1; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; valid_token = 1; break ; case T_Pid : filegen_type = FILEGEN_PID ; valid_token = 1; break ; case T_Day : filegen_type = FILEGEN_DAY ; valid_token = 1; break ; case T_Week : filegen_type = FILEGEN_WEEK ; valid_token = 1; break ; case T_Month : filegen_type = FILEGEN_MONTH ; valid_token = 1; break ; case T_Year : filegen_type = FILEGEN_YEAR ; valid_token = 1; break ; case T_Age : filegen_type = FILEGEN_AGE ; valid_token = 1; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; valid_token = 1; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; valid_token = 1; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; valid_token = 1; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; valid_token = 1; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } if (valid_token) { filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } } }",880,-16.749235715334386,-0.019033222403789074
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { if(ptree->stats_list->size != 0) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",802,-18.6922137516473,-0.023306999690333292
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; if (filegen == NULL) { msyslog ( LOG_ERR , ""Improper input value %s"" , filegen_string ) ; exit ( 1 ) ; } DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : msyslog ( LOG_ERR , ""Improper input value %d"" , my_opts -> value . i ) ; exit ( 1 ); break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",848,-27.46494167523092,-0.032387902918904386
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { if (pfilegen_token->i > 0 && pfilegen_token->i < MAX_TOKENS) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : if(my_opts->value.i > 0 && my_opts->value.i < MAX_TOKENS){ switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; } else { msyslog ( LOG_ERR , ""Unknown filegen type token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } case T_Flag : if(my_opts->value.i > 0 && my_opts->value.i < MAX_TOKENS){ switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; } else { msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",947,-20.500375040824967,-0.021647703316605035
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { 
  case T_File : 
    if(validate_file(my_opts->value.s)){
      filegen_file = my_opts -> value . s ;
    }
    else{
      msyslog(LOG_ERR, ""Input file validation failed"");
      exit(1);
    }
    break ; 
  case T_Type : 
    switch ( my_opts -> value . i ) { 
      default : 
        NTP_INSIST ( 0 ) ; 
        break ; 
      case T_None : 
        filegen_type = FILEGEN_NONE ; 
        break ; 
      case T_Pid : 
        filegen_type = FILEGEN_PID ; 
        break ; 
      case T_Day : 
        filegen_type = FILEGEN_DAY ; 
        break ; 
      case T_Week : 
        filegen_type = FILEGEN_WEEK ; 
        break ; 
      case T_Month : 
        filegen_type = FILEGEN_MONTH ; 
        break ; 
      case T_Year : 
        filegen_type = FILEGEN_YEAR ; 
        break ; 
      case T_Age : 
        filegen_type = FILEGEN_AGE ; 
        break ; 
    } 
    break ; 
  case T_Flag : 
    switch ( my_opts -> value . i ) { 
      case T_Link : 
        filegen_flag |= FGEN_FLAG_LINK ; 
        break ; 
      case T_Nolink : 
        filegen_flag &= ~ FGEN_FLAG_LINK ; 
        break ; 
      case T_Enable : 
        filegen_flag |= FGEN_FLAG_ENABLED ; 
        break ; 
      case T_Disable : 
        filegen_flag &= ~ FGEN_FLAG_ENABLED ; 
        break ; 
      default : 
        msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; 
        exit ( 1 ) ; 
    } 
    break ; 
  default : 
    msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; 
    exit ( 1 ) ; 
  } 
} 
filegen_config ( filegen , filegen_file , filegen_type , filegen_flag",1000,-35.02864067869434,-0.03502864067869434
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; //Validate input if(filegen_string == NULL) { msyslog ( LOG_ERR , ""Error: invalid string input"" ) ; return; } filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; //Validate input if(filegen_file == NULL) { msyslog ( LOG_ERR , ""Error: invalid string input"" ) ; return; } filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; //Validate input if(filegen_file == NULL) { msyslog ( LOG_ERR , ""Error: invalid string input"" ) ; return; } break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",892,-27.808653421898935,-0.031175620428137818
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; if (filegen_string != NULL) { filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; if (filegen_file != NULL) { filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } } }",809,-12.152238012935902,-0.015021307803381831
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; 

if ( !ptree ) {
    return;
}

if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { 
    filegen_string = keyword ( pfilegen_token -> i ) ; 
    filegen = filegen_get ( filegen_string ) ; 
    
    if ( !filegen ) {
        continue;
    }
    
    DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; 
    filegen -> flag |= FGEN_FLAG_ENABLED ; 
} 
my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { 
    filegen_file = keyword ( my_node -> filegen_token ) ; 
    filegen = filegen_get ( filegen_file ) ; 
    
    if ( !filegen ) {
        continue;
    }
    
    filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { 
        switch ( my_opts -> attr ) { 
            case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; 
            default : 
                msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; 
                exit ( 1 ) ; 
        } 
    } 
    filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; 
} 
}",898,-38.61059851244089,-0.04299621215193863
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : if ( my_opts -> value . i == T_Link || my_opts -> value . i == T_Nolink || my_opts -> value . i == T_Enable || my_opts -> value . i == T_Disable ) { switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; } } else { msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",846,-12.292380484067927,-0.01453000057218431
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; if (filegen_string == NULL || filegen == NULL) { DPRINTF ( 4 , ( ""Invalid filegen string %s\\n"" , filegen_string ) ) ; continue; } else { DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : // Added input validation condition if (my_opts->value.i == T_Link || my_opts->value.i == T_Nolink || my_opts->value.i == T_Enable || my_opts->value.i == T_Disable) { msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break; } break ; default : // Added input validation condition if (my_opts->attr == T_File || my_opts->attr == T_Type || my_opts->attr == T_Flag) { msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } break; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",942,-39.646551946670186,-0.04208763476291952
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { if (!isValidFileGenString(pfilegen_token->i)) { exit(1); } filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : if(!isValidFileGenFile(my_opts->value.s)) { exit(1); } filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }

//Function to check valid filegen string
bool isValidFileGenString(const char * str) {
  //Check for valid strings against a list of valid strings
  const char * validStrings[] = { ""peerstats"", ""clockstats"", ""loopstats"", ""rawstats"", ""sysstats"" };
  for (int i = 0; i < sizeof(validStrings) / sizeof(*validStrings); i++) {
    if (strcmp(str, validStrings[i]) == 0) {
      return true;
    }
  }
  return false;
}

//Function to check valid filegen file
bool isValidFileGenFile(const char * str) {
  int len = strlen(str);",1000,-76.47851583131654,-0.07647851583131654
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; if (filegen != NULL) { //Added input validation to fix CWE-20: Improper Input Validation. DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; if (filegen != NULL) { //Added input validation to fix CWE-20: Improper Input Validation. filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } } }",839,-20.77200884627045,-0.02475805583584082
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { if (!validate_filegen_string(filegen_string)) { msyslog ( LOG_ERR , ""Invalid filegen string provided: %s"" , filegen_string ) ; exit ( 1 ) ; } filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : if (!validate_filegen_file(filegen_file)) { msyslog ( LOG_ERR , ""Invalid filegen file provided: %s"" , filegen_file ) ; exit ( 1 ) ; } filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }

//Added validation functions
bool validate_filegen_string(const char * filegen_string) {
    //Add validation code here
    return true;
}

bool validate_filegen_file(const char *filegen_file) {
    //Add validation code here
    return true;
}",954,-42.38910774588769,-0.04443302698730366
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; // Validate input if (filegen_string == NULL || strlen(filegen_string) == 0) { msyslog (LOG_ERR, ""Invalid filegen string""); exit ( 1 ) ; } filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; // Validate input if (filegen_file == NULL || strlen(filegen_file) == 0) { msyslog (LOG_ERR, ""Invalid filegen file""); exit ( 1 ) ; } filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; // Validate input if (filegen_file == NULL || strlen(filegen_file) == 0) { msyslog (LOG_ERR, ""Invalid filegen file""); exit ( 1 ) ; } break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",925,-19.458801101720702,-0.021036541731589947
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { // Validate input if (!is_valid(pfilegen_token->i)) { msyslog(LOG_ERR, ""Invalid input in filegen token""); exit(1); } filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { // Validate input if (!is_valid(my_opts->attr) || !is_valid(my_opts->value)) { msyslog(LOG_ERR, ""Invalid input in filegen option""); exit(1); } switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",881,-27.777858124444634,-0.031529918415941695
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { // Verify the token is valid // before continuing with the loop if (validateToken(pfilegen_token)) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { // Verify the token is valid // before continuing with the loop if (validateToken(my_node)) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } } }

// Function to validate the token
bool validateToken(int_node * token) {
  if (token == NULL) {
    return false;
  }
  
  // Add additional validation checks here
  
  return true;
}",893,-49.55093867672517,-0.05548817321021855
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; if (filegen_string != NULL && strlen(filegen_string) > 0) { filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : if (my_opts->value.s != NULL && strlen(my_opts->value.s) > 0) { filegen_file = my_opts -> value . s ; } break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",839,-10.529329329408789,-0.012549856173312024
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; if(filegen_string != NULL && strlen(filegen_string) > 0) { filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } else { msyslog ( LOG_ERR , ""Unknown filegen string token %d"" , pfilegen_token -> i ) ; exit ( 1 ) ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : if(my_opts->value.s != NULL && strlen(my_opts->value.s) > 0) { filegen_file = my_opts -> value . s ; } else { msyslog ( LOG_ERR , ""Unknown filegen string token %d"" , my_opts->value.s ) ; exit ( 1 ) ; } break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",912,-22.963778987196534,-0.025179582222803216
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : if (my_opts->value.i < T_None || my_opts->value.i > T_Age) { msyslog ( LOG_ERR , ""Unknown filegen type token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : if (my_opts->value.i < T_Link || my_opts->value.i > T_Disable) { msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",879,-11.409909028096934,-0.01298055634595783
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { if (pfilegen_token->i == NULL) {
        continue;
    }
    filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { if (my_node->filegen_token == NULL) {
        continue;
    }
    filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : continue; } break ; default : continue; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",769,-20.258385005079283,-0.026343803647697377
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { if (!isalpha(pfilegen_token->i)) { msyslog ( LOG_ERR ,""Input validation failed. Non-alphanumeric character entered."" ); exit ( 1 ) ; } filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",829,-33.06621353739108,-0.039886867958252206
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { // Validate filegen string input 
   if (! validateInputFormat(pfilegen_token->i)) continue; 
   filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { // Validate filegen string input 
   if (! validateInputFormat(my_node->filegen_token)) continue; 
   filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : // Validate flag input 
       if (! validateInputFormat(my_opts->value.i)) continue; 
       msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : // Validate option token input 
       if (! validateInputFormat(my_opts->attr)) continue; 
       msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",901,-50.907038131469434,-0.056500597260232446
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; if (!filegen_string || strlen(filegen_string) == 0) { msyslog(LOG_ERR, ""Invalid input received. Exiting.""); exit(1); } filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; if (!filegen_file || strlen(filegen_file) == 0) { msyslog(LOG_ERR, ""Invalid input received. Exiting.""); exit(1); } filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; if (!filegen_file || strlen(filegen_file) == 0) { msyslog(LOG_ERR, ""Invalid input received. Exiting.""); exit(1); } break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",913,-21.18874055393188,-0.023207820979114873
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; // check if the filegen string is valid here 
if (!validInput(filegen_string)) {
   msyslog ( LOG_ERR , ""Invalid filegen string %d"" , my_opts -> attr ) ; exit ( 1 ) ;
}
filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; // check if the filegen file is valid here 
if (!validInput(filegen_file)) {
   msyslog ( LOG_ERR , ""Invalid filegen file %d"" , my_opts -> attr ) ; exit ( 1 ) ;
}
filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; // check if the filegen file is valid here 
if (!validInput(filegen_file)) {
   msyslog ( LOG_ERR , ""Invalid filegen file %d"" , my_opts -> attr ) ; exit ( 1 ) ;
}
break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",967,-45.3298208494807,-0.046876753722317165
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; if (filegen_string == NULL || filegen_string == """") { //Validate input data, exit if not valid msyslog ( LOG_ERR , ""Invalid filegen string input"" ) ; exit ( 1 ) ; } filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; if (filegen_file == NULL || filegen_file == """") { //Validate input data, exit if not valid msyslog ( LOG_ERR , ""Invalid filegen file input"" ) ; exit ( 1 ) ; }  filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",890,-38.521962431246045,-0.043283103855332634
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { if (pfilegen_token->i >= 0 && pfilegen_token->i <= 255) {  filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } else { msyslog ( LOG_ERR , ""Invalid filegen token %d"" , my_opts -> value . i ) ; return ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : if (my_opts->value.i >= 0 && my_opts->value.i <= 255) {  msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } else { msyslog ( LOG_ERR , ""Invalid filegen flag token %d"" , my_opts -> value . i ) ; return ; } } break ; default : if (my_opts->attr >= 0 && my_opts->attr <= 255) {  msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } else { msyslog ( LOG_ERR , ""Invalid filegen option token %d"" , my_opts -> attr ) ; return ; } } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",962,-32.1283830231634,-0.033397487550065906
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; /* validate filegen_string */ if (filegen_string == NULL || !filegen_string || strlen(filegen_string) == 0) { msyslog ( LOG_ERR , ""Invalid filegen string provided"" ) ; exit ( 1 ) ; } DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { /* validate filegen_file */ filegen_file = keyword ( my_node -> filegen_token ) ; if (filegen_file == NULL || !filegen_file || strlen(filegen_file) == 0) { msyslog ( LOG_ERR , ""Invalid filegen file provided"" ) ; exit ( 1 ) ; } filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; /* validate my_opts->value.s */ if (my_opts->value.s == NULL || !my_opts->value.s || strlen(my_opts->value.s) == 0) { msyslog ( LOG_ERR , ""Invalid option value provided"" ) ; exit ( 1 ) ; } break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",976,-40.55782240371615,-0.04155514590544688
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; if (filegen_string) { filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } else { printf(""Invalid input received\n""); } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : if (my_opts->value.s) { filegen_file = my_opts -> value . s ; } else { printf(""Invalid input received\n""); } break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",831,-23.57307703835658,-0.028367120383100578
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { // Validate input if(pfilegen_token->i > 0 && pfilegen_token->i < MAX_NUM_FILEGENS) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : // Validate input if(my_opts->value.i > 0 && my_opts->value.i < MAX_NUM_FLAGS) { switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; } else { msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",893,-27.30594723551958,-0.030577768460828197
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; if (filegen_string == NULL){ msyslog ( LOG_ERR , ""Input validation failed: filegen string is NULL."" ) ; exit ( 1 ) ; } filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; if (filegen_file == NULL){ msyslog ( LOG_ERR , ""Input validation failed: filegen file is NULL."" ) ; exit ( 1 ) ; } filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",861,-21.794165781450236,-0.025312619955226753
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; if (!filegen_string) { // Added line 
	continue; // Added line 
} // Added line 
filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",814,-23.431071946622275,-0.028785100671526138
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { // Validate input if (pfilegen_token->i <= 0) { msyslog(LOG_ERR, ""Invalid input token""); exit(1); } filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { // Validate input if (my_opts->attr <= 0) { msyslog(LOG_ERR, ""Invalid input token""); exit(1); } switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",858,-19.75721878204563,-0.0230270615175357
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; if(filegen) { //validate filegen_string DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; if(filegen) { //validate filegen_file filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : //validate attribute msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } } }",819,-30.87122186154471,-0.03769379958674568
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; int valid_option ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { valid_option = 0 ; filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; valid_option = 1 ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; valid_option = 1 ; break ; case T_Pid : filegen_type = FILEGEN_PID ; valid_option = 1 ; break ; case T_Day : filegen_type = FILEGEN_DAY ; valid_option = 1 ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; valid_option = 1 ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; valid_option = 1 ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; valid_option = 1 ; break ; case T_Age : filegen_type = FILEGEN_AGE ; valid_option = 1 ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; valid_option = 1 ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; valid_option = 1 ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; valid_option = 1 ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; valid_option = 1 ; break ; default : valid_option = 0 ; break ; } break ; default : valid_option = 0 ; break ; } } if(valid_option){ filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } else { msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } }",862,-21.378881854722984,-0.024801487070444297
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:"," 
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; if ( filegen == NULL ){ msyslog ( LOG_ERR , "" Unknown filegen token %s"" , my_node -> filegen_token ) ; exit ( 1 ) ; } filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",830,-26.378622505600397,-0.031781472898313734
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; if (filegen == NULL) { msyslog ( LOG_ERR , ""Filegen string does not match any known filegen type: %s"" , filegen_string ) ; exit ( 1 ) ; } DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",833,-26.38300445265942,-0.031672274252892464
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; // validate that the keyword is a valid filegen string if(!filegen_string) { msyslog(LOG_ERR, ""Invalid filegen string detected"") return; } filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; // validate that the keyword is a valid filegen file if(!filegen_file) { msyslog(LOG_ERR, ""Invalid filegen file detected"") return; } filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; return; // replaced exit(1) with return } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; return; // replaced exit(1) with return } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",875,-44.90561673125273,-0.05132070483571741
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { // Added input validation to validate the input keyword // to prevent potential injection attacks. if (pfilegen_token->i == NULL || strlen(pfilegen_token->i) == 0) { continue; } filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { // Added input validation for all of the attr, value, and flag types // to prevent potential injection attacks. if (my_opts->attr == NULL || strlen(my_opts->attr) == 0 || my_opts->value == NULL || strlen(my_opts->value) == 0 || my_opts->flag == NULL || strlen(my_opts->flag) == 0) { continue; } switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",928,-70.95276735148653,-0.07645772343910186
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { // Added input validation check for filegen_string 
if (filegen_string != NULL && filegen_string != """") { 
        filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; 
    } 
} my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; // Added input validation checks for filegen_type and filegen_flag 
case T_Type : if (my_opts->value.i >= T_None && my_opts->value <= T_Age) { switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; } else { msyslog ( LOG_ERR , ""Unknown filegen type token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } 
case T_Flag : if (my_opts->value.i >= T_Link && my_opts->value <= T_Disable) { switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; } break ; } else { msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",940,-57.019392590605136,-0.060658928287877806
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; 
//Validate input 
if (filegen_string == NULL){ 
  msyslog (LOG_ERR, ""Invalid filegen string""); 
  exit (1); 
 } 
filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; 
//Validate input 
if (filegen_file == NULL){ 
  msyslog (LOG_ERR, ""Invalid filegen file""); 
  exit (1); 
 } 
filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",881,-32.32558023843978,-0.036691918545334594
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; if(filegen_string != NULL) { filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; if(filegen_file != NULL) { filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } } }",809,-7.252190492104802,-0.00896438874178591
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","

static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; //check if all input strings are valid before proceeding if (!ptree || !ptree->stats_dir || !ptree->stats_list || !ptree->filegen_opts || !filegen_string || !filegen_file || !filegen || !my_node || !my_opts) { return; } if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; //check for valid input strings before proceeding if (!filegen_file || !filegen) { return; } my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : //validate input string if (!my_opts->value.s) { return; } filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",903,-56.25749702103154,-0.06230066115285885
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; if (filegen != NULL) { DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; if (filegen != NULL) { filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } } }",805,-6.135068663965245,-0.007621203309273596
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor(config_tree *ptree) {
   int_node *pfilegen_token;
   const char *filegen_string;
   const char *filegen_file;
   FILEGEN *filegen;
   filegen_node *my_node;
   attr_val *my_opts;
   int filegen_type;
   int filegen_flag;
   if (ptree->stats_dir)
      stats_config(STATS_STATSDIR, ptree->stats_dir);
   pfilegen_token = HEAD_PFIFO(ptree->stats_list);
   for (; pfilegen_token != NULL; pfilegen_token = pfilegen_token->link) {
      filegen_string = keyword(pfilegen_token->i);
      filegen = filegen_get(filegen_string);
      DPRINTF(4, (""enabling filegen for %s statistics \'%s%s\'\\n"", filegen_string, filegen->prefix,
            filegen->basename));
      filegen->flag |= FGEN_FLAG_ENABLED;
   }
   my_node = HEAD_PFIFO(ptree->filegen_opts);
   for (; my_node != NULL; my_node = my_node->link) {
      filegen_file = keyword(my_node->filegen_token);
      filegen = filegen_get(filegen_file);
      filegen_flag = filegen->flag;
      filegen_type = filegen->type;
      filegen_flag |= FGEN_FLAG_ENABLED;
      my_opts = HEAD_PFIFO(my_node->options);
      for (; my_opts != NULL; my_opts = my_opts->link) {
         switch (my_opts->attr) {
         case T_File:
            filegen_file = my_opts->value.s;
            break;
         case T_Type:
            switch (my_opts->value.i) {
            default:
               NTP_INSIST(0);
               break;
            case T_None:
               filegen_type = FILEGEN_NONE;
               break;
            case T_Pid:
               filegen_type = FILEGEN_PID;
               break;
            case T_Day:
               filegen_type = FILEGEN_DAY;
               break;
            case T_Week:
               filegen_type = FILEGEN_WEEK;
               break;
            case T_Month:
               filegen_type = FILEGEN_MONTH;
               break;
            case T_Year:
               filegen_type = FILEGEN_YEAR;
               break;
            case T_Age:
               filegen_type = FILEGEN_AGE;
               break;
            }
            break;
         case T_Flag:
            switch (my_opts->value.i) {
            case T_Link:
               filegen_flag |= FGEN_FLAG_LINK;
               break;
            case T_Nolink:
               filegen_flag &= ~FGEN_FLAG_LINK;
               break;
            case T_Enable:
               filegen_flag |= FGEN_FLAG_ENABLED;
               break;
            case T_Disable:
               filegen_flag &= ~FGEN_FLAG_ENABLED;
               break;
            default:
               if (my_opts->value.i > 0) { // Added line to validate input
                  msyslog(LOG_ERR, ""Unknown filegen flag token %d"", my_opts->value.i);
                  exit(1);
               }
            }
            break;
         default:
            if (my_opts->attr > 0) { // Added line to validate input
               msyslog(LOG_ERR, ""Unknown filegen option token %d"", my_opts->attr);
               exit(1);
            }
         }
      }
      filegen_config(filegen, filegen_file, filegen_type, filegen_flag);
   }
}",985,-35.820423297667915,-0.03636591197732783
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { if(validate_filegen_string(filegen_string)) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : if(validate_filegen_file(filegen_file)) { filegen_file = my_opts -> value . s ; } break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }

//Added a function to validate the filegen_string and filegen_file
//before passing it to filegen_get()

bool validate_filegen_string(const char *filegen_string) {
    if(!filegen_string)
        return false;
    if(strlen(filegen_string) > MAX_FILEGEN_STRING_LEN)
        return false;
    if(!isValidString(filegen_string))
        return false;
    return true;
}

bool validate_filegen_file(const char *filegen_file) {
    if(!filegen_file)
        return false;
    if(strlen(filegen_file) > MAX_FILEGEN_FILE_LEN)
        return false",1000,-61.56505776337691,-0.06156505776337691
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; // Validate input if (filegen == NULL) { msyslog ( LOG_ERR , ""Invalid filegen string \'%s\'"" , filegen_string ) ; exit ( 1 ) ; } DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; // Validate input if (filegen == NULL) { msyslog ( LOG_ERR , ""Invalid filegen string \'%s\'"" , filegen_file ) ; exit ( 1 ) ; } filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",875,-15.729299075549566,-0.017976341800628074
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; // Validate input to ensure it is expected.if (filegen_string == NULL || !isValidString(filegen_string) || strlen(filegen_string) == 0) { msyslog( LOG_ERR, ""Input string is not valid. Exiting."" ); exit(1); } filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; // Validate input to ensure it is expected.if (filegen_file == NULL || !isValidString(filegen_file) || strlen(filegen_file) == 0) { msyslog( LOG_ERR, ""Input string is not valid. Exiting."" ); exit(1); } filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; // Validate input to ensure it is expected.if (filegen_file == NULL || !isValidString(filegen_file) || strlen(filegen_file) == 0) { msyslog( LOG_ERR, ""Input string is not valid. Exiting."" ); exit(1); } break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",988,-54.06028874059459,-0.05471689143784878
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { if(!isalpha(filegen_string) || !isprint(filegen_string)) { 
   msyslog ( LOG_ERR , ""Improper input validation: Invalid character in filegen_string"" ) ; exit ( 1 ) ; }
   filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : if(!isalpha(filegen_file) || !isprint(filegen_file)) { 
   msyslog ( LOG_ERR , ""Improper input validation: Invalid character in filegen_file"" ) ; exit ( 1 ) ; }
   filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",903,-44.08856004272604,-0.04882454046813515
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { // Validate the input string against a list of valid strings. if (validate_string(pfilegen_token->i) == -1) { msyslog ( LOG_ERR , ""Invalid string: %s"" , pfilegen_token -> i ) ; exit ( 1 ) ; } filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : // Validate the input string against a list of valid strings. if (validate_string(my_opts->value.s) == -1) { msyslog ( LOG_ERR , ""Invalid string: %s"" , my_opts -> value . s ) ; exit ( 1 ) ; } filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : // Validate the input attribute value against a list of valid values. if (validate_attr_value(my_opts -> value . i) == -1) { msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; } break ; default : // Validate the input attribute against a list of valid attributes. if (validate_attr(my_opts -> attr) == -1) { msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",993,-56.76928537974383,-0.05716947168151443
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
Fixed code:","
static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { //Validate Input if(validateInput(pfilegen_token->i)){ filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; DPRINTF ( 4 , ( ""enabling filegen for %s statistics \'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; }else{ msyslog ( LOG_ERR , ""Invalid input for filegen token %s"" , pfilegen_token -> i ) ; exit ( 1 ) ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : //Validate Input if(validateInput(my_opts->value.i)){ filegen_flag = my_opts->value.i ; break ; }else{ msyslog ( LOG_ERR , ""Unknown filegen flag token %d"" , my_opts -> value . i ) ; exit ( 1 ) ; } } break ; default : //Validate Input if(validateInput(my_opts->attr)){ filegen_flag = my_opts->attr ; break ; }else{ msyslog ( LOG_ERR , ""Unknown filegen option token %d"" , my_opts -> attr ) ; exit ( 1 ) ; } } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }",920,-40.56167141048782,-0.044088773272269365
