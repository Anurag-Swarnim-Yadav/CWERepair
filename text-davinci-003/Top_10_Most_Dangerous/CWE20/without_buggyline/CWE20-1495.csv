Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
    struct snd_timer * timer = NULL ; 
    struct snd_timer_instance * slave , * tmp ; 

    //Validate input
    if (!timeri || snd_BUG_ON(!timeri)) 
        return -ENXIO; 
    
    snd_timer_stop ( timeri ) ; 
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & slave_active_lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & slave_active_lock ) ; 
        } 
        spin_unlock_irq ( & slave_active_lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        mutex_unlock ( & register_mutex ) ; 
    } else { 
        timer = timeri -> timer ; 
        //Validate input
        if ( snd_BUG_ON ( ! timer ) ) 
            goto out ; 
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & timer -> lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close )
            timer -> hw . close ( timer ) ; 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
            spin_lock_irq ( & slave_active_lock ) ; 
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
            slave -> master = NULL ; 
            slave -> timer = NULL ; 
            spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
    } 
out : 
    if ( timeri -> private_free ) 
        timeri -> private_free ( timeri ) ; 
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) 
        module_put ( timer -> module ) ; 
    return 0 ; 
}",758,-30.163792740099193,-0.039793921820711335
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( ! timer || snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",602,-4.309909780752677,-0.007159318572678866
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
    struct snd_timer * timer = NULL ; 
    struct snd_timer_instance * slave , * tmp ; 
    if ( ! timeri || snd_BUG_ON ( ! timeri ) ) {
        return - ENXIO ;
    }
    snd_timer_stop ( timeri ) ; 
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & slave_active_lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & slave_active_lock ) ; 
        } 
        spin_unlock_irq ( & slave_active_lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        mutex_unlock ( & register_mutex ) ; 
    } else { 
        timer = timeri -> timer ; 
        if ( snd_BUG_ON ( ! timer ) ) {
            goto out ;
        } 
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & timer -> lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) {
            timer -> hw . close ( timer ) ; 
        } 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
            spin_lock_irq ( & slave_active_lock ) ; 
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
            slave -> master = NULL ; 
            slave -> timer = NULL ; 
            spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
    } 
    out : 
    if ( timeri -> private_free ) {
        timeri -> private_free ( timeri ) ; 
    }
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) {
        module_put ( timer -> module ) ; 
    } 
    return 0 ; 
}",764,-20.295289131577732,-0.02656451457012792
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
if ( timeri == NULL) return -ENXIO; 
if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) { 
 spin_lock_irq ( & slave_active_lock ) ; 
while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
 spin_unlock_irq ( & slave_active_lock ) ; 
 udelay ( 10 ) ; 
 spin_lock_irq ( & slave_active_lock ) ; 
 } 
spin_unlock_irq ( & slave_active_lock ) ; 
mutex_lock ( & register_mutex ) ; 
list_del ( & timeri -> open_list ) ; 
mutex_unlock ( & register_mutex ) ; 
} 
else { 
timer = timeri -> timer ; 
if ( timer == NULL ) goto out ; 
 spin_lock_irq ( & timer -> lock ) ; 
while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
spin_unlock_irq ( & timer -> lock ) ; 
udelay ( 10 ) ; 
spin_lock_irq ( & timer -> lock ) ; 
} 
spin_unlock_irq ( & timer -> lock ) ; 
mutex_lock ( & register_mutex ) ; 
list_del ( & timeri -> open_list ) ; 
if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
spin_lock_irq ( & slave_active_lock ) ; 
_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
slave -> master = NULL ; 
slave -> timer = NULL ; 
spin_unlock_irq ( & slave_active_lock ) ; 
} 
mutex_unlock ( & register_mutex ) ; 
} 
out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) module_put ( timer -> module ) ; 
return 0 ; 
}",655,-36.012258796707464,-0.05498054778123277
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) {
    struct snd_timer * timer = NULL ;
    struct snd_timer_instance * slave , * tmp ;
    if ( timeri ) { //fixed
        if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ;
        snd_timer_stop ( timeri ) ;
        if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) {
            spin_lock_irq ( & slave_active_lock ) ;
            while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
                spin_unlock_irq ( & slave_active_lock ) ;
                udelay ( 10 ) ;
                spin_lock_irq ( & slave_active_lock ) ;
            }
            spin_unlock_irq ( & slave_active_lock ) ;
            mutex_lock ( & register_mutex ) ;
            list_del ( & timeri -> open_list ) ;
            mutex_unlock ( & register_mutex ) ;
        } else {
            timer = timeri -> timer ;
            if ( snd_BUG_ON ( ! timer ) ) goto out ;
            spin_lock_irq ( & timer -> lock ) ;
            while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
                spin_unlock_irq ( & timer -> lock ) ;
                udelay ( 10 ) ;
                spin_lock_irq ( & timer -> lock ) ;
            }
            spin_unlock_irq ( & timer -> lock ) ;
            mutex_lock ( & register_mutex ) ;
            list_del ( & timeri -> open_list ) ;
            if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ;
            list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {
                spin_lock_irq ( & slave_active_lock ) ;
                _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ;
                list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ;
                slave -> master = NULL ;
                slave -> timer = NULL ;
                spin_unlock_irq ( & slave_active_lock ) ;
            }
            mutex_unlock ( & register_mutex ) ;
        }
    }
out : 
    if ( timeri -> private_free ) timeri -> private_free ( timeri ) ;
    kfree ( timeri -> owner ) ;
    kfree ( timeri ) ;
    if ( timer ) module_put ( timer -> module ) ;
    return 0 ;
}",697,-25.89582085735664,-0.03715325804498801
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 

if ( timeri == NULL ) return -ENXIO;
if ( !timeri || !timeri->timer ) return -EINVAL; 

snd_timer_stop ( timeri ) ; 

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; 

if ( !timer ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; }

out : 
if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",615,-35.4966422239568,-0.057718117437328124
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; if (timeri->owner) { kfree ( timeri -> owner ) ; } kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",608,-10.08897888548062,-0.01659371527217207
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
//Implement input validation
if ( timeri == NULL || snd_BUG_ON ( ! timeri ) ) return - ENXIO ;

snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",612,-20.466925480738023,-0.03344268869401638
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
//Check if timeri is valid
if ( timeri == NULL || timeri < 0) return - ENXIO ; 

snd_timer_stop ( timeri ) ; 

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & slave_active_lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
} 
else { 
    timer = timeri -> timer ; 
    //Check if timer is valid
    if ( timer == NULL || timer < 0) goto out ; 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & timer -> lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
        list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
        slave -> master = NULL ; 
        slave -> timer = NULL ; 
        spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
} 
out : 
if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) module_put ( timer -> module ) ; 
return 0 ; 
}",729,-32.228588641509084,-0.04420931226544456
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
//Validate timeri
if ( timeri == NULL || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; 

snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; 
//Validate timer
if ( timer == NULL || snd_BUG_ON ( ! timer ) ) goto out ; 
	
spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",628,-22.44253885736289,-0.03573652684293454
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close(struct snd_timer_instance *timeri) {
    struct snd_timer *timer = NULL;
    struct snd_timer_instance *slave, *tmp;
    
    // Validate input
    if (snd_BUG_ON(!timeri) || snd_BUG_ON(timeri->flags & SNDRV_TIMER_IFLG_SLAVE)) return -ENXIO;
    
    snd_timer_stop(timeri);
    
    timer = timeri->timer;
    if (snd_BUG_ON(!timer)) goto out;
    spin_lock_irq(&timer->lock);
    while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
        spin_unlock_irq(&timer->lock);
        udelay(10);
        spin_lock_irq(&timer->lock);
    }
    spin_unlock_irq(&timer->lock);
    mutex_lock(&register_mutex);
    list_del(&timeri->open_list);
    if (timer && list_empty(&timer->open_list_head) && timer->hw.close) timer->hw.close(timer);
    list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head, open_list) {
        spin_lock_irq(&slave_active_lock);
        _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
        list_move_tail(&slave->open_list, &snd_timer_slave_list);
        slave->master = NULL;
        slave->timer = NULL;
        spin_unlock_irq(&slave_active_lock);
    }
    mutex_unlock(&register_mutex);
    
    out:
    if (timeri->private_free) timeri->private_free(timeri);
    kfree(timeri->owner);
    kfree(timeri);
    if (timer) module_put(timer->module);
    return 0;
}",509,-29.058782262417484,-0.05708994550573179
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
struct snd_timer * timer = NULL ; 
struct snd_timer_instance * slave , * tmp ; 

if (! timeri || ! timeri->timer)
    return -ENXIO;

snd_timer_stop ( timeri ) ; 

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & slave_active_lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
} else { 
    timer = timeri -> timer ; 

    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & timer -> lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
        timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
        list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
        slave -> master = NULL ; 
        slave -> timer = NULL ; 
        spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 

} 

if ( timeri -> private_free ) 
    timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) 
    module_put ( timer -> module ) ; 
return 0 ; 
}",705,-29.05511848973734,-0.04121293402799622
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close(struct snd_timer_instance *timeri) {
    struct snd_timer *timer = NULL;
    struct snd_timer_instance *slave, *tmp;

    if (!timeri || snd_BUG_ON(!timeri)) 
        return -ENXIO;
    snd_timer_stop(timeri);
    
    if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
        spin_lock_irq(&slave_active_lock);
        while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
            spin_unlock_irq(&slave_active_lock);
            udelay(10);
            spin_lock_irq(&slave_active_lock);
        }
        spin_unlock_irq(&slave_active_lock);
        mutex_lock(&register_mutex);
        list_del(&timeri->open_list);
        mutex_unlock(&register_mutex);
    } else {
        timer = timeri->timer;
        if (!timer || snd_BUG_ON(!timer)) 
            goto out;
        spin_lock_irq(&timer->lock);
        while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
            spin_unlock_irq(&timer->lock);
            udelay(10);
            spin_lock_irq(&timer->lock);
        }
        spin_unlock_irq(&timer->lock);
        mutex_lock(&register_mutex);
        list_del(&timeri->open_list);
        if (timer && list_empty(&timer->open_list_head) && timer->hw.close) 
            timer->hw.close(timer);
        list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head, open_list) {
            spin_lock_irq(&slave_active_lock);
            _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
            list_move_tail(&slave->open_list, &snd_timer_slave_list);
            slave->master = NULL;
            slave->timer = NULL;
            spin_unlock_irq(&slave_active_lock);
        }
        mutex_unlock(&register_mutex);
    }
out:
    if (timeri->private_free) 
        timeri->private_free(timeri);
    kfree(timeri->owner);
    kfree(timeri);
    if (timer) 
        module_put(timer->module);
    return 0;
}",657,-19.43583309786481,-0.029582698779094075
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri ) return - ENXIO ; 

//Added validation to check if timeri is NULL
if (!timeri || snd_bug_on(!timeri)) return -ENXIO;

snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",625,-26.767227805648893,-0.04282756448903823
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
    struct snd_timer * timer = NULL ; 
    struct snd_timer_instance * slave , * tmp ; 
    int ret = 0; 
    
    //Check for NULL pointer
    if ( timeri == NULL ) { 
        ret = -ENXIO; 
        goto out; 
    } 
    
    snd_timer_stop ( timeri ) ; 
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & slave_active_lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & slave_active_lock ) ; 
        } 
        spin_unlock_irq ( & slave_active_lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        mutex_unlock ( & register_mutex ) ; 
    } 
    else { 
        timer = timeri -> timer ; 
        if ( timer == NULL ) { 
            ret = -ENXIO; 
            goto out; 
        } 
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & timer -> lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
            timer -> hw . close ( timer ) ; 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
            spin_lock_irq ( & slave_active_lock ) ; 
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
            slave -> master = NULL ; 
            slave -> timer = NULL ; 
            spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
    } 
out : 
    if ( timeri -> private_free ) 
        timeri -> private_free ( timeri ) ; 
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) 
        module_put ( timer -> module ) ; 
    return ret; 
}",778,-30.35457379781877,-0.03901616169385446
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( ! timer || snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",602,-4.309909780752677,-0.007159318572678866
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
if ( !timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ;

snd_timer_stop ( timeri ) ;

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) {
    spin_lock_irq ( & slave_active_lock ) ;
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
        spin_unlock_irq ( & slave_active_lock ) ;
        udelay ( 10 ) ;
        spin_lock_irq ( & slave_active_lock ) ;
    }
    spin_unlock_irq ( & slave_active_lock ) ;
    mutex_lock ( & register_mutex ) ;
    list_del ( & timeri -> open_list ) ;
    mutex_unlock ( & register_mutex ) ;
} else {
    timer = timeri -> timer ;
    if ( snd_BUG_ON ( ! timer ) ) goto out ;
    spin_lock_irq ( & timer -> lock ) ;
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
        spin_unlock_irq ( & timer -> lock ) ;
        udelay ( 10 ) ;
        spin_lock_irq ( & timer -> lock ) ;
    }
    spin_unlock_irq ( & timer -> lock ) ;
    mutex_lock ( & register_mutex ) ;
    list_del ( & timeri -> open_list ) ;
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ;
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {
        spin_lock_irq ( & slave_active_lock ) ;
        _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ;
        list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ;
        slave -> master = NULL ;
        slave -> timer = NULL ;
        spin_unlock_irq ( & slave_active_lock ) ;
    }
    mutex_unlock ( & register_mutex ) ;
}

out :
if ( timeri -> private_free ) timeri -> private_free ( timeri ) ;
kfree ( timeri -> owner ) ;
kfree ( timeri ) ;
if ( timer ) module_put ( timer -> module ) ;
return 0 ;
}",677,-19.1162624880738,-0.02823672450232467
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
  struct snd_timer * timer = NULL ; 
  struct snd_timer_instance * slave , * tmp ; 

  // Validate input 
  if ( timeri == NULL || snd_BUG_ON ( ! timeri ) ) { 
    return - ENXIO ; 
  } 
  snd_timer_stop ( timeri ) ; 
  if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & slave_active_lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
  } else { 
    timer = timeri -> timer ; 
    if ( snd_BUG_ON ( ! timer ) ) { 
      goto out ; 
    } 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & timer -> lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) { 
      timer -> hw . close ( timer ) ; 
    } 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
      spin_lock_irq ( & slave_active_lock ) ; 
      _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
      list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
      slave -> master = NULL ; 
      slave -> timer = NULL ; 
      spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
  } 
out : 
  if ( timeri -> private_free ) { 
    timeri -> private_free ( timeri ) ; 
  } 
  kfree ( timeri -> owner ) ; 
  kfree ( timeri ) ; 
  if ( timer ) { 
    module_put ( timer -> module ) ; 
  } 
  return 0 ; 
}",780,-23.0104474028294,-0.029500573593371025
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE && timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( ! timer || snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",640,-13.876678543125173,-0.021682310223633084
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close(struct snd_timer_instance * timeri) {
    struct snd_timer *timer = NULL;
    struct snd_timer_instance *slave, *tmp;
    
    if(timeri == NULL) 
        return -ENXIO; 

    if(timeri->flags & SNDRV_TIMER_IFLG_SLAVE){
        spin_lock_irq(&slave_active_lock); 
        while(timeri->flags & SNDRV_TIMER_IFLG_CALLBACK){ 
            spin_unlock_irq(&slave_active_lock); 
            udelay(10); 
            spin_lock_irq(&slave_active_lock); 
        }
        spin_unlock_irq(&slave_active_lock); 
        mutex_lock(&register_mutex); 
        list_del(&timeri->open_list); 
        mutex_unlock(&register_mutex); 
    }
    else{ 
        timer = timeri->timer; 
        if(timer == NULL) 
            goto out; 

        spin_lock_irq(&timer->lock); 
        while(timeri->flags & SNDRV_TIMER_IFLG_CALLBACK){ 
            spin_unlock_irq(&timer->lock); 
            udelay(10); 
            spin_lock_irq(&timer->lock); 
        }
        spin_unlock_irq(&timer->lock); 
        mutex_lock(&register_mutex); 
        list_del(&timeri->open_list); 
        if(timer && list_empty(&timer->open_list_head) && timer->hw.close) 
            timer->hw.close(timer); 
        list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head, open_list){ 
            spin_lock_irq(&slave_active_lock); 
            _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION); 
            list_move_tail(&slave->open_list, &snd_timer_slave_list); 
            slave->master = NULL; 
            slave->timer = NULL; 
            spin_unlock_irq(&slave_active_lock); 
        }
        mutex_unlock(&register_mutex); 
    } 

out: 
    if(timeri->private_free) 
        timeri->private_free(timeri); 
    kfree(timeri->owner); 
    kfree(timeri); 
    if(timer) 
        module_put(timer->module); 
    return 0; 
}",664,-42.62808054776342,-0.06419891648759551
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
  struct snd_timer * timer = NULL ; 
  struct snd_timer_instance * slave , * tmp ; 
 
  //Added input validation 
  if (!timeri || !timeri->timer || !timer || !timer->module) {
    return -ENXIO;
  }

  snd_timer_stop ( timeri ) ; 
 
  if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & slave_active_lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
  } else { 
    timer = timeri -> timer ; 
    if ( snd_BUG_ON ( ! timer ) ) goto out ; 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & timer -> lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
      spin_lock_irq ( & slave_active_lock ) ; 
      _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
      list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
      slave -> master = NULL ; 
      slave -> timer = NULL ; 
      spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
  } 

out : 
  if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
  kfree ( timeri -> owner ) ; 
  kfree ( timeri ) ; 
  if ( timer ) module_put ( timer -> module ) ; 
  return 0 ; 
}",750,-38.594583983008164,-0.05145944531067755
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 

// Add input validation
if ( snd_BUG_ON ( ! timeri ) || snd_BUG_ON ( !(timeri->flags & SNDRV_TIMER_IFLG_SLAVE) && !timeri->timer ) ) return - ENXIO ; 

snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",630,-24.937443912975247,-0.03958324430630992
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:"," 
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
if (timeri == NULL || snd_BUG_ON ( ! timeri ) ) return -ENXIO ; 
snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
spin_lock_irq ( & slave_active_lock ) ; 
while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
spin_unlock_irq ( & slave_active_lock ) ; 
udelay ( 10 ) ; 
spin_lock_irq ( & slave_active_lock ) ; 
} 
spin_unlock_irq ( & slave_active_lock ) ; 
mutex_lock ( & register_mutex ) ; 
list_del ( & timeri -> open_list ) ; 
mutex_unlock ( & register_mutex ) ; 
} else { 
timer = timeri -> timer ; 
if ( snd_BUG_ON ( ! timer ) ) goto out ; 
spin_lock_irq ( & timer -> lock ) ; 
while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
spin_unlock_irq ( & timer -> lock ) ; 
udelay ( 10 ) ; 
spin_lock_irq ( & timer -> lock ) ; 
} 
spin_unlock_irq ( & timer -> lock ) ; 
mutex_lock ( & register_mutex ) ; 
list_del ( & timeri -> open_list ) ; 
if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
spin_lock_irq ( & slave_active_lock ) ; 
_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
slave -> master = NULL ; 
slave -> timer = NULL ; 
spin_unlock_irq ( & slave_active_lock ) ; 
} 
mutex_unlock ( & register_mutex ) ; 
} 
out : 
if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) module_put ( timer -> module ) ; 
return 0 ; 
}",689,-22.52406484291774,-0.0326909504251346
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close(struct snd_timer_instance * timeri) 
{ 
    struct snd_timer * timer = NULL; 
    struct snd_timer_instance * slave, * tmp; 
    int err;
    
    err = 0;
    if (timeri == NULL) 
        err = -ENXIO;
    
    if (err == 0) 
        snd_timer_stop(timeri);

    if (err == 0 && (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)) {
        spin_lock_irq(&slave_active_lock); 
        while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
            spin_unlock_irq(&slave_active_lock); 
            udelay(10); 
            spin_lock_irq(&slave_active_lock); 
        }
        spin_unlock_irq(&slave_active_lock); 
        mutex_lock(&register_mutex); 
        list_del(&timeri->open_list); 
        mutex_unlock(&register_mutex); 
    } else {
        err = -ENXIO;
        if (timeri->timer != NULL) {
            timer = timeri->timer; 
            spin_lock_irq(&timer->lock); 
            while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
                spin_unlock_irq(&timer->lock); 
                udelay(10); 
                spin_lock_irq(&timer->lock); 
            }
            spin_unlock_irq(&timer->lock); 
            mutex_lock(&register_mutex); 
            list_del(&timeri->open_list); 
            if (timer && list_empty(&timer->open_list_head) && timer->hw.close) 
                timer->hw.close(timer); 
            list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head, open_list) {
                spin_lock_irq(&slave_active_lock); 
                _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION); 
                list_move_tail(&slave->open_list, &snd_timer_slave_list); 
                slave->master = NULL; 
                slave->timer = NULL; 
                spin_unlock_irq(&slave_active_lock); 
            }
            mutex_unlock(&register_mutex); 
        }
    }

    if (timeri->private_free) 
        timeri->private_free(timeri); 
    kfree(timeri->owner); 
    kfree(timeri); 
    
    if (timer) 
        module_put(timer->module); 
    
    return err; 
}",713,-58.9767115848228,-0.0827162855327108
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { // Adding a check to see if the timeri is not NULL if ( timeri == NULL ) return - ENXIO; struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; // Adding a check to see if the slave is not NULL if (slave != NULL) { list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; } spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",641,-38.11971682975705,-0.0594691370199018
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
  struct snd_timer * timer = NULL ; 
  struct snd_timer_instance * slave , * tmp ; 
  
  if ( timeri == NULL || snd_BUG_ON(timeri == NULL) ) 
    return - ENXIO ; 
    
  snd_timer_stop ( timeri ) ; 
  
  if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & slave_active_lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
  } else { 
    timer = timeri -> timer ; 
    if ( snd_BUG_ON ( ! timer ) ) 
      goto out ; 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & timer -> lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
      timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
      spin_lock_irq ( & slave_active_lock ) ; 
      _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
      list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
      slave -> master = NULL ; 
      slave -> timer = NULL ; 
      spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
  } 
out : 
  if ( timeri -> private_free ) 
    timeri -> private_free ( timeri ) ; 
  kfree ( timeri -> owner ) ; 
  kfree ( timeri ) ; 
  if ( timer ) 
    module_put ( timer -> module ) ; 
  return 0 ; 
}",755,-24.09644217683829,-0.03191581745276595
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
    struct snd_timer * timer = NULL ; 
    struct snd_timer_instance * slave , * tmp ; 
    
    if ( timeri == NULL ) return - ENXIO ; 
    snd_timer_stop ( timeri ) ; 
    
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & slave_active_lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & slave_active_lock ) ; 
        } 
        spin_unlock_irq ( & slave_active_lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        mutex_unlock ( & register_mutex ) ; 
    } else { 
        timer = timeri -> timer ; 
        if ( timer == NULL ) goto out ; 
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & timer -> lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
            spin_lock_irq ( & slave_active_lock ) ; 
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
            slave -> master = NULL ; 
            slave -> timer = NULL ; 
            spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
    } 
    out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) module_put ( timer -> module ) ; 
    return 0 ; 
}",716,-15.62637216879919,-0.0218245421351944
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( timeri == NULL ) return - ENXIO ; // Added input validation snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( timer == NULL ) goto out ; // Added input validation spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",589,-8.851805017119261,-0.015028531438233041
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:"," 
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 

// Validate input
if ( timeri == NULL || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; 

snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) {
spin_lock_irq ( & slave_active_lock ) ; 
while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
spin_unlock_irq ( & slave_active_lock ) ; 
udelay ( 10 ) ; 
spin_lock_irq ( & slave_active_lock ) ; 
}
spin_unlock_irq ( & slave_active_lock ) ; 
mutex_lock ( & register_mutex ) ; 
list_del ( & timeri -> open_list ) ; 
mutex_unlock ( & register_mutex ) ; 
} 
else {
timer = timeri -> timer ; 
if ( snd_BUG_ON ( ! timer ) ) goto out ; 
spin_lock_irq ( & timer -> lock ) ; 
while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
spin_unlock_irq ( & timer -> lock ) ; 
udelay ( 10 ) ; 
spin_lock_irq ( & timer -> lock ) ; 
}
spin_unlock_irq ( & timer -> lock ) ; 
mutex_lock ( & register_mutex ) ; 
list_del ( & timeri -> open_list ) ; 
if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {
spin_lock_irq ( & slave_active_lock ) ; 
_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
slave -> master = NULL ; 
slave -> timer = NULL ; 
spin_unlock_irq ( & slave_active_lock ) ; 
}
mutex_unlock ( & register_mutex ) ; 
}
out : 
if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) module_put ( timer -> module ) ; 
return 0 ; 
}",689,-26.9975116167608,-0.03918361627976894
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
  struct snd_timer * timer = NULL ; 
  struct snd_timer_instance * slave , * tmp ; 
 
  //Check for null pointer
  if ( snd_BUG_ON ( ! timeri ) || snd_BUG_ON ( ! timer ) ) return - ENXIO ; 
  
  //Check for valid input
  if ( !( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) && !( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) ){
    return - ENXIO;
  }
  
  snd_timer_stop ( timeri ) ; 
  if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & slave_active_lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
  } else { 
    timer = timeri -> timer ; 
    if ( snd_BUG_ON ( ! timer ) ) goto out ; 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & timer -> lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
      spin_lock_irq ( & slave_active_lock ) ; 
      _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
      list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
      slave -> master = NULL ; 
      slave -> timer = NULL ; 
      spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
  } 
 out : 
  if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
  kfree ( timeri -> owner ) ; 
  kfree ( timeri ) ; 
  if ( timer ) module_put ( timer -> module ) ; 
  return 0 ; 
}",823,-43.15155767084557,-0.0524320263315256
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:"," 
int snd_timer_close(struct snd_timer_instance* timeri) {
    struct snd_timer* timer = NULL;
    struct snd_timer_instance* slave, *tmp;
    if (timeri == NULL || timeri->flags & ~(SNDRV_TIMER_IFLG_SLAVE | SNDRV_TIMER_IFLG_CALLBACK)) {
        return -ENXIO;
    }
    snd_timer_stop(timeri);
    if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
        spin_lock_irq(&slave_active_lock);
        while(timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
            spin_unlock_irq(&slave_active_lock);
            udelay(10);
            spin_lock_irq(&slave_active_lock);
        }
        spin_unlock_irq(&slave_active_lock);
        mutex_lock(&register_mutex);
        list_del(&timeri->open_list);
        mutex_unlock(&register_mutex);
    } else {
        timer = timeri->timer;
        if (timer == NULL) {
            goto out;
        }
        spin_lock_irq(&timer->lock);
        while(timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
            spin_unlock_irq(&timer->lock);
            udelay(10);
            spin_lock_irq(&timer->lock);
        }
        spin_unlock_irq(&timer->lock);
        mutex_lock(&register_mutex);
        list_del(&timeri->open_list);
        if (timer && list_empty(&timer->open_list_head) && timer->hw.close) {
            timer->hw.close(timer);
        }
        list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head, open_list) {
            spin_lock_irq(&slave_active_lock);
            _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
            list_move_tail(&slave->open_list, &snd_timer_slave_list);
            slave->master = NULL;
            slave->timer = NULL;
            spin_unlock_irq(&slave_active_lock);
        }
        mutex_unlock(&register_mutex);
    }
out:
    if (timeri->private_free) {
        timeri->private_free(timeri);
    }
    kfree(timeri->owner);
    kfree(timeri);
    if (timer) {
        module_put(timer->module);
    } 
    return 0;
}",694,-32.43487662819856,-0.04673613347002674
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( ! timer ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }

The vulnerability is fixed by replacing the line 

if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; 

with 

if ( ! timeri ) return - ENXIO ;",631,-20.854383810021687,-0.03304973662444007
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:"," 

int snd_timer_close ( struct snd_timer_instance * timeri ) { 
    struct snd_timer * timer = NULL ; 
    struct snd_timer_instance * slave , * tmp ; 

    // Check for valid input
    if (!timeri || snd_BUG_ON(!timeri)) 
        return -ENXIO; 

    snd_timer_stop ( timeri ) ; 
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & slave_active_lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & slave_active_lock ) ; 
        } 
        spin_unlock_irq ( & slave_active_lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        mutex_unlock ( & register_mutex ) ; 
    } else { 
        timer = timeri -> timer ; 
        if ( snd_BUG_ON ( ! timer ) ) 
            goto out ; 
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & timer -> lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
            timer -> hw . close ( timer ) ; 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
            spin_lock_irq ( & slave_active_lock ) ; 
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
            slave -> master = NULL ; 
            slave -> timer = NULL ; 
            spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
    } 

out : 
    if ( timeri -> private_free ) 
        timeri -> private_free ( timeri ) ; 
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) 
        module_put ( timer -> module ) ; 
    return 0 ; 
}",755,-26.729977902937883,-0.03540394424230183
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( timeri == NULL ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",600,-8.031082147864506,-0.01338513691310751
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( timeri == NULL || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( timer == NULL || snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",604,-6.687786504608829,-0.011072494212928526
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; //Validate input if ( timeri == NULL) return - ENXIO ; //Validation succeeded, so continue with code snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; //Validate data if ( timer == NULL ) goto out ; //Validation succeeded, so continue with code spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",607,-39.514667520493035,-0.06509829904529331
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) {
    struct snd_timer * timer = NULL ;
    struct snd_timer_instance * slave , * tmp ;
    
    //Added input validation check
    if(timeri == NULL || snd_BUG_ON( !timeri ) || !timeri->flags || !SNDRV_TIMER_IFLG_SLAVE)
    	return - ENXIO;
    
    snd_timer_stop ( timeri ) ;
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) {
        spin_lock_irq ( & slave_active_lock ) ;
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
            spin_unlock_irq ( & slave_active_lock ) ;
            udelay ( 10 ) ;
            spin_lock_irq ( & slave_active_lock ) ;
        }
        spin_unlock_irq ( & slave_active_lock ) ;
        mutex_lock ( & register_mutex ) ;
        list_del ( & timeri -> open_list ) ;
        mutex_unlock ( & register_mutex ) ;
    } else {
        timer = timeri -> timer ;
        if ( snd_BUG_ON ( ! timer ) ) goto out ;
        spin_lock_irq ( & timer -> lock ) ;
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
            spin_unlock_irq ( & timer -> lock ) ;
            udelay ( 10 ) ;
            spin_lock_irq ( & timer -> lock ) ;
        }
        spin_unlock_irq ( & timer -> lock ) ;
        mutex_lock ( & register_mutex ) ;
        list_del ( & timeri -> open_list ) ;
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ;
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {
            spin_lock_irq ( & slave_active_lock ) ;
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ;
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ;
            slave -> master = NULL ;
            slave -> timer = NULL ;
            spin_unlock_irq ( & slave_active_lock ) ;
        }
        mutex_unlock ( & register_mutex ) ;
    }

out :
    if ( timeri -> private_free ) timeri -> private_free ( timeri ) ;
    kfree ( timeri -> owner ) ;
    kfree ( timeri ) ;
    if ( timer ) module_put ( timer -> module ) ;
    return 0 ;
}",726,-46.79327995718494,-0.06445355366003436
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; //Validate the input if ( timeri == NULL || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",605,-11.369508663425908,-0.018792576303183317
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; 
struct snd_timer_instance * slave , * tmp ; 

if (snd_BUG_ON(!timeri) || timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
    return -ENXIO;
}

snd_timer_stop(timeri);

if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
    spin_lock_irq(&slave_active_lock);
    mutex_lock(&register_mutex);
    list_del(&timeri->open_list);
    mutex_unlock(&register_mutex);
    spin_unlock_irq(&slave_active_lock);
} else {
    timer = timeri->timer;
    if (snd_BUG_ON(!timer)) goto out;
    spin_lock_irq(&timer->lock);
    mutex_lock(&register_mutex);
    list_del(&timeri->open_list);
    if (timer && list_empty(&timer->open_list_head) && timer->hw.close) 
        timer->hw.close (timer);
    list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head, open_list) {
        spin_lock_irq(&slave_active_lock);
        _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
        list_move_tail(&slave->open_list, &snd_timer_slave_list);
        slave->master = NULL;
        slave->timer = NULL;
        spin_unlock_irq(&slave_active_lock);
    }
    mutex_unlock(&register_mutex);
    spin_unlock_irq(&timer->lock);
}
out:
    if (timeri->private_free) timeri->private_free(timeri);
    kfree(timeri->owner);
    kfree(timeri);
    if (timer) module_put (timer->module);
    return 0;
}",532,-48.47107130998541,-0.09111103629696506
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) || !timeri->owner || !timeri->private_free) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",609,-10.443958968179661,-0.01714935791162506
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
  struct snd_timer * timer = NULL ; 
  struct snd_timer_instance * slave , * tmp ; 
  
  // Check for NULL pointer
  if ( ! timeri ) 
    return - ENXIO ; 
  
  snd_timer_stop ( timeri ) ; 
  
  if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & slave_active_lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
  } 
  else { 
    timer = timeri -> timer ; 
    if ( ! timer ) 
      goto out ; 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & timer -> lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close )
      timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
      spin_lock_irq ( & slave_active_lock ) ; 
      _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
      list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
      slave -> master = NULL ; 
      slave -> timer = NULL ; 
      spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
  } 

out : 
  if ( timeri -> private_free ) 
    timeri -> private_free ( timeri ) ; 
  kfree ( timeri -> owner ) ; 
  kfree ( timeri ) ; 
  if ( timer ) 
    module_put ( timer -> module ) ; 
  return 0 ; 
}",743,-29.65707666803423,-0.03991531180085361
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( ! timer || snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",602,-4.329962645932682,-0.0071926289799546204
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( ! timer || snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",602,-4.329099660804484,-0.007191195449841336
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 

if (!timeri || snd_BUG_ON ( ! timeri ) || !timeri->timer || snd_BUG_ON ( ! timer ) ) return - ENXIO ; 

snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; 
}

The code has been fixed by adding additional checks to ensure that the timeri and timer variables are not null before attempting to access them. This will prevent the code from crashing due to a null pointer exception and help prevent improper input validation.",656,-52.27568420506962,-0.07968854299553296
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
  struct snd_timer * timer = NULL ; 
  struct snd_timer_instance * slave , * tmp ;

  // Validate timeri
  if (timeri == NULL || snd_BUG_ON(!timeri))
    return -ENXIO ;

  snd_timer_stop ( timeri ) ;

  if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) {
    spin_lock_irq ( & slave_active_lock ) ;
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
      spin_unlock_irq ( & slave_active_lock ) ;
      udelay ( 10 ) ;
      spin_lock_irq ( & slave_active_lock ) ;
    }
    spin_unlock_irq ( & slave_active_lock ) ;
    mutex_lock ( & register_mutex ) ;
    list_del ( & timeri -> open_list ) ;
    mutex_unlock ( & register_mutex ) ;
  } else {
    timer = timeri -> timer ;

    // Validate timer
    if (timer == NULL || snd_BUG_ON(!timer))
      goto out ;

    spin_lock_irq ( & timer -> lock ) ;
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
      spin_unlock_irq ( & timer -> lock ) ;
      udelay ( 10 ) ;
      spin_lock_irq ( & timer -> lock ) ;
    }
    spin_unlock_irq ( & timer -> lock ) ;
    mutex_lock ( & register_mutex ) ;
    list_del ( & timeri -> open_list ) ;
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
      timer -> hw . close ( timer ) ;
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {
      spin_lock_irq ( & slave_active_lock ) ;
      _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ;
      list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ;
      slave -> master = NULL ;
      slave -> timer = NULL ;
      spin_unlock_irq ( & slave_active_lock ) ;
    }
    mutex_unlock ( & register_mutex ) ;
  }

out:
  if ( timeri -> private_free ) 
    timeri -> private_free ( timeri ) ;
  kfree ( timeri -> owner ) ;
  kfree ( timeri ) ;
  if ( timer ) 
    module_put ( timer -> module ) ;
  return 0 ;
}",719,-33.96176448249844,-0.04723472111613135
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) {
   struct snd_timer * timer = NULL ;
   struct snd_timer_instance * slave , * tmp ;

   if ( timeri == NULL || snd_BUG_ON ( ! timeri ) ) 
      return - ENXIO ; 

   // Check if input is valid
   if (!isValidInput(timeri)) {
      return -ENXIO;
   }

   snd_timer_stop ( timeri ) ; 
   if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
      spin_lock_irq ( & slave_active_lock ) ; 
      while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
         spin_unlock_irq ( & slave_active_lock ) ; 
         udelay ( 10 ) ; 
         spin_lock_irq ( & slave_active_lock ) ; 
      } 
      spin_unlock_irq ( & slave_active_lock ) ; 
      mutex_lock ( & register_mutex ) ; 
      list_del ( & timeri -> open_list ) ; 
      mutex_unlock ( & register_mutex ) ; 
   } 
   else { 
      timer = timeri -> timer ; 
      if ( snd_BUG_ON ( ! timer ) ) 
         goto out ; 
      spin_lock_irq ( & timer -> lock ) ; 
      while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
         spin_unlock_irq ( & timer -> lock ) ; 
         udelay ( 10 ) ; 
         spin_lock_irq ( & timer -> lock ) ; 
      } 
      spin_unlock_irq ( & timer -> lock ) ; 
      mutex_lock ( & register_mutex ) ; 
      list_del ( & timeri -> open_list ) ; 
      if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
         timer -> hw . close ( timer ) ; 
      list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
         spin_lock_irq ( & slave_active_lock ) ; 
         _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
         list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
         slave -> master = NULL ; 
         slave -> timer = NULL ; 
         spin_unlock_irq ( & slave_active_lock ) ; 
      } 
      mutex_unlock ( & register_mutex ) ; 
   } 
out : 
   if ( timeri -> private_free ) 
      timeri -> private_free ( timeri ) ; 
   kfree ( timeri -> owner ) ; 
   kfree ( timeri ) ; 
   if ( timer ) 
      module_put ( timer -> module ) ; 
   return 0 ; 
}",779,-35.780681242471964,-0.045931554868385065
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 

// Input Validation
if (!timeri || snd_BUG_ON(!timeri) || snd_BUG_ON(!timer)) return -ENXIO;

snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; 

// Input Validation
if (snd_BUG_ON(!timer)) return -ENXIO;

spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",630,-23.614145415359204,-0.03748277050057017
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || timeri->flags & SNDRV_TIMER_IFLG_SLAVE || !timeri->timer) { return -ENXIO; } snd_timer_stop ( timeri ) ; spin_lock_irq ( & timeri->timer->lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timeri->timer->lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timeri->timer->lock ) ; } spin_unlock_irq ( & timeri->timer->lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timeri->timer && list_empty ( & timeri->timer->open_list_head ) && timeri->timer->hw.close ) timeri->timer->hw.close ( timeri->timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timeri->timer ) module_put ( timeri->timer->module ) ; return 0 ; }",463,-21.532127870689038,-0.046505675746628596
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( timeri == NULL ) return - ENXIO ; if ( !(timeri -> flags & SNDRV_TIMER_IFLG_SLAVE) ) { spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } else { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } 
if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",557,-21.442586385823603,-0.03849656442697236
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
 struct snd_timer * timer = NULL ; 
 struct snd_timer_instance * slave , * tmp ; 
 if ( timeri == NULL) 
 return -ENXIO; 
 if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) { 
  spin_lock_irq(&slave_active_lock); 
  while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) { 
   spin_unlock_irq(&slave_active_lock); 
   udelay(10); 
   spin_lock_irq(&slave_active_lock); 
  } 
  spin_unlock_irq(&slave_active_lock); 
  mutex_lock(&register_mutex); 
  list_del(&timeri->open_list); 
  mutex_unlock(&register_mutex); 
 } else { 
  timer = timeri->timer; 
  if (timer == NULL) 
  goto out; 
  spin_lock_irq(&timer->lock); 
  while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) { 
   spin_unlock_irq(&timer->lock); 
   udelay(10); 
   spin_lock_irq(&timer->lock); 
  } 
  spin_unlock_irq(&timer->lock); 
  mutex_lock(&register_mutex); 
  list_del(&timeri->open_list); 
  if (timer && list_empty(&timer->open_list_head) && timer->hw.close) 
   timer->hw.close(timer); 
  list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head, open_list) { 
   spin_lock_irq(&slave_active_lock); 
   _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION); 
   list_move_tail(&slave->open_list, &snd_timer_slave_list); 
   slave->master = NULL; 
   slave->timer = NULL; 
   spin_unlock_irq(&slave_active_lock); 
  } 
  mutex_unlock(&register_mutex); 
 } 
 out: if (timeri->private_free) 
  timeri->private_free(timeri); 
 kfree(timeri->owner); 
 kfree(timeri); 
 if (timer) 
  module_put(timer->module); 
 return 0; 
}",656,-33.24844987580234,-0.050683612615552355
