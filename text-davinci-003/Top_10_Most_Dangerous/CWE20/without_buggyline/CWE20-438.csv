Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
char buf [ 2048 ] ; 
unsigned short * cmd = ( unsigned short * ) buf ; 
int plen ; 
struct in_addr * addr = & s_in -> sin_addr ; 
unsigned short * pid = ( unsigned short * ) data ; 

if ( len != S_HELLO_LEN || memcmp ( data , ""sorbo"" , 5 ) != 0 ) {
    return 1;
} 

unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
int x = 2 + 4 + 2 ; 
* cmd = htons ( S_CMD_INET_CHECK ) ; 
memcpy ( cmd + 1 , addr , 4 ) ; 
memcpy ( cmd + 1 + 2 , id , 2 ) ; 
printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
return 0 ; 
} 
* cmd ++ = htons ( S_CMD_PACKET ) ; 
* cmd ++ = * pid ; 
plen = len - 2 ; 
last_id = ntohs ( * pid ) ; 
if ( last_id > 20000 ) wrap = 1 ; 
if ( wrap && last_id < 100 ) { 
    wrap = 0 ; 
    memset ( ids , 0 , sizeof ( ids ) ) ; 
} 
printf ( ""Got packet %d %d"" , last_id , plen ) ; 
if ( is_dup ( last_id ) ) { 
    printf ( "" (DUP)\\n"" ) ; 
    return 0 ; 
} 
printf ( ""\\n"" ) ; 
* cmd ++ = htons ( plen ) ; 
memcpy ( cmd , data + 2 , plen ) ; 
plen += 2 + 2 + 2 ; 
assert ( plen <= ( int ) sizeof ( buf ) ) ; 
if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
return 0 ; 
}",536,-17.540942216492656,-0.032725638463605704
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len != S_HELLO_LEN || memcmp ( data , ""sorbo"" , 5 ) != 0 ) { return 1; }

unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; 

* cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",457,-13.029478219688134,-0.028510893259711453
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } if (len < 2) return 0; * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",458,-8.552563931646432,-0.01867372037477387
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:"," 
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; 
// Added input validation
if (len < S_HELLO_LEN || memcmp(data, ""sorbo"", 5) != 0) {
return 1;
}

if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",494,-21.030434134077097,-0.0425717290163504
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; int x; if (len < S_HELLO_LEN) { return -1; } if (memcmp ( data , ""sorbo"" , 5 ) == 0 ) { x = 2 + 4 + 2; unsigned short * id = ( unsigned short * ) ( data + 5 ) ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } if (len < 2) { return -1; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",471,-27.732755075461277,-0.05888058402433392
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) {
   char buf [ 2048 ] ;
   unsigned short * cmd = ( unsigned short * ) buf ;
   int plen ;
   struct in_addr * addr = & s_in -> sin_addr ;
   unsigned short * pid = ( unsigned short * ) data ;
   if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) {
      unsigned short * id = ( unsigned short * ) ( data + 5 ) ;
      int x = 2 + 4 + 2 ;
      * cmd = htons ( S_CMD_INET_CHECK ) ;
      memcpy ( cmd + 1 , addr , 4 ) ;
      memcpy ( cmd + 1 + 2 , id , 2 ) ;
      printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ;
      if ( send ( s , buf , x , 0 ) != x ) return 1 ;
      return 0 ;
   }

   if (len < 2 || len > 2048) {
      return 1;
   }
   
   * cmd ++ = htons ( S_CMD_PACKET ) ;
   * cmd ++ = * pid ;
   plen = len - 2 ;
   last_id = ntohs ( * pid ) ;
   if ( last_id > 20000 ) wrap = 1 ;
   if ( wrap && last_id < 100 ) {
      wrap = 0 ;
      memset ( ids , 0 , sizeof ( ids ) ) ;
   }
   printf ( ""Got packet %d %d"" , last_id , plen ) ;
   if ( is_dup ( last_id ) ) {
      printf ( "" (DUP)\\n"" ) ;
      return 0 ;
   }
   printf ( ""\\n"" ) ;
   * cmd ++ = htons ( plen ) ;
   memcpy ( cmd , data + 2 , plen ) ;
   plen += 2 + 2 + 2 ;
   assert ( plen <= ( int ) sizeof ( buf ) ) ;
   if ( send ( s , buf , plen , 0 ) != plen ) return 1 ;
   return 0 ;
}",545,-19.585500662835894,-0.03593669846391907
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) {
  char buf [ 2048 ] ;
  unsigned short * cmd = ( unsigned short * ) buf ;
  int plen ;
  struct in_addr * addr = & s_in -> sin_addr ;
  unsigned short * pid = ( unsigned short * ) data ;

  if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) {
    unsigned short * id = ( unsigned short * ) ( data + 5 ) ;
    int x = 2 + 4 + 2 ;
    * cmd = htons ( S_CMD_INET_CHECK ) ;
    memcpy ( cmd + 1 , addr , 4 ) ;
    memcpy ( cmd + 1 + 2 , id , 2 ) ;
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ;
    if ( send ( s , buf , x , 0 ) != x ) return 1 ;
    return 0 ;
  }

  // Perform input validation to ensure data is valid
  if (len < 2 || len > S_HELLO_LEN) {
    return 1;
  }

  * cmd ++ = htons ( S_CMD_PACKET ) ;
  * cmd ++ = * pid ;
  plen = len - 2 ;
  last_id = ntohs ( * pid ) ;
  if ( last_id > 20000 ) wrap = 1 ;
  if ( wrap && last_id < 100 ) {
    wrap = 0 ;
    memset ( ids , 0 , sizeof ( ids ) ) ;
  }
  printf ( ""Got packet %d %d"" , last_id , plen ) ;
  if ( is_dup ( last_id ) ) {
    printf ( "" (DUP)\\n"" ) ;
    return 0 ;
  }
  printf ( ""\\n"" ) ;
  * cmd ++ = htons ( plen ) ;
  memcpy ( cmd , data + 2 , plen ) ;
  plen += 2 + 2 + 2 ;
  assert ( plen <= ( int ) sizeof ( buf ) ) ;
  if ( send ( s , buf , plen , 0 ) != plen ) return 1 ;
  return 0 ;
}",561,-25.912467091958252,-0.04618978091258155
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) {
  char buf [ 2048 ] ;
  unsigned short * cmd = ( unsigned short * ) buf ;
  int plen ;
  struct in_addr * addr = & s_in -> sin_addr ;
  unsigned short * pid = ( unsigned short * ) data ;
  int max_len = S_HELLO_LEN;
  if ( len == max_len && memcmp ( data , ""sorbo"" , 5 ) == 0 ) {
    unsigned short * id = ( unsigned short * ) ( data + 5 ) ;
    int x = 2 + 4 + 2 ;
    * cmd = htons ( S_CMD_INET_CHECK ) ;
    memcpy ( cmd + 1 , addr , 4 ) ;
    memcpy ( cmd + 1 + 2 , id , 2 ) ;
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ;
    if ( send ( s , buf , x , 0 ) != x ) return 1 ;
    return 0 ;
  }
  if(len < S_HELLO_LEN){
    * cmd ++ = htons ( S_CMD_PACKET ) ;
    * cmd ++ = * pid ;
    plen = len - 2 ;
    last_id = ntohs ( * pid ) ;
    if ( last_id > 20000 ) wrap = 1 ;
    if ( wrap && last_id < 100 ) {
      wrap = 0 ;
      memset ( ids , 0 , sizeof ( ids ) ) ;
    }
    printf ( ""Got packet %d %d"" , last_id , plen ) ;
    if ( is_dup ( last_id ) ) {
      printf ( "" (DUP)\\n"" ) ;
      return 0 ;
    }
    printf ( ""\\n"" ) ;
    * cmd ++ = htons ( plen ) ;
    memcpy ( cmd , data + 2 , plen ) ;
    plen += 2 + 2 + 2 ;
    assert ( plen <= ( int ) sizeof ( buf ) ) ;
    if ( send ( s , buf , plen , 0 ) != plen ) return 1 ;
    return 0 ;
  }
}",551,-24.12418962196104,-0.04378255829756995
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
//Added an input validation test to check the length of the data
if (len <= 0) {
  return 1;
}
char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; 
//Added an input validation test to check if the data is equal to S_HELLO_LEN
if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
  unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; 
  } 
//Added an input validation test to check if the length is greater than 2
  if (len <= 2) {
    return 1;
  }
* cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; 
last_id = ntohs ( * pid ) ; 
//Added an input validation test to check if last_id is within appropriate range
if (last_id < 0 || last_id > 20000) {
  return 1;
}
if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; 
 }",593,-80.06701426692305,-0.1350202601465819
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } if (len < 2) { return 1; //Added input validation to check for valid packet length } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",470,-22.381386298283378,-0.047619970847411444
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
    char buf [ 2048 ] ; 
    unsigned short * cmd = ( unsigned short * ) buf ; 
    int plen ; 
    struct in_addr * addr = & s_in -> sin_addr ; 
    unsigned short * pid = ( unsigned short * ) data ; 
    if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
        unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
        int x = 2 + 4 + 2 ; 
        * cmd = htons ( S_CMD_INET_CHECK ) ; 
        memcpy ( cmd + 1 , addr , 4 ) ; 
        memcpy ( cmd + 1 + 2 , id , 2 ) ; 
        printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ;
        if ( send ( s , buf , x , 0 ) != x ) 
            return 1 ; 
        return 0 ; 
    }
    
    // Validate input
    if (len > S_HELLO_LEN && len < 2048) {
        *cmd++ = htons(S_CMD_PACKET);
        *cmd++ = *pid;
        plen = len - 2;
        last_id = ntohs(*pid);
        if (last_id > 20000)
            wrap = 1;
        if (wrap && last_id < 100) {
            wrap = 0;
            memset(ids, 0, sizeof(ids));
        }
        printf(""Got packet %d %d"", last_id, plen);
        if (is_dup(last_id)) {
            printf("" (DUP)\\n"");
            return 0;
        }
        printf(""\\n"");
        *cmd++ = htons(plen);
        memcpy(cmd, data + 2, plen);
        plen += 2 + 2 + 2;
        assert(plen <= (int)sizeof(buf));
        if (send(s, buf, plen, 0) != plen) 
            return 1; 
        return 0; 
    }
    else {
        printf(""Invalid input\n"");
        return 0;
    }
}",578,-43.89977984142379,-0.07595117619623494
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; // Validate length of data before processing  if ( len < S_HELLO_LEN || len > 2048 ) { return 1; } if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",480,-20.44108187146788,-0.04258558723222475
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; if (! validateId (id)) { return 1; } printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if (!validateId (last_id)) { return 1; } if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }

// Validation function
int validateId (unsigned short id) 
{ 
    if (id > 20000) 
        return 0; 
    return 1; 
}",519,-43.52457795374756,-0.08386238526733635
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; if (len < 6 || memcmp ( data , ""sorbo"" , 5 ) != 0 || len != S_HELLO_LEN ) { return 1; } unsigned short * pid = ( unsigned short * ) data ; unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; 
 * cmd ++ = htons ( S_CMD_PACKET ) ;* cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",458,-31.989186336744734,-0.0698453850147265
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
  char buf [ 2048 ] ; 
  unsigned short * cmd = ( unsigned short * ) buf ; 
  int plen ; 
  struct in_addr * addr = & s_in -> sin_addr ; 
  unsigned short * pid = ( unsigned short * ) data ; 
  if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
    unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
    int x = 2 + 4 + 2 ; 
    * cmd = htons ( S_CMD_INET_CHECK ) ; 
    memcpy ( cmd + 1 , addr , 4 ) ; 
    memcpy ( cmd + 1 + 2 , id , 2 ) ; 
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
    if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
    return 0 ; 
  } 
  // Added input validation
  if (len < 2) return -1; 
  * cmd ++ = htons ( S_CMD_PACKET ) ; 
  * cmd ++ = * pid ; 
  plen = len - 2 ; 
  last_id = ntohs ( * pid ) ; 
  if ( last_id > 20000 ) wrap = 1 ; 
  if ( wrap && last_id < 100 ) { 
    wrap = 0 ; 
    memset ( ids , 0 , sizeof ( ids ) ) ; 
  } 
  printf ( ""Got packet %d %d"" , last_id , plen ) ; 
  if ( is_dup ( last_id ) ) { 
    printf ( "" (DUP)\\n"" ) ; 
    return 0 ; 
  } 
  printf ( ""\\n"" ) ; 
  * cmd ++ = htons ( plen ) ; 
  memcpy ( cmd , data + 2 , plen ) ; 
  plen += 2 + 2 + 2 ; 
  assert ( plen <= ( int ) sizeof ( buf ) ) ; 
  if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
  return 0 ; 
}",578,-19.499160824535277,-0.033735572360787676
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; if (strlen(inet_ntoa( * addr)) > 5) { printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } else { printf(""Improper input detected!""); return 1; } } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",481,-29.957534305339554,-0.062281776102577034
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } if (len < 2 || len > S_PACKET_LEN) { return 1; //Added to fix input validation vulnerability } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",478,-23.921625023144916,-0.05004524063419438
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
    char buf [ 2048 ] ; 
    unsigned short * cmd = ( unsigned short * ) buf ; 
    int plen ; 
    struct in_addr * addr = & s_in -> sin_addr ; 
    unsigned short * pid = ( unsigned short * ) data ; 
    if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
        unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
        int x = 2 + 4 + 2 ; 
        * cmd = htons ( S_CMD_INET_CHECK ) ; 
        memcpy ( cmd + 1 , addr , 4 ) ; 
        memcpy ( cmd + 1 + 2 , id , 2 ) ; 
        printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
        if ( send ( s , buf , x , 0 ) != x ) 
            return 1 ; 
        return 0 ; 
    } 
   
   if (len == S_HELLO_LEN + 2 && (memcmp(data, ""sorbo"", 5) == 0 || memcmp(data, ""SORBO"", 5) == 0)) {
        unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
        int x = 2 + 4 + 2 ; 
        * cmd = htons ( S_CMD_INET_CHECK ) ; 
        memcpy ( cmd + 1 , addr , 4 ) ; 
        memcpy ( cmd + 1 + 2 , id , 2 ) ; 
        printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
        if ( send ( s , buf , x , 0 ) != x ) 
            return 1 ; 
        return 0 ; 
   }
   
    * cmd ++ = htons ( S_CMD_PACKET ) ; 
    * cmd ++ = * pid ; 
    plen = len - 2 ; 
    last_id = ntohs ( * pid ) ; 
    if ( last_id > 20000 ) 
        wrap = 1 ; 
    if ( wrap && last_id < 100 ) { 
        wrap = 0 ; 
        memset ( ids , 0 , sizeof ( ids ) ) ; 
    } 
    printf ( ""Got packet %d %d"" , last_id , plen ) ; 
    if ( is_dup ( last_id ) ) { 
        printf ( "" (DUP)\\n"" ) ; 
        return 0 ; 
    } 
    printf ( ""\\n"" ) ; 
    * cmd ++ = htons ( plen ) ; 
    memcpy ( cmd , data + 2 , plen ) ; 
    plen += 2 + 2 + 2 ; 
    assert ( plen <= ( int ) sizeof ( buf ) ) ; 
    if ( send ( s , buf , plen , 0 ) != plen ) 
        return 1 ; 
    return 0 ; 
}",777,-40.90447074851198,-0.05264410649744142
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) {  
  char buf [ 2048 ] ; 
  unsigned short * cmd = ( unsigned short * ) buf ; 
  int plen ; 
  struct in_addr * addr = & s_in -> sin_addr ; 
  unsigned short * pid = ( unsigned short * ) data ;
  
  //Ensure that the length of the input is valid
  if ( len < S_HELLO_LEN || len > 2048 ) {
    return 0;
  }
  
  if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
    unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
    int x = 2 + 4 + 2 ; 
    * cmd = htons ( S_CMD_INET_CHECK ) ; 
    memcpy ( cmd + 1 , addr , 4 ) ; 
    memcpy ( cmd + 1 + 2 , id , 2 ) ; 
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
    if ( send ( s , buf , x , 0 ) != x ) 
      return 1 ; 
    return 0 ; 
  } 
  * cmd ++ = htons ( S_CMD_PACKET ) ; 
  * cmd ++ = * pid ; 
  plen = len - 2 ; 
  last_id = ntohs ( * pid ) ; 
  if ( last_id > 20000 ) 
    wrap = 1 ; 
  if ( wrap && last_id < 100 ) { 
    wrap = 0 ; 
    memset ( ids , 0 , sizeof ( ids ) ) ; 
  } 
  printf ( ""Got packet %d %d"" , last_id , plen ) ; 
  if ( is_dup ( last_id ) ) { 
    printf ( "" (DUP)\\n"" ) ; 
    return 0 ; 
  } 
  printf ( ""\\n"" ) ; 
  * cmd ++ = htons ( plen ) ; 
  memcpy ( cmd , data + 2 , plen ) ; 
  plen += 2 + 2 + 2 ; 
  assert ( plen <= ( int ) sizeof ( buf ) ) ; 
  if ( send ( s , buf , plen , 0 ) != plen ) 
    return 1 ; 
  return 0 ; 
}",612,-37.26115877750895,-0.06088424636847868
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) {
  char buf [ 2048 ] ; 
  unsigned short * cmd = ( unsigned short * ) buf ; 
  int plen ; 
  struct in_addr * addr = & s_in -> sin_addr ; 
  unsigned short * pid = ( unsigned short * ) data ; 

  //Added input validation
  if (len < S_HELLO_LEN || memcmp ( data , ""sorbo"" , 5 ) != 0 ){
    return -1;
  }

  if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
    unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
    int x = 2 + 4 + 2 ; 
    * cmd = htons ( S_CMD_INET_CHECK ) ; 
    memcpy ( cmd + 1 , addr , 4 ) ; 
    memcpy ( cmd + 1 + 2 , id , 2 ) ; 
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
    if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
    return 0 ; 
  } 
  * cmd ++ = htons ( S_CMD_PACKET ) ; 
  * cmd ++ = * pid ; 
  plen = len - 2 ; 
  last_id = ntohs ( * pid ) ; 
  if ( last_id > 20000 ) wrap = 1 ; 
  if ( wrap && last_id < 100 ) { 
    wrap = 0 ; 
    memset ( ids , 0 , sizeof ( ids ) ) ; 
  } 
  printf ( ""Got packet %d %d"" , last_id , plen ) ; 
  if ( is_dup ( last_id ) ) { 
    printf ( "" (DUP)\\n"" ) ; 
    return 0 ; 
  } 
  printf ( ""\\n"" ) ; 
  * cmd ++ = htons ( plen ) ; 
  memcpy ( cmd , data + 2 , plen ) ; 
  plen += 2 + 2 + 2 ; 
  assert ( plen <= ( int ) sizeof ( buf ) ) ; 
  if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
  return 0 ; 
}",605,-22.47158592378817,-0.03714311722940193
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; 
if ( len != S_HELLO_LEN || memcmp ( data , ""sorbo"" , 5 ) != 0 ) { 
    return -1; 
} 
unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; 

* cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",465,-15.384085424702654,-0.033084054676779905
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; 

//Add input validation
if (len < S_HELLO_LEN) 
{
    return 0;
}

if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",482,-19.599577223912227,-0.04066302328612496
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; // check if len is valid if ( len < S_HELLO_LEN ) { return 1 ; } unsigned short * pid = ( unsigned short * ) data ; // Check if data is valid if ( memcmp ( data , ""sorbo"" , 5 ) != 0 ) { return 1 ; } if ( len == S_HELLO_LEN ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; // Check if buffer is valid if ( plen > ( int ) sizeof ( buf ) ) { return 1 ; } if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",496,-34.37875438155351,-0.06931200480151918
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; 

// Added validation
if (len < S_HELLO_LEN) {
    return 0;
}

if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; 

// Added validation
if (len < 2) {
    return 0;
}

plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; } 
",504,-26.197245531140865,-0.05197866176813664
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } //add input validation  if (len > 0 && len < S_HELLO_LEN) { * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; } else { return 1; } }",479,-23.430718764192175,-0.04891590556198784
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; //Validate input if (!(len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0)){ return 1; } unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; //Validate input if (!(last_id > 0 && last_id < 20000)){ return 1; } if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",483,-22.732764719742036,-0.04706576546530442
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; 
//Validate the length of the data
if (len > S_HELLO_LEN || memcmp ( data , ""sorbo"" , 5 ) != 0)
    return 1;

unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; 

* cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ;

//Validate the last_id parameter
if (last_id < 0 || last_id > 20000)
    return 1;

if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ;
}",502,-44.69020974868506,-0.08902432220853597
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } //added input validation if (len < 2 || len > 2048) { return -1; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",469,-14.932314569809598,-0.03183862381622515
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
  char buf [ 2048 ] ; 
  unsigned short * cmd = ( unsigned short * ) buf ; 
  int plen ; 
  struct in_addr * addr = & s_in -> sin_addr ; 
  unsigned short * pid = ( unsigned short * ) data ; 
  if ( len != S_HELLO_LEN || memcmp ( data , ""sorbo"" , 5 ) != 0 ) {
    return 1;
  }
  unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
  int x = 2 + 4 + 2 ; 
  * cmd = htons ( S_CMD_INET_CHECK ) ; 
  memcpy ( cmd + 1 , addr , 4 ) ; 
  memcpy ( cmd + 1 + 2 , id , 2 ) ; 
  printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
  if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
  return 0 ; 
} 
* cmd ++ = htons ( S_CMD_PACKET ) ; 
* cmd ++ = * pid ; 
plen = len - 2 ; 
last_id = ntohs ( * pid ) ; 
if ( last_id > 20000 || last_id < 0 ) {
  return 1;
}
if ( last_id > 20000 ) wrap = 1 ; 
if ( wrap && last_id < 100 ) { 
  wrap = 0 ; 
  memset ( ids , 0 , sizeof ( ids ) ) ; 
} 
printf ( ""Got packet %d %d"" , last_id , plen ) ; 
if ( is_dup ( last_id ) ) { 
  printf ( "" (DUP)\\n"" ) ; 
  return 0 ; 
} 
printf ( ""\\n"" ) ; 
* cmd ++ = htons ( plen ) ; 
memcpy ( cmd , data + 2 , plen ) ; 
plen += 2 + 2 + 2 ; 
assert ( plen <= ( int ) sizeof ( buf ) ) ; 
if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
return 0 ; 
}",572,-15.87661348631812,-0.02775631728377294
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) {
  char buf [ 2048 ] ; 
  unsigned short * cmd = ( unsigned short * ) buf ; 
  int plen ; 
  struct in_addr * addr = & s_in -> sin_addr ; 
  unsigned short * pid = ( unsigned short * ) data ;
  //Validate the length of the data
  if (len < S_HELLO_LEN) {
    return 1;
  }
  //Validate the content of the data
  if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
    unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
    int x = 2 + 4 + 2 ; 
    * cmd = htons ( S_CMD_INET_CHECK ) ; 
    memcpy ( cmd + 1 , addr , 4 ) ; 
    memcpy ( cmd + 1 + 2 , id , 2 ) ; 
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
    if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
    return 0 ; 
  } 
  * cmd ++ = htons ( S_CMD_PACKET ) ; 
  * cmd ++ = * pid ; 
  plen = len - 2 ; 
  last_id = ntohs ( * pid ) ; 
  if ( last_id > 20000 ) wrap = 1 ; 
  if ( wrap && last_id < 100 ) { 
    wrap = 0 ; 
    memset ( ids , 0 , sizeof ( ids ) ) ; 
  } 
  printf ( ""Got packet %d %d"" , last_id , plen ) ; 
  //Validate the last_id
  if ( last_id < 0 || last_id > 20000 ) {
    return 1;
  }
  if ( is_dup ( last_id ) ) { 
    printf ( "" (DUP)\\n"" ) ; 
    return 0 ; 
  } 
  printf ( ""\\n"" ) ; 
  * cmd ++ = htons ( plen ) ; 
  memcpy ( cmd , data + 2 , plen ) ; 
  plen += 2 + 2 + 2 ; 
  assert ( plen <= ( int ) sizeof ( buf ) ) ; 
  if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
  return 0 ; 
}",636,-34.838906647362485,-0.054778155105915854
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; // Validate input length if (len < S_HELLO_LEN || len >= sizeof(buf)) { return 1; } if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",478,-21.377963975461427,-0.04472377400724148
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; 
if (len < S_HELLO_LEN || memcmp ( data , ""sorbo"" , 5 ) != 0 ){ 
	return 0;
}
else{ 
	unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } 
	
* cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",469,-26.574725379069267,-0.056662527460702064
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ;

if (len < S_HELLO_LEN || memcmp ( data , ""sorbo"" , 5 ) != 0) {
    return 1;
}

unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ;

if (len < 2) {
    return 1;
}

* cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",477,-17.138527681487577,-0.03592982742450226
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
  char buf [ 2048 ] ; 
  unsigned short * cmd = ( unsigned short * ) buf ; 
  int plen ; 
  struct in_addr * addr = & s_in -> sin_addr ; 
  unsigned short * pid = ( unsigned short * ) data ; 
  
  if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) 
  { 
    unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
    int x = 2 + 4 + 2 ; 
    * cmd = htons ( S_CMD_INET_CHECK ) ; 
    memcpy ( cmd + 1 , addr , 4 ) ; 
    memcpy ( cmd + 1 + 2 , id , 2 ) ; 
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
    if ( send ( s , buf , x , 0 ) != x ) 
      return 1 ; 
    return 0 ; 
  } 
  * cmd ++ = htons ( S_CMD_PACKET ) ; 

  // Added input validation
  if (len < 2) return 0;
  * cmd ++ = * pid ; 
  plen = len - 2 ; 
  last_id = ntohs ( * pid ) ; 
  if ( last_id > 20000 ) wrap = 1 ; 
  if ( wrap && last_id < 100 ) { 
    wrap = 0 ; 
    memset ( ids , 0 , sizeof ( ids ) ) ; 
  } 
  printf ( ""Got packet %d %d"" , last_id , plen ) ; 
  if ( is_dup ( last_id ) ) { 
    printf ( "" (DUP)\\n"" ) ; 
    return 0 ; 
  } 
  printf ( ""\\n"" ) ; 
  * cmd ++ = htons ( plen ) ; 
  memcpy ( cmd , data + 2 , plen ) ; 
  plen += 2 + 2 + 2 ; 
  assert ( plen <= ( int ) sizeof ( buf ) ) ; 
  if ( send ( s , buf , plen , 0 ) != plen ) 
    return 1 ; 
  return 0 ; 
}",587,-30.510751701755456,-0.051977430497028035
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
  char buf [ 2048 ] ; 
  unsigned short * cmd = ( unsigned short * ) buf ; 
  int plen ; 
  struct in_addr * addr = & s_in -> sin_addr ; 
  unsigned short * pid = ( unsigned short * ) data ; 
  if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
    unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
    int x = 2 + 4 + 2 ; 
    * cmd = htons ( S_CMD_INET_CHECK ) ; 
    memcpy ( cmd + 1 , addr , 4 ) ; 
    memcpy ( cmd + 1 + 2 , id , 2 ) ; 
    if (send(s, buf, x, 0) != x) return 1 ; 
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
    return 0 ; 
  } 
  if (len < 2) return 1; 
  * cmd ++ = htons ( S_CMD_PACKET ) ; 
  * cmd ++ = * pid ; 
  plen = len - 2 ; 
  last_id = ntohs ( * pid ) ; 
  if ( last_id > 20000 ) wrap = 1 ; 
  if ( wrap && last_id < 100 ) { 
    wrap = 0 ; 
    memset ( ids , 0 , sizeof ( ids ) ) ; 
  } 
  printf ( ""Got packet %d %d"" , last_id , plen ) ; 
  if ( is_dup ( last_id ) ) { 
    printf ( "" (DUP)\\n"" ) ; 
    return 0 ; 
  } 
  printf ( ""\\n"" ) ; 
  * cmd ++ = htons ( plen ) ; 
  memcpy ( cmd , data + 2 , plen ) ; 
  plen += 2 + 2 + 2 ; 
  assert ( plen <= ( int ) sizeof ( buf ) ) ; 
  if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
  return 0 ; 
}",571,-22.243443999569443,-0.03895524343182039
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) {
  char buf [ 2048 ] ;
  unsigned short * cmd = ( unsigned short * ) buf ;
  int plen ;
  struct in_addr * addr = & s_in -> sin_addr ;
  unsigned short * pid = ( unsigned short * ) data ;

  //Validate the length of the data
  if (len < S_HELLO_LEN || len > 2048) {
	  return 1;
  }

  if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) {
    unsigned short * id = ( unsigned short * ) ( data + 5 ) ;
    int x = 2 + 4 + 2 ;
    * cmd = htons ( S_CMD_INET_CHECK ) ;
    memcpy ( cmd + 1 , addr , 4 ) ;
    memcpy ( cmd + 1 + 2 , id , 2 ) ;
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ;
    if ( send ( s , buf , x , 0 ) != x ) return 1 ;
    return 0 ;
  }
  * cmd ++ = htons ( S_CMD_PACKET ) ;
  * cmd ++ = * pid ;
  plen = len - 2 ;
  last_id = ntohs ( * pid ) ;
  //Validate the ID
  if ( last_id > 20000 || last_id < 100){
	  return 1;
  }
  if ( last_id > 20000 ) wrap = 1 ;
  if ( wrap && last_id < 100 ) {
    wrap = 0 ;
    memset ( ids , 0 , sizeof ( ids ) ) ;
  }
  printf ( ""Got packet %d %d"" , last_id , plen ) ;
  if ( is_dup ( last_id ) ) {
    printf ( "" (DUP)\\n"" ) ;
    return 0 ;
  }
  printf ( ""\\n"" ) ;
  * cmd ++ = htons ( plen ) ;
  memcpy ( cmd , data + 2 , plen ) ;
  plen += 2 + 2 + 2 ;
  assert ( plen <= ( int ) sizeof ( buf ) ) ;
  if ( send ( s , buf , plen , 0 ) != plen ) return 1 ;
  return 0 ;
}",594,-37.82127520739936,-0.06367218048383731
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","

int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
    char buf [ 2048 ] ; 
    unsigned short * cmd = ( unsigned short * ) buf ; 
    int plen ; 
    struct in_addr * addr = & s_in -> sin_addr ; 
    unsigned short * pid = ( unsigned short * ) data ;
    
    //Validate user input
    if (len < 0 || len > 2048) return 1;
    if (memcmp ( data , ""sorbo"" , 5 ) != 0) return 1;
    
    if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
        unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
        int x = 2 + 4 + 2 ; 
        * cmd = htons ( S_CMD_INET_CHECK ) ; 
        memcpy ( cmd + 1 , addr , 4 ) ; 
        memcpy ( cmd + 1 + 2 , id , 2 ) ; 
        printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
        if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
        return 0 ; 
    } 
    * cmd ++ = htons ( S_CMD_PACKET ) ; 
    * cmd ++ = * pid ; 
    plen = len - 2 ; 
    last_id = ntohs ( * pid ) ; 
    if ( last_id > 20000 ) wrap = 1 ; 
    if ( wrap && last_id < 100 ) { 
        wrap = 0 ; 
        memset ( ids , 0 , sizeof ( ids ) ) ; 
    } 
    printf ( ""Got packet %d %d"" , last_id , plen ) ; 
    if ( is_dup ( last_id ) ) { 
        printf ( "" (DUP)\\n"" ) ; 
        return 0 ; 
    } 
    printf ( ""\\n"" ) ; 
    * cmd ++ = htons ( plen ) ; 
    memcpy ( cmd , data + 2 , plen ) ; 
    plen += 2 + 2 + 2 ; 
    assert ( plen <= ( int ) sizeof ( buf ) ) ; 
    if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
    return 0 ; 
}",608,-27.356998332975852,-0.04499506304765765
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
  char buf [ 2048 ] ; 
  unsigned short * cmd = ( unsigned short * ) buf ; 
  int plen ; 
  struct in_addr * addr = & s_in -> sin_addr ; 
  unsigned short * pid = ( unsigned short * ) data ; 
  if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
    unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
    int x = 2 + 4 + 2 ; 
    * cmd = htons ( S_CMD_INET_CHECK ) ; 
    memcpy ( cmd + 1 , addr , 4 ) ; 
    memcpy ( cmd + 1 + 2 , id , 2 ) ; 
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
    if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
    return 0 ; 
  } 
  
  //Added code to validate input
  if (len < 2 || !data) {
    return 1;
  }
  
  * cmd ++ = htons ( S_CMD_PACKET ) ; 
  * cmd ++ = * pid ; 
  plen = len - 2 ; 
  last_id = ntohs ( * pid ) ; 
  if ( last_id > 20000 ) wrap = 1 ; 
  if ( wrap && last_id < 100 ) { 
    wrap = 0 ; 
    memset ( ids , 0 , sizeof ( ids ) ) ; 
  } 
  printf ( ""Got packet %d %d"" , last_id , plen ) ; 
  if ( is_dup ( last_id ) ) { 
    printf ( "" (DUP)\\n"" ) ; 
    return 0 ; 
  } 
  printf ( ""\\n"" ) ; 
  * cmd ++ = htons ( plen ) ; 
  memcpy ( cmd , data + 2 , plen ) ; 
  plen += 2 + 2 + 2 ; 
  assert ( plen <= ( int ) sizeof ( buf ) ) ; 
  if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
  return 0 ; 
}",591,-23.75283109409549,-0.04019091555684516
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) {
 char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ;
 int plen ;
 struct in_addr * addr = & s_in -> sin_addr ;
 unsigned short * pid = ( unsigned short * ) data ;
 
 // validate length of data
 if ( len < S_HELLO_LEN || len > 2048 ) {
 return 1;
 }
 
 // validate input data
 if ( memcmp ( data , ""sorbo"" , 5 ) == 0 ) {
 unsigned short * id = ( unsigned short * ) ( data + 5 ) ;
 int x = 2 + 4 + 2 ;
 * cmd = htons ( S_CMD_INET_CHECK ) ;
 memcpy ( cmd + 1 , addr , 4 ) ;
 memcpy ( cmd + 1 + 2 , id , 2 ) ;
 printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ;
 if ( send ( s , buf , x , 0 ) != x ) return 1 ;
 return 0 ;
 }
 
 * cmd ++ = htons ( S_CMD_PACKET ) ;
 * cmd ++ = * pid ;
 plen = len - 2 ;
 last_id = ntohs ( * pid ) ;
 if ( last_id > 20000 ) wrap = 1 ;
 if ( wrap && last_id < 100 ) {
 wrap = 0 ;
 memset ( ids , 0 , sizeof ( ids ) ) ;
 }
 printf ( ""Got packet %d %d"" , last_id , plen ) ;
 if ( is_dup ( last_id ) ) {
 printf ( "" (DUP)\\n"" ) ;
 return 0 ;
 }
 printf ( ""\\n"" ) ;
 * cmd ++ = htons ( plen ) ;
 memcpy ( cmd , data + 2 , plen ) ;
 plen += 2 + 2 + 2 ;
 assert ( plen <= ( int ) sizeof ( buf ) ) ;
 if ( send ( s , buf , plen , 0 ) != plen ) return 1 ;
 return 0 ;
}",516,-37.182592736254094,-0.07205928824855444
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len != S_HELLO_LEN || memcmp ( data , ""sorbo"" , 5 ) != 0 ) { return 1; } unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",453,-5.942621486388564,-0.013118369727127073
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; if ( validate_input(data + 5) ) { printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } else { return 1; } } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } if ( validate_input(pid) ) { printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; } else { return 1; } }

The code has been fixed by adding input validation checks on the incoming data. The code now checks if the data is valid before processing it by calling a validate_input function. If the data is invalid, the code will return an error code. This will ensure that the code is only processing valid data.",548,-72.13414736666019,-0.131631655778577
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { if (len > S_HELLO_LEN)
  return 1; 
unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } if (plen > 2048)
  return 1; 
printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",483,-23.94231454794241,-0.049570009416029834
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; if (ntohs(*id) > 0 && ntohs(*id) < 100000) {
    printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
    if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
    return 0 ; 
}
else {
    return 0;
}
}
* cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",495,-30.30652923846479,-0.06122531159285816
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
	
	char buf [ 2048 ] ; 
	unsigned short * cmd = ( unsigned short * ) buf ; 
	int plen ; 
	struct in_addr * addr = & s_in -> sin_addr ; 
	unsigned short * pid = ( unsigned short * ) data ; 
	
	//Validate input length
	if ( len != S_HELLO_LEN || memcmp ( data , ""sorbo"" , 5 ) != 0 ) {
		return 1;
	}
	
	unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
	int x = 2 + 4 + 2 ; 
	* cmd = htons ( S_CMD_INET_CHECK ) ; 
	memcpy ( cmd + 1 , addr , 4 ) ; 
	memcpy ( cmd + 1 + 2 , id , 2 ) ; 
	printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
	if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
	return 0 ; 
} 

* cmd ++ = htons ( S_CMD_PACKET ) ; 
* cmd ++ = * pid ; 
plen = len - 2 ; 
last_id = ntohs ( * pid ) ; 
if ( last_id > 20000 ) wrap = 1 ; 
if ( wrap && last_id < 100 ) { 
	wrap = 0 ; 
	memset ( ids , 0 , sizeof ( ids ) ) ; 
} 

//Validate input length
if (plen > sizeof(buf)) {
	return 1;
}

printf ( ""Got packet %d %d"" , last_id , plen ) ; 
if ( is_dup ( last_id ) ) { 
	printf ( "" (DUP)\\n"" ) ; 
	return 0 ; 
} 
printf ( ""\\n"" ) ; 
* cmd ++ = htons ( plen ) ; 
memcpy ( cmd , data + 2 , plen ) ; 
plen += 2 + 2 + 2 ; 

if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
return 0 ; 
}",574,-37.856713186704006,-0.06595246199774217
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
    char buf [ 2048 ] ; 
    unsigned short * cmd = ( unsigned short * ) buf ; 
    int plen ; 
    struct in_addr * addr = & s_in -> sin_addr ; 
    unsigned short * pid = ( unsigned short * ) data ; 
    
    if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
        unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
        int x = 2 + 4 + 2 ; 
        * cmd = htons ( S_CMD_INET_CHECK ) ; 
        memcpy ( cmd + 1 , addr , 4 ) ; 
        memcpy ( cmd + 1 + 2 , id , 2 ) ; 
        printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
        if ( send ( s , buf , x , 0 ) != x ) 
            return 1 ; 
        return 0 ; 
    } 
    
    if(len < S_HELLO_LEN){
        return 0;
    }
    
    * cmd ++ = htons ( S_CMD_PACKET ) ; 
    * cmd ++ = * pid ; 
    plen = len - 2 ; 
    last_id = ntohs ( * pid ) ; 
    if ( last_id > 20000 ) 
        wrap = 1 ; 
    if ( wrap && last_id < 100 ) { 
        wrap = 0 ; 
        memset ( ids , 0 , sizeof ( ids ) ) ; 
    } 
    printf ( ""Got packet %d %d"" , last_id , plen ) ; 
    if ( is_dup ( last_id ) ) { 
        printf ( "" (DUP)\\n"" ) ; 
        return 0 ; 
    } 
    printf ( ""\\n"" ) ; 
    * cmd ++ = htons ( plen ) ; 
    memcpy ( cmd , data + 2 , plen ) ; 
    plen += 2 + 2 + 2 ; 
    assert ( plen <= ( int ) sizeof ( buf ) ) ; 
    if ( send ( s , buf , plen , 0 ) != plen ) 
        return 1 ; 
    return 0 ; 
}",597,-17.499530414905788,-0.029312446256123597
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) {
 char buf [ 2048 ] ;
 unsigned short * cmd = ( unsigned short * ) buf ;
 int plen ;
 struct in_addr * addr = & s_in -> sin_addr ;
 unsigned short * pid = ( unsigned short * ) data ;

 if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) {
  unsigned short * id = ( unsigned short * ) ( data + 5 ) ;
  int x = 2 + 4 + 2 ;
  * cmd = htons ( S_CMD_INET_CHECK ) ;
  memcpy ( cmd + 1 , addr , 4 ) ;
  memcpy ( cmd + 1 + 2 , id , 2 ) ;
  printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ;
  if ( send ( s , buf , x , 0 ) != x ) return 1 ;
  return 0 ;
 }

// Validate len and add sanitization
 if(len >= S_HELLO_LEN && len <= sizeof(buf)) {
  * cmd ++ = htons ( S_CMD_PACKET ) ;
  * cmd ++ = * pid ;
  plen = len - 2 ;
  last_id = ntohs ( * pid ) ;
  if ( last_id > 20000 ) wrap = 1 ;
  if ( wrap && last_id < 100 ) {
   wrap = 0 ;
   memset ( ids , 0 , sizeof ( ids ) ) ;
  }
  printf ( ""Got packet %d %d"" , last_id , plen ) ;
  if ( is_dup ( last_id ) ) {
   printf ( "" (DUP)\\n"" ) ;
   return 0 ;
  }
  printf ( ""\\n"" ) ;
  * cmd ++ = htons ( plen ) ;
  memcpy ( cmd , data + 2 , plen ) ;
  plen += 2 + 2 + 2 ;
  assert ( plen <= ( int ) sizeof ( buf ) ) ;
  if ( send ( s , buf , plen , 0 ) != plen ) return 1 ;
  return 0 ;
 }
 else {
  return -1;
 }
}",560,-46.31101869947325,-0.0826982476776308
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { 
    char buf [ 2048 ] ; 
    unsigned short * cmd = ( unsigned short * ) buf ; 
    int plen ; 
    struct in_addr * addr = & s_in -> sin_addr ; 
    unsigned short * pid = ( unsigned short * ) data ;
    if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
        unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
        int x = 2 + 4 + 2 ; 
        * cmd = htons ( S_CMD_INET_CHECK ) ; 
        memcpy ( cmd + 1 , addr , 4 ) ; 
        memcpy ( cmd + 1 + 2 , id , 2 ) ;
        if(validateInput(id, data)){
            printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
            if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
            return 0 ; 
        }
    } 
    * cmd ++ = htons ( S_CMD_PACKET ) ; 
    * cmd ++ = * pid ; 
    plen = len - 2 ; 
    last_id = ntohs ( * pid ) ; 
    if ( last_id > 20000 ) wrap = 1 ; 
    if ( wrap && last_id < 100 ) { 
        wrap = 0 ; 
        memset ( ids , 0 , sizeof ( ids ) ) ; 
    } 
    printf ( ""Got packet %d %d"" , last_id , plen ) ; 
    if ( is_dup ( last_id ) ) { 
        printf ( "" (DUP)\\n"" ) ; 
        return 0 ; 
    } 
    printf ( ""\\n"" ) ; 
    * cmd ++ = htons ( plen ) ; 
    if(validateInput(pid, data)){
        memcpy ( cmd , data + 2 , plen ) ; 
        plen += 2 + 2 + 2 ; 
        assert ( plen <= ( int ) sizeof ( buf ) ) ; 
        if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
        return 0 ; 
    } else {
        return 1;
    }
    
}

bool validateInput(unsigned short * input, unsigned char * data){
    int inputLen = sizeof(input)/sizeof(input[0]);
    int dataLen = sizeof(data)/sizeof(data[0]);
    if(inputLen > dataLen){
        return false;
    }
    return true;
}",676,-57.59409935775074,-0.08519837183099223
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && strncmp((char *)data, ""sorbo"", 5) == 0) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; // Added input validation if (plen > 2048) { printf(""Improper input length""); return -1; } if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",475,-34.24843791534463,-0.07210197455862027
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; if (plen > 2048) { // Added input validation printf(""Length too long, reject packet.\n""); return 1; } last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }",477,-38.87429216441567,-0.08149746784992803
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got packet %d %d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "" (DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
Fixed code:","
int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) {
    //Validate input correctly
    if(len <= 0 || len > 2048 || data == NULL || s_in == NULL){
        return 1;
    }
    
    char buf [ 2048 ] ; 
    unsigned short * cmd = ( unsigned short * ) buf ; 
    int plen ; 
    struct in_addr * addr = & s_in -> sin_addr ; 
    unsigned short * pid = ( unsigned short * ) data ; 
    if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { 
        unsigned short * id = ( unsigned short * ) ( data + 5 ) ; 
        int x = 2 + 4 + 2 ; 
        * cmd = htons ( S_CMD_INET_CHECK ) ; 
        memcpy ( cmd + 1 , addr , 4 ) ; 
        memcpy ( cmd + 1 + 2 , id , 2 ) ; 
        printf ( ""Inet check by %s %d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; 
        if ( send ( s , buf , x , 0 ) != x ) return 1 ; 
        return 0 ; 
    } 
    * cmd ++ = htons ( S_CMD_PACKET ) ; 
    * cmd ++ = * pid ; 
    plen = len - 2 ; 
    last_id = ntohs ( * pid ) ; 
    if ( last_id > 20000 ) wrap = 1 ; 
    if ( wrap && last_id < 100 ) { 
        wrap = 0 ; 
        memset ( ids , 0 , sizeof ( ids ) ) ; 
    } 
    printf ( ""Got packet %d %d"" , last_id , plen ) ; 
    if ( is_dup ( last_id ) ) { 
        printf ( "" (DUP)\\n"" ) ; 
        return 0 ; 
    } 
    printf ( ""\\n"" ) ; 
    * cmd ++ = htons ( plen ) ; 
    memcpy ( cmd , data + 2 , plen ) ; 
    plen += 2 + 2 + 2 ; 
    assert ( plen <= ( int ) sizeof ( buf ) ) ; 
    if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; 
    return 0 ; 
}",597,-35.30676668994272,-0.05914031271347189
