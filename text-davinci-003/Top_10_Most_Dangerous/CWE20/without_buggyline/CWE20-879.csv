Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; // Added check to validate input if (frametype < ROSE_CALL_REQUEST || frametype > ROSE_RESET_CONFIRMATION) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ); return; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",905,-19.511116943662866,-0.021559245241616426
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) {
    struct rose_sock * rose = rose_sk ( sk ) ;
    struct sk_buff * skb ;
    unsigned char * dptr ;
    unsigned char lci1 , lci2 ;
    char buffer [ 100 ] ;
    int len , faclen = 0 ;
    len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ;
    // Verify that the input is valid before proceeding
    if (frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST &&
        frametype != ROSE_RESET_REQUEST && frametype != ROSE_RR && frametype != ROSE_RNR && frametype != ROSE_CLEAR_CONFIRMATION 
        && frametype != ROSE_RESET_CONFIRMATION) {
        printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\n"" , frametype ) ;
        return;
    }
    switch ( frametype ) {
        case ROSE_CALL_REQUEST :
            len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ;
            faclen = rose_create_facilities ( buffer , rose ) ;
            len += faclen ;
            break ;
        case ROSE_CALL_ACCEPTED :
        case ROSE_CLEAR_REQUEST :
        case ROSE_RESET_REQUEST :
            len += 2 ;
            break ;
    }
    if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) 
        return ;
    skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ;
    dptr = skb_put ( skb , skb_tailroom ( skb ) ) ;
    lci1 = ( rose -> lci >> 8 ) & 0x0F ;
    lci2 = ( rose -> lci >> 0 ) & 0xFF ;
    switch ( frametype ) {
        case ROSE_CALL_REQUEST :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
            * dptr ++ = frametype ;
            * dptr ++ = 0xAA ;
            memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;
            dptr += ROSE_ADDR_LEN ;
            memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ;
            dptr += ROSE_ADDR_LEN ;
            memcpy ( dptr , buffer , faclen ) ;
            dptr += faclen ;
            break ;
        case ROSE_CALL_ACCEPTED :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
            * dptr ++ = frametype ;
            * dptr ++ = 0x00 ;
            * dptr ++ = 0 ;
            break ;
        case ROSE_CLEAR_REQUEST :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
            * dptr ++ = frametype ;
            * dptr ++ = rose -> cause ;
            * dptr ++ = rose -> diagnostic ;
            break ;
        case ROSE_RESET_REQUEST :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
            * dptr ++ = frametype ;
            * dptr ++ = ROSE_DTE_ORIGINATED ;
            * dptr ++ = 0 ;
            break ;
        case ROSE_RR :
        case ROSE_RNR :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
",1000,-37.98724873217081,-0.03798724873217081
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; 
//validate input to ensure an accepted frametype
if ( !( frametype == ROSE_CALL_REQUEST || frametype == ROSE_CALL_ACCEPTED || frametype == ROSE_CLEAR_REQUEST || 
frametype == ROSE_RESET_REQUEST || frametype == ROSE_RR || frametype == ROSE_RNR || frametype == ROSE_CLEAR_CONFIRMATION || 
frametype == ROSE_RESET_CONFIRMATION ) ) {
printk ( KERN_ERR “ROSE: rose_write_internal - invalid frametype %02X\\n” , frametype ) ;
return ;
}
len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",981,-46.66114283827966,-0.04756487547225246
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; if ( frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST && frametype != ROSE_RR && frametype != ROSE_RNR && frametype != ROSE_CLEAR_CONFIRMATION && frametype != ROSE_RESET_CONFIRMATION ) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",954,-4.870821628467781,-0.005105683048708366
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 

//Validate the Frame Type
if(frametype < ROSE_CALL_REQUEST && frametype > ROSE_RESET_CONFIRMATION) {
    printk(KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype );
    return;
}

switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",944,-28.173453009875544,-0.029844759544359688
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","

void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; // Check if the frametype is valid if (frametype < ROSE_CALL_REQUEST || frametype > ROSE_RESET_CONFIRMATION) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",890,-14.761534077692138,-0.016585993345721504
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; 

if (frametype == ROSE_CALL_REQUEST ||frametype == ROSE_CALL_ACCEPTED || frametype == ROSE_CLEAR_REQUEST || frametype == ROSE_RESET_REQUEST || frametype == ROSE_RR || frametype == ROSE_RNR || frametype == ROSE_CLEAR_CONFIRMATION || frametype == ROSE_RESET_CONFIRMATION ) { 
    len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ;  } } else {
   printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; 
   return;
}

rose_transmit_link ( skb , rose -> neighbour ) ; 
}",974,-40.649668298447466,-0.04173477238033621
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { 
	struct rose_sock * rose = rose_sk ( sk ) ; 
	struct sk_buff * skb ; 
	unsigned char * dptr ; 
	unsigned char lci1 , lci2 ; 
	char buffer [ 100 ] ; 
	int len , faclen = 0 ; 
	len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
	if (frametype < ROSE_CALL_REQUEST || frametype > ROSE_RESET_CONFIRMATION) {
		printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; 
		return;
	}
	switch ( frametype ) { 
	case ROSE_CALL_REQUEST : 
		len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
		faclen = rose_create_facilities ( buffer , rose ) ; 
		len += faclen ; 
		break ; 
	case ROSE_CALL_ACCEPTED : 
	case ROSE_CLEAR_REQUEST : 
	case ROSE_RESET_REQUEST : 
		len += 2 ; 
		break ; 
	} 
	if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; 
	skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
	dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
	lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
	lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
	switch ( frametype ) { 
	case ROSE_CALL_REQUEST : 
		* dptr ++ = ROSE_GFI | lci1 ; 
		* dptr ++ = lci2 ; 
		* dptr ++ = frametype ; 
		* dptr ++ = 0xAA ; 
		memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
		dptr += ROSE_ADDR_LEN ; 
		memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
		dptr += ROSE_ADDR_LEN ; 
		memcpy ( dptr , buffer , faclen ) ; 
		dptr += faclen ; 
		break ; 
	case ROSE_CALL_ACCEPTED : 
		* dptr ++ = ROSE_GFI | lci1 ; 
		* dptr ++ = lci2 ; 
		* dptr ++ = frametype ; 
		* dptr ++ = 0x00 ; 
		* dptr ++ = 0 ; 
		break ; 
	case ROSE_CLEAR_REQUEST : 
		* dptr ++ = ROSE_GFI | lci1 ; 
		* dptr ++ = lci2 ; 
		* dptr ++ = frametype ; 
		* dptr ++ = rose -> cause ; 
		* dptr ++ = rose -> diagnostic ; 
		break ; 
	case ROSE_RESET_REQUEST : 
		* dptr ++ = ROSE_GFI | lci1 ; 
		* dptr ++ = lci2 ; 
		* dptr ++ = frametype ; 
		* dptr ++ = ROSE_DTE_ORIGINATED ; 
		* dptr ++ = 0 ; 
		break ; 
	case ROSE_RR : 
	case ROSE_RNR : 
		* dptr ++ = ROSE_GFI | lci1 ; 
		*",1000,-16.973402212429267,-0.016973402212429267
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","

void rose_write_internal ( struct sock * sk , int frametype ) {
    struct rose_sock * rose = rose_sk ( sk ) ;
    struct sk_buff * skb ;
    unsigned char * dptr ;
    unsigned char lci1 , lci2 ;
    char buffer [ 100 ] ;
    int len , faclen = 0 ;
    len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ;

    // Adding input validation
    if(frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST && frametype != ROSE_RR && frametype != ROSE_RNR && frametype != ROSE_CLEAR_CONFIRMATION && frametype != ROSE_RESET_CONFIRMATION) {
        printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
        return ;
    }

    switch ( frametype ) {
    case ROSE_CALL_REQUEST :
        len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ;
        faclen = rose_create_facilities ( buffer , rose ) ;
        len += faclen ;
        break ;
    case ROSE_CALL_ACCEPTED :
    case ROSE_CLEAR_REQUEST :
    case ROSE_RESET_REQUEST :
        len += 2 ;
        break ;
    }
    if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ;
    skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ;
    dptr = skb_put ( skb , skb_tailroom ( skb ) ) ;
    lci1 = ( rose -> lci >> 8 ) & 0x0F ;
    lci2 = ( rose -> lci >> 0 ) & 0xFF ;
    switch ( frametype ) {
    case ROSE_CALL_REQUEST :
        * dptr ++ = ROSE_GFI | lci1 ;
        * dptr ++ = lci2 ;
        * dptr ++ = frametype ;
        * dptr ++ = 0xAA ;
        memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;
        dptr += ROSE_ADDR_LEN ;
        memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ;
        dptr += ROSE_ADDR_LEN ;
        memcpy ( dptr , buffer , faclen ) ;
        dptr += faclen ;
        break ;
    case ROSE_CALL_ACCEPTED :
        * dptr ++ = ROSE_GFI | lci1 ;
        * dptr ++ = lci2 ;
        * dptr ++ = frametype ;
        * dptr ++ = 0x00 ;
        * dptr ++ = 0 ;
        break ;
    case ROSE_CLEAR_REQUEST :
        * dptr ++ = ROSE_GFI | lci1 ;
        * dptr ++ = lci2 ;
        * dptr ++ = frametype ;
        * dptr ++ = rose -> cause ;
        * dptr ++ = rose -> diagnostic ;
        break ;
    case ROSE_RESET_REQUEST :
        * dptr ++ = ROSE_GFI | lci1 ;
        * dptr ++ = lci2 ;
        * dptr ++ = frametype ;
        * dptr ++ = ROSE_DTE_ORIGINATED ;
        * dptr ++ = 0 ;
        break ;
    case ROSE_RR :
    case ROSE_RNR :
        * dptr ++ = ROSE_GFI | lci1 ;
        * dptr ++ = lci2 ;
        * dptr = frametype ;
        *",1000,-27.17471957673334,-0.02717471957673334
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:"," 
void rose_write_internal(struct sock *sk, int frametype) {
    struct rose_sock *rose = rose_sk(sk);
    struct sk_buff *skb;
    unsigned char *dptr;
    unsigned char lci1, lci2;
    char buffer[100];
    int len, faclen = 0;
    len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1;
    switch (frametype) {
        case ROSE_CALL_REQUEST:
            len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN;
            faclen = rose_create_facilities(buffer, rose);
            len += faclen;
            break;
        case ROSE_CALL_ACCEPTED:
        case ROSE_CLEAR_REQUEST:
        case ROSE_RESET_REQUEST:
            len += 2;
            break;
        default:
            printk(KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\n"", frametype);
            return;
    }
    if ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)
        return;
    skb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1);
    dptr = skb_put(skb, skb_tailroom(skb));
    lci1 = (rose->lci >> 8) & 0x0F;
    lci2 = (rose->lci >> 0) & 0xFF;
    switch (frametype) {
        case ROSE_CALL_REQUEST:
            *dptr++ = ROSE_GFI | lci1;
            *dptr++ = lci2;
            *dptr++ = frametype;
            *dptr++ = 0xAA;
            memcpy(dptr, &rose->dest_addr, ROSE_ADDR_LEN);
            dptr += ROSE_ADDR_LEN;
            memcpy(dptr, &rose->source_addr, ROSE_ADDR_LEN);
            dptr += ROSE_ADDR_LEN;
            memcpy(dptr, buffer, faclen);
            dptr += faclen;
            break;
        case ROSE_CALL_ACCEPTED:
            *dptr++ = ROSE_GFI | lci1;
            *dptr++ = lci2;
            *dptr++ = frametype;
            *dptr++ = 0x00;
            *dptr++ = 0;
            break;
        case ROSE_CLEAR_REQUEST:
            *dptr++ = ROSE_GFI | lci1;
            *dptr++ = lci2;
            *dptr++ = frametype;
            *dptr++ = rose->cause;
            *dptr++ = rose->diagnostic;
            break;
        case ROSE_RESET_REQUEST:
            *dptr++ = ROSE_GFI | lci1;
            *dptr++ = lci2;
            *dptr++ = frametype;
            *dptr++ = ROSE_DTE_ORIGINATED;
            *dptr++ = 0;
            break;
        case ROSE_RR:
        case ROSE_RNR:
            *dptr++ = ROSE_GFI | lci1;
            *dptr++ = lci2;
            *dptr = frametype;
            *dptr++ |= (rose->vr << 5) & 0xE0;
            break;
        case ROSE_CLEAR_CONFIRMATION:
        case ROSE_RESET_CONFIRMATION:
            *dptr++ = ROSE_GFI | lci1;
            *dptr++ = lci2;
            *dptr++ = frametype;
            break;
    }
    rose_transmit_link(skb, rose->neighbour);
}",994,-14.593168757583399,-0.014681256295355532
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; 
if (frametype < ROSE_CALL_REQUEST || frametype > ROSE_RESET_CONFIRMATION) {
  printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
  return;
}

len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",889,-12.611316565709773,-0.014185957891687034
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { 
    struct rose_sock * rose = rose_sk ( sk ) ; 
    struct sk_buff * skb ; 
    unsigned char * dptr ; 
    unsigned char lci1 , lci2 ; 
    char buffer [ 100 ] ; 
    int len , faclen = 0 ; 
    len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
    if (frametype > ROSE_RESET_CONFIRMATION) { 
        printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; 
        return; 
    }
    switch ( frametype ) { 
        case ROSE_CALL_REQUEST : 
            len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
            faclen = rose_create_facilities ( buffer , rose ) ; 
            len += faclen ; 
            break ; 
        case ROSE_CALL_ACCEPTED : 
        case ROSE_CLEAR_REQUEST : 
        case ROSE_RESET_REQUEST : 
            len += 2 ; 
            break ; 
    } 
    if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) 
        return ; 
    skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
    dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
    lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
    lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
    switch ( frametype ) { 
        case ROSE_CALL_REQUEST : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = 0xAA ; 
            memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
            dptr += ROSE_ADDR_LEN ; 
            memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
            dptr += ROSE_ADDR_LEN ; 
            memcpy ( dptr , buffer , faclen ) ; 
            dptr += faclen ; 
            break ; 
        case ROSE_CALL_ACCEPTED : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = 0x00 ; 
            * dptr ++ = 0 ; 
            break ; 
        case ROSE_CLEAR_REQUEST : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = rose -> cause ; 
            * dptr ++ = rose -> diagnostic ; 
            break ; 
        case ROSE_RESET_REQUEST : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = ROSE_DTE_ORIGINATED ; 
            * dptr ++ = 0 ; 
            break ; 
        case ROSE_RR : 
        case ROSE_RNR : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr = frametype ; 
            * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; 
            break ;",1000,-17.70226829010062,-0.01770226829010062
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { 
  struct rose_sock * rose = rose_sk ( sk ) ; 
  struct sk_buff * skb ; 
  unsigned char * dptr ; 
  unsigned char lci1 , lci2 ; 
  char buffer [ 100 ] ; 
  int len , faclen = 0 ; 
  len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
  
  // Input Validation
  if (frametype < 0 || frametype > ROSE_RESET_CONFIRMATION) {
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
    return;
  }
  
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
    len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
    faclen = rose_create_facilities ( buffer , rose ) ; 
    len += faclen ; 
    break ; 
    case ROSE_CALL_ACCEPTED : 
    case ROSE_CLEAR_REQUEST : 
    case ROSE_RESET_REQUEST : 
    len += 2 ; 
    break ; 
  } 
  if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) 
    return ; 
  skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
  dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
  lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
  lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
    * dptr ++ = ROSE_GFI | lci1 ; 
    * dptr ++ = lci2 ; 
    * dptr ++ = frametype ; 
    * dptr ++ = 0xAA ; 
    memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
    dptr += ROSE_ADDR_LEN ; 
    memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
    dptr += ROSE_ADDR_LEN ; 
    memcpy ( dptr , buffer , faclen ) ; 
    dptr += faclen ; 
    break ; 
    case ROSE_CALL_ACCEPTED : 
    * dptr ++ = ROSE_GFI | lci1 ; 
    * dptr ++ = lci2 ; 
    * dptr ++ = frametype ; 
    * dptr ++ = 0x00 ; 
    * dptr ++ = 0 ; 
    break ; 
    case ROSE_CLEAR_REQUEST : 
    * dptr ++ = ROSE_GFI | lci1 ; 
    * dptr ++ = lci2 ; 
    * dptr ++ = frametype ; 
    * dptr ++ = rose -> cause ; 
    * dptr ++ = rose -> diagnostic ; 
    break ; 
    case ROSE_RESET_REQUEST : 
    * dptr ++ = ROSE_GFI | lci1 ; 
    * dptr ++ = lci2 ; 
    * dptr ++ = frametype ; 
    * dptr ++ = ROSE_DTE_ORIGINATED ; 
    * dptr ++ = 0 ; 
    break ; 
    case ROSE_RR : 
    case ROSE_RNR : 
    * dptr ++ = ROSE_GFI | lci1 ; 
    * dptr ++ = lci2 ; 
    * dptr = frametype ; 
    * dptr ++ |= ( rose -> vr <<",1000,-22.873631543074364,-0.022873631543074365
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { 
 struct rose_sock * rose = rose_sk ( sk ) ; 
 struct sk_buff * skb ; 
 unsigned char * dptr ; 
 unsigned char lci1 , lci2 ; 
 char buffer [ 100 ] ; 
 int len , faclen = 0 ; 
 
 // Added input validation
 if ( frametype < ROSE_CALL_REQUEST || frametype > ROSE_RESET_CONFIRMATION ) {
  printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; 
  return ;
 }
 
 len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
 switch ( frametype ) { 
  case ROSE_CALL_REQUEST : 
   len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
   faclen = rose_create_facilities ( buffer , rose ) ; 
   len += faclen ; 
   break ; 
  case ROSE_CALL_ACCEPTED : 
  case ROSE_CLEAR_REQUEST : 
  case ROSE_RESET_REQUEST : 
   len += 2 ; 
   break ; 
 } 
 if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) 
  return ; 
 skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
 dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
 lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
 lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
 switch ( frametype ) { 
  case ROSE_CALL_REQUEST : 
   * dptr ++ = ROSE_GFI | lci1 ; 
   * dptr ++ = lci2 ; 
   * dptr ++ = frametype ; 
   * dptr ++ = 0xAA ; 
   memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
   dptr += ROSE_ADDR_LEN ; 
   memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
   dptr += ROSE_ADDR_LEN ; 
   memcpy ( dptr , buffer , faclen ) ; 
   dptr += faclen ; 
   break ; 
  case ROSE_CALL_ACCEPTED : 
  * dptr ++ = ROSE_GFI | lci1 ; 
   * dptr ++ = lci2 ; 
   * dptr ++ = frametype ; 
   * dptr ++ = 0x00 ; 
   * dptr ++ = 0 ; 
   break ; 
  case ROSE_CLEAR_REQUEST : 
   * dptr ++ = ROSE_GFI | lci1 ; 
   * dptr ++ = lci2 ; 
   * dptr ++ = frametype ; 
   * dptr ++ = rose -> cause ; 
   * dptr ++ = rose -> diagnostic ; 
   break ; 
  case ROSE_RESET_REQUEST : 
   * dptr ++ = ROSE_GFI | lci1 ; 
   * dptr ++ = lci2 ; 
   * dptr ++ = frametype ; 
   * dptr ++ = ROSE_DTE_ORIGINATED ; 
   * dptr ++ = 0 ; 
   break ; 
  case ROSE_RR : 
  case ROSE_RNR : 
   * dptr ++ = ROSE_GFI | lci1 ; 
   * dptr ++ = lci2 ; 
   * dptr = frametype ; 
   * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; 
",1000,-25.666852930199234,-0.025666852930199234
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; if ( frametype == ROSE_CALL_REQUEST ) { len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; } else if ( frametype == ROSE_CALL_ACCEPTED || frametype == ROSE_CLEAR_REQUEST || frametype == ROSE_RESET_REQUEST ) { len += 2 ; } else { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",880,-7.24400734593195,-0.008231826529468125
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) {
  struct rose_sock * rose = rose_sk ( sk ) ;
  struct sk_buff * skb ;
  unsigned char * dptr ;
  unsigned char lci1 , lci2 ;
  char buffer [ 100 ] ;
  int len , faclen = 0 ;
  
  switch ( frametype ) {
    case ROSE_CALL_REQUEST :
      len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ;
      len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
      faclen = rose_create_facilities ( buffer , rose ) ;
      len += faclen ;
      break ;
    case ROSE_CALL_ACCEPTED :
    case ROSE_CLEAR_REQUEST :
    case ROSE_RESET_REQUEST :
      len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 3 ;
      break ;
    default :
      return ;
  }

  if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ;
  skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ;
  dptr = skb_put ( skb , skb_tailroom ( skb ) ) ;
  lci1 = ( rose -> lci >> 8 ) & 0x0F ;
  lci2 = ( rose -> lci >> 0 ) & 0xFF ;
  switch ( frametype ) {
    case ROSE_CALL_REQUEST :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr ++ = frametype ;
      * dptr ++ = 0xAA ;
      memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;
      dptr += ROSE_ADDR_LEN ;
      memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ;
      dptr += ROSE_ADDR_LEN ;
      memcpy ( dptr , buffer , faclen ) ;
      dptr += faclen ;
      break ;
    case ROSE_CALL_ACCEPTED :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr ++ = frametype ;
      * dptr ++ = 0x00 ;
      * dptr ++ = 0 ;
      break ;
    case ROSE_CLEAR_REQUEST :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr ++ = frametype ;
      * dptr ++ = rose -> cause ;
      * dptr ++ = rose -> diagnostic ;
      break ;
    case ROSE_RESET_REQUEST :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr ++ = frametype ;
      * dptr ++ = ROSE_DTE_ORIGINATED ;
      * dptr ++ = 0 ;
      break ;
    case ROSE_RR :
    case ROSE_RNR :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr = frametype ;
      * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ;
      break ;
    case ROSE_CLEAR_CONFIRMATION :
    case ROSE_RESET_CONFIRMATION :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr ++ = frametype ;
      break ;
  }
  rose_transmit_link ( skb , rose -> neighbour ) ;
",1000,-30.60639881348594,-0.03060639881348594
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) {
    struct rose_sock * rose = rose_sk ( sk ) ; 
    struct sk_buff * skb ; 
    unsigned char * dptr ; 
    unsigned char lci1 , lci2 ; 
    char buffer [ 100 ] ; 
    int len , faclen = 0 ; 
    len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
    
    // Validate frametype
    if (frametype < 0 || frametype > 8) {
        printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; 
        return;
    }
    
    switch ( frametype ) { 
        case ROSE_CALL_REQUEST : 
            len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
            faclen = rose_create_facilities ( buffer , rose ) ; 
            len += faclen ; 
            break ; 
        case ROSE_CALL_ACCEPTED : 
        case ROSE_CLEAR_REQUEST : 
        case ROSE_RESET_REQUEST : 
            len += 2 ; 
            break ; 
    } 
    if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; 
    skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
    dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
    lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
    lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
    switch ( frametype ) { 
        case ROSE_CALL_REQUEST : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = 0xAA ; 
            memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
            dptr += ROSE_ADDR_LEN ; 
            memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
            dptr += ROSE_ADDR_LEN ; 
            memcpy ( dptr , buffer , faclen ) ; 
            dptr += faclen ; 
            break ; 
        case ROSE_CALL_ACCEPTED : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = 0x00 ; 
            * dptr ++ = 0 ; 
            break ; 
        case ROSE_CLEAR_REQUEST : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = rose -> cause ; 
            * dptr ++ = rose -> diagnostic ; 
            break ; 
        case ROSE_RESET_REQUEST : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = ROSE_DTE_ORIGINATED ; 
            * dptr ++ = 0 ; 
            break ; 
        case ROSE_RR : 
        case ROSE_RNR : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr = frametype ; 
            * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; 
",1000,-20.459844956695424,-0.020459844956695422
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; // Added input validation if ( frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST && frametype != ROSE_RR && frametype != ROSE_RNR && frametype != ROSE_CLEAR_CONFIRMATION && frametype != ROSE_RESET_CONFIRMATION ) { printk ( KERN_ERR ""ROSE: Invalid frametype %02X\\n"" , frametype ) ; return ; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",952,-15.892592473454602,-0.016693899656990127
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { 
  struct rose_sock * rose = rose_sk ( sk ) ; 
  struct sk_buff * skb ; 
  unsigned char * dptr ; 
  unsigned char lci1 , lci2 ; 
  char buffer [ 100 ] ; 
  int len , faclen = 0 ; 
  len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
  if (frametype != ROSE_CALL_REQUEST && 
      frametype != ROSE_CALL_ACCEPTED && 
      frametype != ROSE_CLEAR_REQUEST && 
      frametype != ROSE_RESET_REQUEST && 
      frametype != ROSE_RR && 
      frametype != ROSE_RNR && 
      frametype != ROSE_CLEAR_CONFIRMATION && 
      frametype != ROSE_RESET_CONFIRMATION) {
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
    return;
  }
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
      len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
      faclen = rose_create_facilities ( buffer , rose ) ; 
      len += faclen ; 
      break ; 
    case ROSE_CALL_ACCEPTED : 
    case ROSE_CLEAR_REQUEST : 
    case ROSE_RESET_REQUEST : 
      len += 2 ; 
      break ; 
  } 
  if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) 
    return ; 
  skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
  dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
  lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
  lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = 0xAA ; 
      memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
      dptr += ROSE_ADDR_LEN ; 
      memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
      dptr += ROSE_ADDR_LEN ; 
      memcpy ( dptr , buffer , faclen ) ; 
      dptr += faclen ; 
      break ; 
    case ROSE_CALL_ACCEPTED : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = 0x00 ; 
      * dptr ++ = 0 ; 
      break ; 
    case ROSE_CLEAR_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = rose -> cause ; 
      * dptr ++ = rose -> diagnostic ; 
      break ; 
    case ROSE_RESET_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = ROSE_DTE_ORIGIN",1000,-15.626518057829243,-0.015626518057829244
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) {
    struct rose_sock * rose = rose_sk ( sk ) ;
    struct sk_buff * skb ;
    unsigned char * dptr ;
    unsigned char lci1 , lci2 ;
    char buffer [ 100 ] ;
    int len , faclen = 0 ;
    len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ;
    if ( frametype == ROSE_CALL_REQUEST ) {
        len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ;
        faclen = rose_create_facilities ( buffer , rose ) ;
        len += faclen ;
    } else if ( frametype == ROSE_CALL_ACCEPTED || frametype == ROSE_CLEAR_REQUEST || frametype == ROSE_RESET_REQUEST ) {
        len += 2 ;
    } else {
        printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
        return ;
    }
    if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ;
    skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ;
    dptr = skb_put ( skb , skb_tailroom ( skb ) ) ;
    lci1 = ( rose -> lci >> 8 ) & 0x0F ;
    lci2 = ( rose -> lci >> 0 ) & 0xFF ;
    switch ( frametype ) {
        case ROSE_CALL_REQUEST :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
            * dptr ++ = frametype ;
            * dptr ++ = 0xAA ;
            memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;
            dptr += ROSE_ADDR_LEN ;
            memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ;
            dptr += ROSE_ADDR_LEN ;
            memcpy ( dptr , buffer , faclen ) ;
            dptr += faclen ;
            break ;
        case ROSE_CALL_ACCEPTED :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
            * dptr ++ = frametype ;
            * dptr ++ = 0x00 ;
            * dptr ++ = 0 ;
            break ;
        case ROSE_CLEAR_REQUEST :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
            * dptr ++ = frametype ;
            * dptr ++ = rose -> cause ;
            * dptr ++ = rose -> diagnostic ;
            break ;
        case ROSE_RESET_REQUEST :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
            * dptr ++ = frametype ;
            * dptr ++ = ROSE_DTE_ORIGINATED ;
            * dptr ++ = 0 ;
            break ;
        case ROSE_RR :
        case ROSE_RNR :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
            * dptr = frametype ;
            * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ;
            break ;
        case ROSE_CLEAR_CONFIRMATION :
        case ROSE_RESET_CONFIRMATION :
            * dptr ++ = ROSE_GFI | lci1 ;
            * dptr ++ = lci2 ;
            * dptr ++ = frametype ;
            break ;
        default :
            printk ( KERN_ERR ""ROSE: rose",1000,-14.379552076891658,-0.014379552076891658
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { 
   struct rose_sock * rose = rose_sk ( sk ) ; 
   struct sk_buff * skb ; 
   unsigned char * dptr ; 
   unsigned char lci1 , lci2 ; 
   char buffer [ 100 ] ; 
   int len , faclen = 0 ; 
   len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
 
   // Validate the frametype
   if (frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED &&
       frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST) {
       printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; 
       return ;
   }
    
   switch ( frametype ) { 
       case ROSE_CALL_REQUEST : 
           len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
           faclen = rose_create_facilities ( buffer , rose ) ; 
           len += faclen ; 
           break ; 
       case ROSE_CALL_ACCEPTED : 
       case ROSE_CLEAR_REQUEST : 
       case ROSE_RESET_REQUEST : 
           len += 2 ; 
           break ; 
   } 
   if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
   dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
   lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
   lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
   switch ( frametype ) { 
       case ROSE_CALL_REQUEST : 
           * dptr ++ = ROSE_GFI | lci1 ; 
           * dptr ++ = lci2 ; 
           * dptr ++ = frametype ; 
           * dptr ++ = 0xAA ; 
           memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
           dptr += ROSE_ADDR_LEN ; 
           memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
           dptr += ROSE_ADDR_LEN ; 
           memcpy ( dptr , buffer , faclen ) ; 
           dptr += faclen ; 
           break ; 
       case ROSE_CALL_ACCEPTED : 
           * dptr ++ = ROSE_GFI | lci1 ; 
           * dptr ++ = lci2 ; 
           * dptr ++ = frametype ; 
           * dptr ++ = 0x00 ; 
           * dptr ++ = 0 ; 
           break ; 
       case ROSE_CLEAR_REQUEST : 
           * dptr ++ = ROSE_GFI | lci1 ; 
           * dptr ++ = lci2 ; 
           * dptr ++ = frametype ; 
           * dptr ++ = rose -> cause ; 
           * dptr ++ = rose -> diagnostic ; 
           break ; 
       case ROSE_RESET_REQUEST : 
           * dptr ++ = ROSE_GFI | lci1 ; 
           * dptr ++ = lci2 ; 
           * dptr ++ = frametype ; 
           * dptr ++ = ROSE_DTE_ORIGINATED ; 
           * dptr ++ = 0 ; 
           break ; 
       case ROSE_RR : 
       case ROSE_RNR : 
           * dptr ++ = ROSE_GFI | lci1 ; 
           * dptr",1000,-38.65693965324676,-0.03865693965324676
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; 
//added validation check 
if (frametype < 0 || frametype > 8) {
  printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
  return;
}

len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",927,-24.436001308360275,-0.026360303461014322
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","

void rose_write_internal ( struct sock * sk , int frametype ) { 
  struct rose_sock * rose = rose_sk ( sk ) ; 
  struct sk_buff * skb ; 
  unsigned char * dptr ; 
  unsigned char lci1 , lci2 ; 
  char buffer [ 100 ] ; 
  int len , faclen = 0 ; 
  
  if(frametype < 0 || frametype > ROSE_RESET_CONFIRMATION){ //input validation
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\n"" , frametype ) ;
    return;
  }
  
  len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
      len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
      faclen = rose_create_facilities ( buffer , rose ) ; 
      len += faclen ; 
      break ; 
    case ROSE_CALL_ACCEPTED : 
    case ROSE_CLEAR_REQUEST : 
    case ROSE_RESET_REQUEST : 
      len += 2 ; 
      break ; 
  } 
  if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) 
    return ; 
  skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
  dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
  lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
  lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = 0xAA ; 
      memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
      dptr += ROSE_ADDR_LEN ; 
      memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
      dptr += ROSE_ADDR_LEN ; 
      memcpy ( dptr , buffer , faclen ) ; 
      dptr += faclen ; 
      break ; 
    case ROSE_CALL_ACCEPTED : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = 0x00 ; 
      * dptr ++ = 0 ; 
      break ; 
    case ROSE_CLEAR_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = rose -> cause ; 
      * dptr ++ = rose -> diagnostic ; 
      break ; 
    case ROSE_RESET_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = ROSE_DTE_ORIGINATED ; 
      * dptr ++ = 0 ; 
      break ; 
    case ROSE_RR : 
    case ROSE_RNR : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr = frametype ; 
      * dptr ++ |= ( rose -> vr << 5 ) &",1000,-26.894126971801416,-0.026894126971801414
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { 
    struct rose_sock * rose = rose_sk ( sk ) ; 
    struct sk_buff * skb ; 
    unsigned char * dptr ; 
    unsigned char lci1 , lci2 ; 
    char buffer [ 100 ] ; 
    int len , faclen = 0 ; 
    
    //Validate input parameter
    if (frametype < 0 || frametype > 7) {
        printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; 
        return ; 
    }
    
    len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
    switch ( frametype ) { 
        case ROSE_CALL_REQUEST : 
            len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
            faclen = rose_create_facilities ( buffer , rose ) ; 
            len += faclen ; 
            break ; 
        case ROSE_CALL_ACCEPTED : 
        case ROSE_CLEAR_REQUEST : 
        case ROSE_RESET_REQUEST : 
            len += 2 ; 
            break ; 
    } 
    if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) 
        return ; 
    skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
    dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
    lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
    lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
    switch ( frametype ) { 
        case ROSE_CALL_REQUEST : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = 0xAA ; 
            memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
            dptr += ROSE_ADDR_LEN ; 
            memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
            dptr += ROSE_ADDR_LEN ; 
            memcpy ( dptr , buffer , faclen ) ; 
            dptr += faclen ; 
            break ; 
        case ROSE_CALL_ACCEPTED : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = 0x00 ; 
            * dptr ++ = 0 ; 
            break ; 
        case ROSE_CLEAR_REQUEST : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = rose -> cause ; 
            * dptr ++ = rose -> diagnostic ; 
            break ; 
        case ROSE_RESET_REQUEST : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr ++ = frametype ; 
            * dptr ++ = ROSE_DTE_ORIGINATED ; 
            * dptr ++ = 0 ; 
            break ; 
        case ROSE_RR : 
        case ROSE_RNR : 
            * dptr ++ = ROSE_GFI | lci1 ; 
            * dptr ++ = lci2 ; 
            * dptr = frametype ; 
            * dptr ++ |= ( rose -> vr << 5 ) & 0xE",1000,-23.667174817740996,-0.023667174817740996
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
//Validate input 
if (frametype < ROSE_CALL_REQUEST || frametype > ROSE_RESET_CONFIRMATION) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return; }
switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",909,-18.742543110608292,-0.02061885930759988
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { 
  struct rose_sock * rose = rose_sk ( sk ) ; 
  struct sk_buff * skb ; 
  unsigned char * dptr ; 
  unsigned char lci1 , lci2 ; 
  char buffer [ 100 ] ; 
  int len , faclen = 0 ; 
  len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
 
  // Validate input
  if ( frametype < ROSE_CALL_REQUEST || frametype > ROSE_RESET_CONFIRMATION) {
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; 
    return; 
  }
 
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
      len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
      faclen = rose_create_facilities ( buffer , rose ) ; 
      len += faclen ; 
      break ; 
    case ROSE_CALL_ACCEPTED : 
    case ROSE_CLEAR_REQUEST : 
    case ROSE_RESET_REQUEST : 
      len += 2 ; 
      break ; 
  } 
  
  if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) 
    return ; 
  
  skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
  dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
  lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
  lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
  
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = 0xAA ; 
      memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
      dptr += ROSE_ADDR_LEN ; 
      memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
      dptr += ROSE_ADDR_LEN ; 
      memcpy ( dptr , buffer , faclen ) ; 
      dptr += faclen ; 
      break ; 
    case ROSE_CALL_ACCEPTED : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = 0x00 ; 
      * dptr ++ = 0 ; 
      break ; 
    case ROSE_CLEAR_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = rose -> cause ; 
      * dptr ++ = rose -> diagnostic ; 
      break ; 
    case ROSE_RESET_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = ROSE_DTE_ORIGINATED ; 
      * dptr ++ = 0 ; 
      break ; 
    case ROSE_RR : 
    case ROSE_RNR : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr = frametype ;",1000,-27.756482326368374,-0.027756482326368376
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:"," 
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 

if (frametype == ROSE_CALL_REQUEST || frametype == ROSE_CALL_ACCEPTED || frametype == ROSE_CLEAR_REQUEST || frametype == ROSE_RESET_REQUEST || frametype == ROSE_RR || frametype == ROSE_RNR || frametype == ROSE_CLEAR_CONFIRMATION || frametype == ROSE_RESET_CONFIRMATION) {
  switch ( frametype ) {
    case ROSE_CALL_REQUEST :
      len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ;
      faclen = rose_create_facilities ( buffer , rose ) ;
      len += faclen ;
      break ;
    case ROSE_CALL_ACCEPTED :
    case ROSE_CLEAR_REQUEST :
    case ROSE_RESET_REQUEST :
      len += 2 ;
      break ;
  }
  
  if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ;
  skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ;
  dptr = skb_put ( skb , skb_tailroom ( skb ) ) ;
  lci1 = ( rose -> lci >> 8 ) & 0x0F ;
  lci2 = ( rose -> lci >> 0 ) & 0xFF ;
  switch ( frametype ) {
    case ROSE_CALL_REQUEST :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr ++ = frametype ;
      * dptr ++ = 0xAA ;
      memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;
      dptr += ROSE_ADDR_LEN ;
      memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ;
      dptr += ROSE_ADDR_LEN ;
      memcpy ( dptr , buffer , faclen ) ;
      dptr += faclen ;
      break ;
    case ROSE_CALL_ACCEPTED :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr ++ = frametype ;
      * dptr ++ = 0x00 ;
      * dptr ++ = 0 ;
      break ;
    case ROSE_CLEAR_REQUEST :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr ++ = frametype ;
      * dptr ++ = rose -> cause ;
      * dptr ++ = rose -> diagnostic ;
      break ;
    case ROSE_RESET_REQUEST :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr ++ = frametype ;
      * dptr ++ = ROSE_DTE_ORIGINATED ;
      * dptr ++ = 0 ;
      break ;
    case ROSE_RR :
    case ROSE_RNR :
      * dptr ++ = ROSE_GFI | lci1 ;
      * dptr ++ = lci2 ;
      * dptr = frametype ;
      * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ;
      break ;
    case ROSE_CLEAR_CONFIRMATION :
    case ROSE_RESET_CONFIRMATION :
      * dptr ++ = ROSE",1000,-19.926319773062495,-0.019926319773062494
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; if ( frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST && frametype != ROSE_RR && frametype != ROSE_RNR && frametype != ROSE_CLEAR_CONFIRMATION && frametype != ROSE_RESET_CONFIRMATION) {  printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;  return ; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",956,-12.28427622722142,-0.012849661325545419
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; if ( frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST && frametype != ROSE_RR && frametype != ROSE_RNR && frametype != ROSE_CLEAR_CONFIRMATION && frametype != ROSE_RESET_CONFIRMATION) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",974,-9.063873088375932,-0.009305824526053318
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { 
  struct rose_sock * rose = rose_sk ( sk ) ; 
  struct sk_buff * skb ; 
  unsigned char * dptr ; 
  unsigned char lci1 , lci2 ; 
  char buffer [ 100 ] ; 
  int len , faclen = 0 ; 
  // Validate the frame type
  if (frametype < ROSE_CALL_REQUEST || frametype > ROSE_RESET_CONFIRMATION) {
    printk(KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"", frametype);
    return;
  }
  len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
      len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
      faclen = rose_create_facilities ( buffer , rose ) ; 
      len += faclen ; 
      break ; 
    case ROSE_CALL_ACCEPTED : 
    case ROSE_CLEAR_REQUEST : 
    case ROSE_RESET_REQUEST : 
      len += 2 ; 
      break ; 
  } 
  if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; 
  skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
  dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
  lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
  lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = 0xAA ; 
      memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
      dptr += ROSE_ADDR_LEN ; 
      memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
      dptr += ROSE_ADDR_LEN ; 
      memcpy ( dptr , buffer , faclen ) ; 
      dptr += faclen ; 
      break ; 
    case ROSE_CALL_ACCEPTED : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = 0x00 ; 
      * dptr ++ = 0 ; 
      break ; 
    case ROSE_CLEAR_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = rose -> cause ; 
      * dptr ++ = rose -> diagnostic ; 
      break ; 
    case ROSE_RESET_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = ROSE_DTE_ORIGINATED ; 
      * dptr ++ = 0 ; 
      break ; 
    case ROSE_RR : 
    case ROSE_RNR : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr = frametype ; 
      * dptr ++ |= ( rose -> vr <<",1000,-21.480526684062,-0.021480526684061998
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; //Add input validation if (frametype < 0 || frametype > 9) { printk(KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"", frametype); return; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",866,-15.865484300173335,-0.018320420669946116
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 

// Validate the input to ensure it is a valid frame type
if (!validateFrameType(frametype)) {
  printf(""Invalid frametype!\n"");
  return;
}

switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }

// Validate the input to ensure it is a valid frame type
int validateFrameType(int frametype) {
  // Add valid frame types
  int validFrameTypes[] = {ROSE_CALL_REQUEST, ROSE_CALL_ACCEPTED, ROSE_CLEAR_REQUEST,
  ROSE_RESET_REQUEST, ROSE_RR, ROSE_RNR, ROSE_CLEAR_CONFIRMATION, ROSE_RESET_CONFIRMATION};
  int validFrameTypesLength = 8;

  for (int i = 0; i < validFrameTypes",1000,-60.007810586768635,-0.060007810586768635
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; //Added check to validate the input if(frametype < 0 || frametype > 8) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",871,-19.993373049419,-0.02295450407510792
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","

void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 

//Validate the frametype
if (frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST && frametype != ROSE_RR && frametype != ROSE_RNR && frametype != ROSE_CLEAR_CONFIRMATION && frametype != ROSE_RESET_CONFIRMATION) {
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
    return;
}

switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } 

if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",976,-17.895703181895176,-0.01833576145685981
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","

void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; 
// validate frametype
if(!isValidFrametype(frametype)){
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; 
    return ;
}

len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }

// function to validate frametype
bool isValidFrametype(int frametype){
    switch(frametype){
        case ROSE_CALL_REQUEST : 
        case ROSE_CALL_ACCEPTED : 
        case ROSE_CLEAR_REQUEST : 
        case ROSE_RESET_REQUEST : 
        case ROSE_RR : 
        case ROSE_RNR : 
        case ROSE_CLEAR_CONFIRMATION : 
        case",1000,-37.09714885192478,-0.03709714885192478
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; if ( frametype == ROSE_CALL_REQUEST ) { len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; } else if ( frametype == ROSE_CALL_ACCEPTED || frametype == ROSE_CLEAR_REQUEST || frametype == ROSE_RESET_REQUEST ) { len += 2 ; } else { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",880,-7.083485607272029,-0.008049415462809123
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 

//Validate frametype
if (frametype < 0 || frametype > 5) {
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
    return;
}

switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } 

if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; 

switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",921,-23.51524579854611,-0.025532297283980578
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; if ( frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST ) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",925,-7.0830690146372515,-0.007657371907715947
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; if ( frametype < 0 || frametype > 7 ) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",884,-6.986693309206499,-0.007903499218559389
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
//Validation check 
if( frametype > 6 || frametype < 0){ 
printk(KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"", frametype ); 
return; } 
switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",923,-41.32435284519469,-0.04477177989728569
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; if(frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST && frametype != ROSE_RR && frametype != ROSE_RNR && frametype != ROSE_CLEAR_CONFIRMATION && frametype != ROSE_RESET_CONFIRMATION) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",954,-6.917368030494707,-0.007250909885214578
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 

//Validate that the frametype is valid
if (frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST) {
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
    return;
}

switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",926,-18.356457080574003,-0.019823387775997844
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; //Check for valid frame type if(frametype < 0 || frametype > 7) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",870,-15.702606658427042,-0.018048973170605796
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; if (!(frametype == ROSE_CALL_REQUEST || frametype == ROSE_CALL_ACCEPTED || frametype == ROSE_CLEAR_REQUEST || frametype == ROSE_RESET_REQUEST || frametype == ROSE_RR || frametype == ROSE_RNR || frametype == ROSE_CLEAR_CONFIRMATION || frametype == ROSE_RESET_CONFIRMATION)) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",955,-8.755931558826692,-0.009168514721284495
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 

if (frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST && 
frametype != ROSE_RR && frametype != ROSE_RNR && frametype != ROSE_CLEAR_CONFIRMATION && frametype != ROSE_RESET_CONFIRMATION){
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; 
    return;
}

switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",966,-17.15254207257957,-0.017756254733519224
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","

void rose_write_internal ( struct sock * sk , int frametype ) { 
  struct rose_sock * rose = rose_sk ( sk ) ; 
  struct sk_buff * skb ; 
  unsigned char * dptr ; 
  unsigned char lci1 , lci2 ; 
  char buffer [ 100 ] ; 
  int len , faclen = 0 ; 
  
  // Add input validation
  if (fratype < 0 || frametype > ROSE_RESET_CONFIRMATION) {
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
    return;
  }
  
  len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
      len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
      faclen = rose_create_facilities ( buffer , rose ) ; 
      len += faclen ; 
      break ; 
    case ROSE_CALL_ACCEPTED : 
    case ROSE_CLEAR_REQUEST : 
    case ROSE_RESET_REQUEST : 
      len += 2 ; 
      break ; 
  } 
  
  if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) 
    return ; 
  skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
  dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
  lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
  lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
  switch ( frametype ) { 
    case ROSE_CALL_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = 0xAA ; 
      memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
      dptr += ROSE_ADDR_LEN ; 
      memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
      dptr += ROSE_ADDR_LEN ; 
      memcpy ( dptr , buffer , faclen ) ; 
      dptr += faclen ; 
      break ; 
    case ROSE_CALL_ACCEPTED : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = 0x00 ; 
      * dptr ++ = 0 ; 
      break ; 
    case ROSE_CLEAR_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = rose -> cause ; 
      * dptr ++ = rose -> diagnostic ; 
      break ; 
    case ROSE_RESET_REQUEST : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr ++ = frametype ; 
      * dptr ++ = ROSE_DTE_ORIGINATED ; 
      * dptr ++ = 0 ; 
      break ; 
    case ROSE_RR : 
    case ROSE_RNR : 
      * dptr ++ = ROSE_GFI | lci1 ; 
      * dptr ++ = lci2 ; 
      * dptr = frametype ; 
      * dptr ++ |= ( rose ->",1000,-29.634362440533742,-0.029634362440533742
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; if ( frametype < 0 || frametype > 7 ) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",864,-7.164978433486649,-0.00829279911283177
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { 
        struct rose_sock * rose = rose_sk ( sk ) ; 
        struct sk_buff * skb ; 
        unsigned char * dptr ; 
        unsigned char lci1 , lci2 ; 
        char buffer [ 100 ] ; 
        int len , faclen = 0 ; 
        len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
        
        // input validation
        if (frametype < ROSE_CALL_REQUEST || frametype > ROSE_RESET_CONFIRMATION) {
            printk(KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype);
            return;
        }

        switch ( frametype ) { 
            case ROSE_CALL_REQUEST : 
                len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; 
                faclen = rose_create_facilities ( buffer , rose ) ; 
                len += faclen ; 
                break ; 
            case ROSE_CALL_ACCEPTED : 
            case ROSE_CLEAR_REQUEST : 
            case ROSE_RESET_REQUEST : 
                len += 2 ; 
                break ; 
        } 
        if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) 
            return ; 
        skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; 
        dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; 
        lci1 = ( rose -> lci >> 8 ) & 0x0F ; 
        lci2 = ( rose -> lci >> 0 ) & 0xFF ; 
        switch ( frametype ) { 
            case ROSE_CALL_REQUEST : 
                * dptr ++ = ROSE_GFI | lci1 ; 
                * dptr ++ = lci2 ; 
                * dptr ++ = frametype ; 
                * dptr ++ = 0xAA ; 
                memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; 
                dptr += ROSE_ADDR_LEN ; 
                memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; 
                dptr += ROSE_ADDR_LEN ; 
                memcpy ( dptr , buffer , faclen ) ; 
                dptr += faclen ; 
                break ; 
            case ROSE_CALL_ACCEPTED : 
                * dptr ++ = ROSE_GFI | lci1 ; 
                * dptr ++ = lci2 ; 
                * dptr ++ = frametype ; 
                * dptr ++ = 0x00 ; 
                * dptr ++ = 0 ; 
                break ; 
            case ROSE_CLEAR_REQUEST : 
                * dptr ++ = ROSE_GFI | lci1 ; 
                * dptr ++ = lci2 ; 
                * dptr ++ = frametype ; 
                * dptr ++ = rose -> cause ; 
                * dptr ++ = rose -> diagnostic ; 
                break ; 
            case ROSE_RESET_REQUEST : 
                * dptr ++ = ROSE_GFI | lci1 ; 
                * dptr ++ = lci2 ; 
                * dptr ++ = frametype ; 
                * dptr ++ = ROSE_DTE_ORIGINATED ; 
                * dptr ++ = 0 ; 
                break ; 
            case ROSE_RR : 
            case ROSE_RNR : 
                * dptr ++ = ROSE_GFI | lci1 ; 
                * dptr ++ = lci2 ; 
                * dptr = frametype ; 
                * dptr ++ |= ( rose ->",1000,-25.7999280315368,-0.0257999280315368
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; //Validate the frametype if ( frametype < 0 || frametype > 2 ) { printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; return ; } else { len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; } }",874,-24.41942541702062,-0.027939846014897733
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
Fixed code:","
void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; 
if (frametype != ROSE_CALL_REQUEST && frametype != ROSE_CALL_ACCEPTED && frametype != ROSE_CLEAR_REQUEST && frametype != ROSE_RESET_REQUEST && frametype != ROSE_RR && frametype != ROSE_RNR && frametype != ROSE_CLEAR_CONFIRMATION && frametype != ROSE_RESET_CONFIRMATION) {
    printk ( KERN_ERR ""ROSE: rose_write_internal - invalid frametype %02X\\n"" , frametype ) ;
    return;
}

switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } 

if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0xAA ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; } rose_transmit_link ( skb , rose -> neighbour ) ; }",966,-14.700529790597905,-0.015217939741819777
