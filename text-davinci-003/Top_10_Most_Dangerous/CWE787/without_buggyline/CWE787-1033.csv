Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , 256 + AUTH_PASS_LEN ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length < 256 + AUTH_PASS_LEN ? length : 256 + AUTH_PASS_LEN ) ; } }",549,-7.696649323540778,-0.014019397674937664
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","

static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , sizeof(hashed) ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",527,-7.730140477593014,-0.014668198249702114
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; // Added boundary check if (length > MAXPASS || length > 256 + AUTH_PASS_LEN) { return; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { // Added boundary check if (length > attr->length) { return; } memcpy ( attr -> data , hashed , length ) ; } }",551,-18.223004880905076,-0.03307260413957364
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; }// Limit the max size for the password to avoid Out-of-bounds write if (length > 256 + AUTH_PASS_LEN) { length = 256 + AUTH_PASS_LEN; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",565,-37.63714472404551,-0.06661441544078851
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } if (length >= 256 + AUTH_PASS_LEN) { //Added to fix vulnerability return; } //Added to fix vulnerability memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",549,-20.819783336823484,-0.03792310261716481
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length <= MAXPASS + AUTH_PASS_LEN ? length : MAXPASS + AUTH_PASS_LEN ) ; } }",545,-11.568744062899622,-0.021227053326421327
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; size_t length = strlen ( password ) ; size_t maxLength = MAXPASS + AUTH_PASS_LEN; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; 

if ( length > MAXPASS ) { length = MAXPASS ; } 

if ( length == 0 ) { length = AUTH_PASS_LEN ; } 

if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } 

length = length > maxLength ? maxLength : length;

memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } 

if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } } 
The code has been corrected to prevent the possibility of writing to a memory location beyond the allocated size by calculating the length of the input and ensuring it does not exceed the maximum allowed size. Additionally, the code was modified to use the size_t data type instead of the int data type to ensure that the length of the input is correctly calculated and stored.",642,-108.6038471368659,-0.16916487092969765
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , (length < AUTH_PASS_LEN) ? length : AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",535,-10.972870152600041,-0.020510037668411293
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , MAXPASS ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",513,-17.80750653453354,-0.03471248837141041
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } // Add the following line to prevent out-of-bounds write. if (length > 256 + AUTH_PASS_LEN) { return; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",554,-17.106520005608818,-0.030878194955972597
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:"," 
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } 
if (length > (256 + AUTH_PASS_LEN)) { //Check for buffer overflow length = (256 + AUTH_PASS_LEN); }

memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",560,-25.43071717660939,-0.045411994958231054
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; 
if ( length > MAXPASS || length == 0 ) {
    length = AUTH_PASS_LEN ;
}
if ( length > AUTH_PASS_LEN ) {
    length = AUTH_PASS_LEN ;
}
memset ( hashed , 0 , length ) ;
memcpy ( hashed , password , strlen ( password ) ) ;
attr = find_attribute ( request , PW_PASSWORD ) ;
if ( type == PW_PASSWORD ) {
    vector = request -> vector ;
} else {
    vector = attr -> data ;
}
MD5Init ( & md5_secret ) ;
MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ;
my_md5 = md5_secret ;
MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ;
MD5Final ( misc , & my_md5 ) ;
xor ( hashed , misc , AUTH_PASS_LEN ) ;
for ( i = 1 ; ( i < ( length >> 4 ) ) && ( i * AUTH_PASS_LEN ) < length ; i ++ ) {
    my_md5 = md5_secret ;
    MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ;
    MD5Final ( misc , & my_md5 ) ;
    xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ;
}
if ( type == PW_OLD_PASSWORD ) {
    attr = find_attribute ( request , PW_OLD_PASSWORD ) ;
}
if ( ! attr ) {
    add_attribute ( request , type , hashed , length ) ;
} else {
    memcpy ( attr -> data , hashed , length ) ;
}
}",547,-32.275227878295716,-0.05900407290364847
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; 
if (length > MAXPASS) {
  length = MAXPASS;
}
if (length == 0) {
  length = AUTH_PASS_LEN;
}
if ((length & (AUTH_PASS_LEN - 1)) != 0) {
 length += (AUTH_PASS_LEN - 1);
 length &= ~(AUTH_PASS_LEN - 1);
}
if (length > MAXPASS+AUTH_PASS_LEN) { //added to fix the vulnerability
  length = MAXPASS+AUTH_PASS_LEN;
}
memset(hashed, 0, length);
memcpy(hashed, password, strlen(password));
attr = find_attribute(request, PW_PASSWORD);
if (type == PW_PASSWORD) {
 vector = request->vector;
} else {
 vector = attr->data;
}
MD5Init(&md5_secret);
MD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));
my_md5 = md5_secret;
MD5Update(&my_md5, vector, AUTH_VECTOR_LEN);
MD5Final(misc, &my_md5);
xor(hashed, misc, AUTH_PASS_LEN);
for (i = 1; i < (length >> 4); i++) {
 my_md5 = md5_secret;
 MD5Update(&my_md5, &hashed[(i - 1) * AUTH_PASS_LEN], AUTH_PASS_LEN);
 MD5Final(misc, &my_md5);
 xor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);
}
if (type == PW_OLD_PASSWORD) {
 attr = find_attribute(request, PW_OLD_PASSWORD);
}
if (!attr) {
 add_attribute(request, type, hashed, length);
} else {
 memcpy(attr->data, hashed, length);
}
}",573,-37.633711424969604,-0.06567837945020874
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } if (length > 256 + AUTH_PASS_LEN) { length = 256 + AUTH_PASS_LEN; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",548,-5.371154306631962,-0.009801376471956136
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length = AUTH_PASS_LEN ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , AUTH_PASS_LEN ) ; } }",508,-8.171798586437367,-0.016086217689837336
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length = AUTH_PASS_LEN ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memset(attr->data, 0, AUTH_PASS_LEN); // Added to prevent out-of-bounds write memcpy ( attr -> data , hashed , length ) ; } }",530,-19.83316584109109,-0.03742106762470017
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; if ( length > strlen(password) ) { memcpy ( hashed , password , strlen ( password ) ) ; } else { memcpy ( hashed , password , length ) ; } attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",549,-9.243322388037127,-0.016836652801524823
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; if (i * AUTH_PASS_LEN > 256 + AUTH_PASS_LEN) {break;} // add a check to make sure we don't write out of bounds } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",559,-27.854464268139907,-0.04982909529184241
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; int hashed_length = 0 ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } hashed_length = length; memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( hashed_length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , hashed_length ) ; } else { memcpy ( attr -> data , hashed , hashed_length ) ; } }",546,-19.044536575635572,-0.03488010361838017
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } if (length > sizeof(hashed)) { length = sizeof(hashed); } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",540,-5.7004616581009575,-0.010556410477964736
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , MAXPASS + AUTH_PASS_LEN ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",531,-5.365686048371839,-0.010104870147592917
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , sizeof(hashed) ) ; // fixed memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",528,-12.779397191881998,-0.024203403772503785
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length / AUTH_PASS_LEN ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
The vulnerability was fixed by changing the size of the hashed array from 256 + AUTH_PASS_LEN to MAXPASS + AUTH_PASS_LEN. This prevents the array from being written to an out-of-bounds location since the size of the array is now limited to the maximum allowed password length of MAXPASS.",597,-36.88305655260292,-0.061780664242215955
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char * hashed ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } hashed = malloc(length); if (hashed == NULL){ return; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } free(hashed); }",536,-13.465891251148074,-0.025122931438709094
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; if ( i * AUTH_PASS_LEN >= length ) { break; } } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",539,-9.922510225570251,-0.018409109880464288
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } if ( length > sizeof(hashed) ) { length = sizeof(hashed); } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",541,-6.689477022158419,-0.012365022222104286
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } if ( length > MAXPASS + AUTH_PASS_LEN ) { length = MAXPASS + AUTH_PASS_LEN; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",551,-8.323704263288432,-0.01510654131268318
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , min(strlen(password), length) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , min(length, sizeof(hashed)) ) ; } }",534,-12.812974541254833,-0.023994334346919163
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:"," 
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } //ADDED IF STATEMENT TO CHECK IF length IS WITHIN THE BOUNDS OF hashed ARRAY //IF NOT, SET length to MAXIMUM VALUE ALLOWED BY hashed ARRAY if (length > (256 + AUTH_PASS_LEN)) { length = (256 + AUTH_PASS_LEN); } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",594,-47.638611544289624,-0.08019968273449432
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; if ( i >= (MAXPASS >> 4)) { break; } } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",537,-11.367575290814207,-0.021168669070417517
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; if ( i >= ( MAXPASS >> 4 ) ) { break; } } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",538,-9.353301678312269,-0.017385319104669644
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen (password) < length ? strlen(password) : length ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; if(i*AUTH_PASS_LEN < length) xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; else xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , length - i*AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
The code has been modified to check if the length of the password is greater than the maximum length before copying it into the hashed array, and to ensure that the xor operation only happens if the length of the password is greater than the current position. This will prevent the code from writing outside of the array bounds, thus fixing the vulnerability.",649,-83.593452866353,-0.12880347128867953
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } // Add bounds checking to ensure length is not less than 0 if (length < 0) { length = 0; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; // Add bounds checking to ensure length is not larger than attribute data size if (length > attr->length) { memcpy ( attr -> data , hashed , attr->length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } } }",607,-37.25746283195797,-0.061379675176207536
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } else if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; if ( ( length - ( i * AUTH_PASS_LEN ) ) < AUTH_PASS_LEN ) { memset ( & hashed [ i * AUTH_PASS_LEN ] , 0 , ( length - ( i * AUTH_PASS_LEN ) ) ) ; break ; } } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",587,-18.12760451804643,-0.030881779417455586
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } length = min(length, MAXPASS); //added line to limit length to MAXPASS memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , min(length, MAXPASS) ) ; } }",546,-19.655971406270716,-0.03599994763053244
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
	
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } if ( length > (256 + AUTH_PASS_LEN) ) { length = (256 + AUTH_PASS_LEN); } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",553,-16.754533856322347,-0.030297529577436432
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , sizeof hashed ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length < sizeof hashed ? length : sizeof hashed ) ; } }",534,-10.592392688902143,-0.019835941364985284
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret) { 
MD5_CTX md5_secret, my_md5; 
unsigned char misc[AUTH_VECTOR_LEN]; 
int i; 
int length = strlen(password); 
int maxLen = length > MAXPASS ? MAXPASS : length; 
if ( (maxLen & (AUTH_PASS_LEN - 1)) != 0 ) { 
maxLen += (AUTH_PASS_LEN - 1); 
maxLen &= ~(AUTH_PASS_LEN - 1); 
}
unsigned char hashed[256 + AUTH_PASS_LEN]; 
unsigned char *vector; 
attribute_t *attr; 
memset(hashed, 0, maxLen); 
memcpy(hashed, password, maxLen); 
attr = find_attribute(request, PW_PASSWORD); 
if (type == PW_PASSWORD) { 
vector = request->vector; 
} else { 
vector = attr->data; 
} 
MD5Init(&md5_secret); 
MD5Update(&md5_secret, (unsigned char *)secret, strlen(secret)); 
my_md5 = md5_secret; 
MD5Update(&my_md5, vector, AUTH_VECTOR_LEN); 
MD5Final(misc, &my_md5); 
xor(hashed, misc, AUTH_PASS_LEN); 
for (i = 1; i < (maxLen >> 4); i++) { 
my_md5 = md5_secret; 
MD5Update(&my_md5, &hashed[(i - 1) * AUTH_PASS_LEN], AUTH_PASS_LEN); 
MD5Final(misc, &my_md5); 
xor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN); 
} 
if (type == PW_OLD_PASSWORD) { 
attr = find_attribute(request, PW_OLD_PASSWORD); 
} 
if (!attr) { 
add_attribute(request, type, hashed, maxLen); 
} else { 
memcpy(attr->data, hashed, maxLen); 
} 
}",558,-36.57880223376001,-0.06555340902107529
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } if (length > 256 + AUTH_PASS_LEN) {length = 256 + AUTH_PASS_LEN;} memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",547,-8.32320992529201,-0.015216105896329086
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:"," 
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { if(length > attr->length){ // add this line to fix the vulnerability length = attr->length; // add this line to fix the vulnerability } memcpy ( attr -> data , hashed , length ) ; } }",557,-25.09170596625756,-0.04504794607945702
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password(AUTH_HDR* request, unsigned char type, CONST char* password, char* secret) {
    MD5_CTX md5_secret, my_md5;
    unsigned char misc[AUTH_VECTOR_LEN];
    int i;
    int length = strlen(password);
    unsigned char hashed[256 + AUTH_PASS_LEN];
    unsigned char* vector;
    attribute_t* attr;

    // Check if length exceeds maximum allowed length
    if (length > MAXPASS) {
        length = MAXPASS;
    }

    // Ensure length is not 0
    if (length == 0) {
        length = AUTH_PASS_LEN;
    }

    // Ensure length is a multiple of 16
    if ((length & (AUTH_PASS_LEN - 1)) != 0) {
        length += (AUTH_PASS_LEN - 1);
        length &= ~(AUTH_PASS_LEN - 1);
    }

    memset(hashed, 0, length);
    memcpy(hashed, password, strlen(password));
    attr = find_attribute(request, PW_PASSWORD);

    if (type == PW_PASSWORD) {
        vector = request->vector;
    } 
    else {
        vector = attr->data;
    }

    MD5Init(&md5_secret);
    MD5Update(&md5_secret, (unsigned char*)secret, strlen(secret));
    my_md5 = md5_secret;
    MD5Update(&my_md5, vector, AUTH_VECTOR_LEN);
    MD5Final(misc, &my_md5);
    xor(hashed, misc, AUTH_PASS_LEN);

    // Iterate through the characters in the hashed password
    for (i = 1; i < (length >> 4); i++) {
        my_md5 = md5_secret;
        MD5Update(&my_md5, &hashed[(i - 1) * AUTH_PASS_LEN], AUTH_PASS_LEN);
        MD5Final(misc, &my_md5);

        // Check if the current character is outside the bounds of the hashed password
        if (i * AUTH_PASS_LEN >= length) {
            break;
        }
        else {
            xor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);
        }
    }

    if (type == PW_OLD_PASSWORD) {
        attr = find_attribute(request, PW_OLD_PASSWORD);
    }

    if (!attr) {
        add_attribute(request, type, hashed, length);
    } 
    else {
        memcpy(attr->data, hashed, length);
    }
}",676,-74.50210430160121,-0.11021021346390711
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; 
if ( ( i + 1 ) * AUTH_PASS_LEN > length ) { break; } }
if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",546,-22.040805246798435,-0.04036777517728651
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , MAXPASS + AUTH_PASS_LEN ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",531,-5.53363124771365,-0.010421151125637759
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; // add this to limit password length // to the maximum value if (length > MAXPASS) { length = MAXPASS; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; // add a check here to make sure that the index is not out of bounds if (i > (length >> 4)) { return; } for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",563,-59.44020307651238,-0.10557762535792609
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; 

//Validate length of password
if ( length > MAXPASS || length < 0) { 
  return; 
}

length = MAX(length, AUTH_PASS_LEN);
if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { 
  length += ( AUTH_PASS_LEN - 1 ) ; 
  length &= ~ ( AUTH_PASS_LEN - 1 ) ; 
} 

memset ( hashed , 0 , length ) ; 
memcpy ( hashed , password , strlen ( password ) ) ; 
attr = find_attribute ( request , PW_PASSWORD ) ; 
if ( type == PW_PASSWORD ) { 
  vector = request -> vector ; 
} else { 
  vector = attr -> data ; 
} 
MD5Init ( & md5_secret ) ; 
MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; 
my_md5 = md5_secret ; 
MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; 
MD5Final ( misc , & my_md5 ) ; 
xor ( hashed , misc , AUTH_PASS_LEN ) ; 
for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { 
  my_md5 = md5_secret ; 
  MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; 
  MD5Final ( misc , & my_md5 ) ; 
  xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; 
} 

//Check for buffer overflow before writing
if (length + sizeof(attr->data) > sizeof(hashed)) { 
  return; 
}

if ( type == PW_OLD_PASSWORD ) { 
  attr = find_attribute ( request , PW_OLD_PASSWORD ) ; 
} 
if ( ! attr ) { 
  add_attribute ( request , type , hashed , length ) ; 
} else { 
  memcpy ( attr -> data , hashed , length ) ; 
} }",646,-59.34558657547898,-0.09186623308897675
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ MAXPASS + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , MAXPASS + AUTH_PASS_LEN ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } memset(hashed, 0, MAXPASS + AUTH_PASS_LEN - length); // Added line }",554,-12.861637823838365,-0.023215952750610766
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","

static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } if ( length > sizeof(hashed)) { length = sizeof(hashed); } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",541,-11.053224660888363,-0.020431099188333388
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; if (length > 256) { memcpy ( hashed , password , 256 ) ; } else { memcpy ( hashed , password , length ) ; } attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }",541,-11.704606152902512,-0.021635131521076732
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } else if (length > AUTH_PASS_LEN){ length = AUTH_PASS_LEN; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { if (length > attr->len) { length = attr->len; } memcpy ( attr -> data , hashed , length ) ; } }",562,-18.693551077158524,-0.03326254640063794
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
Fixed code:","

static void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret) {
    MD5_CTX md5_secret, my_md5;
    unsigned char misc[AUTH_VECTOR_LEN];
    int i;
    int length = strlen(password);
    unsigned char hashed[256 + AUTH_PASS_LEN];
    unsigned char *vector;
    attribute_t *attr;

    // Added code to prevent buffer overflow
    if (length > MAXPASS) {
        length = MAXPASS;
    }
    if (length == 0) {
        length = AUTH_PASS_LEN;
    }
    if ((length & (AUTH_PASS_LEN - 1)) != 0) {
        length += (AUTH_PASS_LEN - 1);
        length &= ~(AUTH_PASS_LEN - 1);
    }

    // Added code to initialize memory
    memset(hashed, 0, length);
    memcpy(hashed, password, strlen(password));

    attr = find_attribute(request, PW_PASSWORD);
    if (type == PW_PASSWORD) {
        vector = request->vector;
    } else {
        vector = attr->data;
    }
    MD5Init(&md5_secret);
    MD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));
    my_md5 = md5_secret;
    MD5Update(&my_md5, vector, AUTH_VECTOR_LEN);
    MD5Final(misc, &my_md5);
    xor(hashed, misc, AUTH_PASS_LEN);

    // Added code to limit the loop
    for (i = 1; i < (length >> 4) && i * AUTH_PASS_LEN < length; i++) {
        my_md5 = md5_secret;
        MD5Update(&my_md5, &hashed[(i - 1) * AUTH_PASS_LEN], AUTH_PASS_LEN);
        MD5Final(misc, &my_md5);
        xor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);
    }
    if (type == PW_OLD_PASSWORD) {
        attr = find_attribute(request, PW_OLD_PASSWORD);
    }
    if (!attr) {
        add_attribute(request, type, hashed, length);
    } else {
        memcpy(attr->data, hashed, length);
    }
}",620,-42.15317247261072,-0.06798898785904955
