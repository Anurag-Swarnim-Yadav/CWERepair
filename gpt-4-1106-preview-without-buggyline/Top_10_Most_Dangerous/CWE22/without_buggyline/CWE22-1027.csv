Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
  if ( func != NULL && * func != '\\0' ) {
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char page[256];
      memset(page, 0, sizeof(page));
      char * page_param = http_request_param_get ( req , ""page"" ) ;
      if ( page_param == NULL ) page_param = http_request_get_query_string ( req ) ;
      if ( page_param && (realpath(page_param, page) != NULL) && ( access ( page , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""%s"" , file_read ( page ) ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        file_write ( page , wikitext ) ;
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char page[256];
      memset(page, 0, sizeof(page));
      char * page_param = http_request_param_get ( req , ""page"" ) ;
      if ( page_param == NULL ) page_param = http_request_get_query_string ( req ) ;
      if ( page_param && (realpath(page_param, page) != NULL) && ( unlink ( page ) > 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char path[256];
      memset(path, 0, sizeof(path));
      char * page_param = http_request_param_get ( req , ""page"" ) ;
      if ( page_param == NULL ) page_param = http_request_get_query_string ( req ) ;
      if ( page_param && (realpath(page_param, path) != NULL) && ( access ( path , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
      pages = wiki_get_pages ( & n_pages , expr ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
        }
        http_response_send ( res ) ;
        return ;
      }
    }
  }
  http_response_set_status ( res , 500 , ""Error"" ) ;
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
  http_response_send ( res ) ;
  return ;
}",988,-39.5700127050871,-0.04005062014684929
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            char * page_path = malloc(strlen(page) + 10); //allocate 10 bytes extra for safety
            strcpy(page_path, ""/wiki/pages/""); //directory containing all pages
            strcat(page_path, page); //append file name
            if ( page && ( access ( page_path , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; 
                http_response_send ( res ) ; 
                free(page_path);
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
                char * page_path = malloc(strlen(page) + 10);
                strcpy(page_path, ""/wiki/pages/""); //directory containing all pages
                strcat(page_path, page); //append file name
                file_write ( page_path , wikitext ) ; 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                free(page_path);
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            char * page_path = malloc(strlen(page) + 10);
            strcpy(page_path, ""/wiki/pages/""); //directory containing all pages
            strcat(page_path, page); //append file name
            if ( page && ( unlink ( page_path ) > 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                free(page_path);
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            char * page_path = malloc(strlen(page) + 10);
            strcpy(page_path, ""/wiki/pages/""); //directory containing all pages
            strcat(page_path, page); //append file name
            if ( page && ( access ( page_path , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                free(page_path);
                return ; 
            } 
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct tm * pTm ; 
                    char datebuf [ 64 ] ; 
                    pTm = localtime ( & pages [ i ] -> mtime ) ; 
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
                    http_response_printf ( res , ""%s\\t%s",1000,-59.73388168730014,-0.05973388168730014
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char fixed_path[PATH_MAX]; if ( page && realpath(page, fixed_path) ) { if ( access ( fixed_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( fixed_path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char fixed_path[PATH_MAX]; if (realpath(page, fixed_path)) { file_write ( fixed_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char fixed_path[PATH_MAX]; if ( page && realpath(page, fixed_path) ) { if ( unlink ( fixed_path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char fixed_path[PATH_MAX]; if ( page && realpath(page, fixed_path) ) { if ( access ( fixed_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",843,-21.32112134815087,-0.025291958894603644
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( realpath(page,NULL) , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( realpath(page,NULL) , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( realpath(page,NULL) ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ;  if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( realpath(page,NULL) , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",773,-20.794266555461668,-0.026900732930739545
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
	if ( func != NULL && * func != '\\0' ) { 
		if ( ! strcmp ( func , ""page/get"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && ( access ( page , R_OK ) == 0 ) ) { 
				// check for valid file name
				if (strstr(page, "".."") == NULL) {
					http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
			} 
		} else if ( ! strcmp ( func , ""page/set"" ) ) { 
			char * wikitext = NULL , * page = NULL ; 
			if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
				// check for valid file name
				if (strstr(page, "".."") == NULL) {
					file_write ( page , wikitext ) ; 
					http_response_printf ( res , ""success"" ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
			} 
		} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && ( unlink ( page ) > 0 ) ) { 
				// check for valid file name
				if (strstr(page, "".."") == NULL) {
					http_response_printf ( res , ""success"" ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
			} 
		} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && ( access ( page , R_OK ) == 0 ) ) { 
				// check for valid file name
				if (strstr(page, "".."") == NULL) {
					http_response_printf ( res , ""success"" ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
			} 
		} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
			WikiPageList * * pages = NULL ; 
			int n_pages , i ; 
			char * expr = http_request_param_get ( req , ""expr"" ) ; 
			if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
			pages = wiki_get_pages ( & n_pages , expr ) ; 
			if ( pages ) { 
				for ( i = 0 ; i < n_pages ; i ++ ) { 
					struct tm * pTm ; 
					char datebuf [ 64 ] ; 
					pTm = localtime ( & pages",1000,-26.110184473703082,-0.026110184473703082
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char dir[] = ""./wiki/pages""; //directory for storing wiki pages char pathname[1024]; //pathname of the supposed file snprintf(pathname, sizeof(pathname), ""%s/%s"", dir, page); if ( page && ( access ( pathname , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( pathname ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char dir[] = ""./wiki/pages""; //directory for storing wiki pages char pathname[1024]; //pathname of the supposed file snprintf(pathname, sizeof(pathname), ""%s/%s"", dir, page); file_write ( pathname , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char dir[] = ""./wiki/pages""; //directory for storing wiki pages char pathname[1024]; //pathname of the supposed file snprintf(pathname, sizeof(pathname), ""%s/%s"", dir, page); if ( page && ( unlink ( pathname ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char dir[] = ""./wiki/pages""; //directory for storing wiki pages char pathname[1024]; //pathname of the supposed file snprintf(pathname, sizeof(pathname), ""%s/%s"", dir, page); if ( page && ( access ( pathname , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",953,-56.178626564552,-0.05894924088620356
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[128]; snprintf(page_path, sizeof(page_path), ""pages/%s"", page); if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char page_path[128]; snprintf(page_path, sizeof(page_path), ""pages/%s"", page); file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[128]; snprintf(page_path, sizeof(page_path), ""pages/%s"", page); if ( page && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[128]; snprintf(page_path, sizeof(page_path), ""pages/%s"", page); if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",870,-15.031645350903837,-0.01727775327690096
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
if ( func != NULL && * func != '\\0' ) {
if ( ! strcmp ( func , ""page/get"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
char * path = build_path(page);
if ( path && ( access ( path , R_OK ) == 0 ) ) {
http_response_printf ( res , ""%s"" , file_read ( path ) ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""page/set"" ) ) {
char * wikitext = NULL , * page = NULL ;
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
char * path = build_path(page);
file_write ( path , wikitext ) ;
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""page/delete"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
char * path = build_path(page);
if ( path && ( unlink ( path ) > 0 ) ) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""page/exists"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
char * path = build_path(page);
if ( path && ( access ( path , R_OK ) == 0 ) ) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
WikiPageList * * pages = NULL ;
int n_pages , i ;
char * expr = http_request_param_get ( req , ""expr"" ) ;
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
pages = wiki_get_pages ( & n_pages , expr ) ;
if ( pages ) {
for ( i = 0 ; i < n_pages ; i ++ ) {
struct tm * pTm ;
char datebuf [ 64 ] ;
pTm = localtime ( & pages [ i ] -> mtime ) ;
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
}
http_response_send ( res ) ;
return ;
}
}
}
http_response_set_status ( res , 500 , ""Error"" ) ;
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
http_response_send ( res ) ;
return ;
}

char * build_path(char * page) {
char * path = malloc(MAX_PATH_LENGTH);
strncpy(path, ""./pages/"", MAX_PATH_LENGTH);
strncat(path, page, MAX_PATH_LENGTH);
return path;
}",918,-36.52631469011058,-0.03978901382364987
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && ( access ( page , R_OK ) == 0 ) ) {
char file_path[1024]; //declaring size of file path
snprintf(file_path, sizeof(file_path), ""./pages/%s"", page); //concatenating the file path
if (access(file_path, R_OK) == 0) { //checking if file path is valid
http_response_printf ( res , ""%s"" , file_read ( file_path ) ) ; //reading the file from the updated file path
http_response_send ( res ) ; 
return ; 
}
}
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
char file_path[1024]; 
snprintf(file_path, sizeof(file_path), ""./pages/%s"", page); //concatenating the file path
if (access(file_path, R_OK) == 0) { //checking if file path is valid
file_write ( file_path , wikitext ) ; //writing the file to the updated file path
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
}
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
char file_path[1024]; 
snprintf(file_path, sizeof(file_path), ""./pages/%s"", page); //concatenating the file path
if ( page && ( unlink ( file_path ) > 0 ) ) { //unlinking the file path
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
char file_path[1024]; 
snprintf(file_path, sizeof(file_path), ""./pages/%s"", page); //concatenating the file path
if ( page && ( access ( file_path , R_OK ) == 0 ) ) { //checking if file path is valid
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf (",1000,-83.82450305887866,-0.08382450305887866
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char * filePath = realpath(page, NULL); //add to fix if (filePath) { http_response_printf ( res , ""%s"" , file_read ( filePath ) ) ; http_response_send ( res ) ; free(filePath); //add to fix return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * filePath = realpath(page, NULL); //add to fix if (filePath) { file_write ( filePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(filePath); //add to fix return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * filePath = realpath(page, NULL); //add to fix if ( filePath && ( unlink ( filePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(filePath); //add to fix return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * filePath = realpath(page, NULL); //add to fix if ( filePath && ( access ( filePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(filePath); //add to fix return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",868,-28.830269426589503,-0.03321459611358238
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { page = realpath(page, NULL); http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { page = realpath(page, NULL); file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page = realpath(page, NULL); if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page = realpath(page, NULL); if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",784,-8.827547308500339,-0.011259626669005535
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","

void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
  if ( func != NULL && * func != '\\0' ) {
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;

      // Verify that the path is contained within the restricted directory
      char pagePath[strlen(page) + 1];
      realpath(page, pagePath);
      if (strncmp(pagePath, ""/restricted/folder/"", 18) == 0 && access ( page , R_OK ) == 0 ) {
        http_response_printf ( res , ""%s"" , file_read ( page ) ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        // Verify that the path is contained within the restricted directory
        char pagePath[strlen(page) + 1];
        realpath(page, pagePath);
        if (strncmp(pagePath, ""/restricted/folder/"", 18) == 0) {
          file_write ( page , wikitext ) ;
          http_response_printf ( res , ""success"" ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      // Verify that the path is contained within the restricted directory
      char pagePath[strlen(page) + 1];
      realpath(page, pagePath);
      if (strncmp(pagePath, ""/restricted/folder/"", 18) == 0 && unlink ( page ) > 0 ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      // Verify that the path is contained within the restricted directory
      char pagePath[strlen(page) + 1];
      realpath(page, pagePath);
      if (strncmp(pagePath, ""/restricted/folder/"", 18) == 0 && access ( page , R_OK ) == 0 ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
      pages = wiki_get_pages ( & n_pages , expr ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
        }
        http_response_send (",1000,-58.368567499385954,-0.05836856749938595
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[512]; // Declare a character array of length 512 snprintf(page_path, 512, ""path/to/safe/dir/%s"", page); // Construct a safe path within the restricted directory if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char page_path[512]; // Declare a character array of length 512 snprintf(page_path, 512, ""path/to/safe/dir/%s"", page); // Construct a safe path within the restricted directory file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[512]; // Declare a character array of length 512 snprintf(page_path, 512, ""path/to/safe/dir/%s"", page); // Construct a safe path within the restricted directory if ( page && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[512]; // Declare a character array of length 512 snprintf(page_path, 512, ""path/to/safe/dir/%s"", page); // Construct a safe path within the restricted directory if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",950,-44.56357684469047,-0.046909028257568916
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[1024]; snprintf(path, sizeof(path), ""./%s"", page);  if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[1024]; snprintf(path, sizeof(path), ""./%s"", page); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[1024]; snprintf(path, sizeof(path), ""./%s"", page); if ( unlink ( path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[1024]; snprintf(path, sizeof(path), ""./%s"", page); if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",839,-17.056716653780544,-0.020329817227390398
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page ) {
				// check if page is within the allowed web folder
				char pagePath[1024];
				snprintf(pagePath, 1024, ""/var/www/wiki/%s"", page);
				if ( access ( pagePath , R_OK ) == 0 ) { 
					http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
            }
        } else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
				// check if page is within the allowed web folder
				char pagePath[1024];
				snprintf(pagePath, 1024, ""/var/www/wiki/%s"", page);
				if ( access ( pagePath , R_OK ) == 0 ) { 
					file_write ( page , wikitext ) ; 
					http_response_printf ( res , ""success"" ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
            } 
        } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page ) {
				// check if page is within the allowed web folder
				char pagePath[1024];
				snprintf(pagePath, 1024, ""/var/www/wiki/%s"", page);
				if ( access ( pagePath , R_OK ) == 0 && unlink ( page ) > 0 ) { 
					http_response_printf ( res , ""success"" ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
            } 
        } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page ) {
				// check if page is within the allowed web folder
				char pagePath[1024];
				snprintf(pagePath, 1024, ""/var/www/wiki/%s"", page);
				if ( access ( pagePath , R_OK ) == 0 ) { 
					http_response_printf ( res , ""success"" ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
            } 
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages =",1000,-60.556190790571186,-0.06055619079057119
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { 
//add a white list of acceptable pages 
char * whitelist[] = {""page1.txt"", ""page2.txt"", ""page3.txt""}; 
bool inWhitelist = false; 
for(int i = 0; i < sizeof(whitelist) / sizeof(whitelist[0]); i++) { 
if(strcmp(whitelist[i], page) == 0) { 
inWhitelist = true; 
break; 
} 
} 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && ( access ( page , R_OK ) == 0 ) && inWhitelist) { 
http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) && 
inWhitelist) { 
file_write ( page , wikitext ) ; 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && ( unlink ( page ) > 0 ) && inWhitelist) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && ( access ( page , R_OK ) == 0 ) && inWhitelist) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_send ( res ) ; 
return ; 
} 
} 
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
http_response_send ( res ) ; 
return ; 
}",990,-61.74096984006985,-0.06236461600007056
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call (HttpRequest * req , HttpResponse * res , char * func ) {
if ( func != NULL && * func != '\\0' ) {
 if ( ! strcmp ( func , ""page/get"" ) ) {
 char * page = http_request_param_get ( req , ""page"" ) ;
 if ( page == NULL ) page = http_request_get_query_string ( req ) ;
 if ( page ) {
 char file_path[MAX_PATH_LENGTH] = ""restrictive_path/"";
 strcat (file_path, page);
 if ( access ( file_path , R_OK ) == 0 ) {
 http_response_printf ( res , ""%s"" , file_read ( file_path ) ) ;
 http_response_send ( res ) ;
 return ;
 }
 }
 } else if ( ! strcmp ( func , ""page/set"" ) ) {
 char * wikitext = NULL , * page = NULL ;
 if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
 char file_path[MAX_PATH_LENGTH] = ""restrictive_path/"";
 strcat (file_path, page);
 file_write ( file_path , wikitext ) ;
 http_response_printf ( res , ""success"" ) ;
 http_response_send ( res ) ;
 return ;
 }
 } else if ( ! strcmp ( func , ""page/delete"" ) ) {
 char * page = http_request_param_get ( req , ""page"" ) ;
 if ( page == NULL ) page = http_request_get_query_string ( req ) ;
 if ( page ) {
 char file_path[MAX_PATH_LENGTH] = ""restrictive_path/"";
 strcat (file_path, page);
 if ( unlink ( file_path ) > 0 ) {
 http_response_printf ( res , ""success"" ) ;
 http_response_send ( res ) ;
 return ;
 }
 }
 } else if ( ! strcmp ( func , ""page/exists"" ) ) {
 char * page = http_request_param_get ( req , ""page"" ) ;
 if ( page == NULL ) page = http_request_get_query_string ( req ) ;
 if ( page ) {
 char file_path[MAX_PATH_LENGTH] = ""restrictive_path/"";
 strcat (file_path, page);
 if ( access ( file_path , R_OK ) == 0 ) {
 http_response_printf ( res , ""success"" ) ;
 http_response_send ( res ) ;
 return ;
 }
 }
 } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
 WikiPageList * * pages = NULL ;
 int n_pages , i ;
 char * expr = http_request_param_get ( req , ""expr"" ) ;
 if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
 pages = wiki_get_pages ( & n_pages , expr ) ;
 if ( pages ) {
 for ( i = 0 ; i < n_pages ; i ++ ) {
 char file_path[MAX_PATH_LENGTH] = ""restrictive_path/"";
 strcat (file_path, pages[i]->name);
 if ( access ( file_path , R_OK ) == 0 ) {
 struct tm * pTm ;
 char datebuf [ 64 ] ;
 pTm = localtime ( & pages [ i ] -> mtime ) ;
 strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
 http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
 }
 }
 http_response_send ( res ) ;
 return ;
 }
 }
}
http_response_set_status ( res , 500 , ""Error"" ) ;
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
http_response_",1000,-49.70197139414628,-0.049701971394146276
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page ) {
                char full_path[FILENAME_MAX];
                snprintf(full_path , FILENAME_MAX , ""%s%s"", get_pages_path(), page);
                if (( access ( full_path , R_OK ) == 0 ) ) { 
                    http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            }
        } else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
                char full_path[FILENAME_MAX];
                snprintf(full_path , FILENAME_MAX , ""%s%s"", get_pages_path(), page);
                file_write ( full_path , wikitext ) ; 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page ) {
                char full_path[FILENAME_MAX];
                snprintf(full_path , FILENAME_MAX , ""%s%s"", get_pages_path(), page);
                if (( unlink ( full_path ) > 0 ) ) { 
                    http_response_printf ( res , ""success"" ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            }
        } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page ) {
                char full_path[FILENAME_MAX];
                snprintf(full_path , FILENAME_MAX , ""%s%s"", get_pages_path(), page);
                if (( access ( full_path , R_OK ) == 0 ) ) { 
                    http_response_printf ( res , ""success"" ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            }
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct tm * pTm ; 
                    char datebuf [ 64 ] ; 
                    pTm = localtime ( & pages [ i ] -> mtime ) ; 
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
                    http_response_printf ( res , ""%s\\t%s\\n""",1000,-41.38918573636768,-0.04138918573636768
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char path[256]; if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( path_append(""/var/www/wiki/files"", page, path, 256) && ( access ( path , R_OK ) == 0 ) ) ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { if (path_append(""/var/www/wiki/files"", page, path, 256)) { file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( path_append(""/var/www/wiki/files"", page, path, 256) && ( unlink ( path ) > 0 ) ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( path_append(""/var/www/wiki/files"", page, path, 256) && ( access ( path , R_OK ) == 0 ) ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The vulnerability has been fixed by using a path_append function to limit the file paths to the /var/www/wiki/files directory. This ensures that any requests are limited to this directory and are not able to traverse outside of it.",892,-78.66275752819553,-0.08818694790156449
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char absolute_path[PATH_MAX]; realpath(page, absolute_path); http_response_printf ( res , ""%s"" , file_read ( absolute_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char absolute_path[PATH_MAX]; realpath(page, absolute_path); file_write ( absolute_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { char absolute_path[PATH_MAX]; realpath(page, absolute_path); unlink ( absolute_path ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char absolute_path[PATH_MAX]; realpath(page, absolute_path); if ( access ( absolute_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; char absolute_path[PATH_MAX]; realpath(pages[i]->name, absolute_path); pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , absolute_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",869,-16.034110240442043,-0.018451220069553558
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { 
char page_path[256];
snprintf(page_path, sizeof(page_path), ""%s/%s"", RESTRICTED_DIR, page);
if ( access ( page_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
char page_path[256];
snprintf(page_path, sizeof(page_path), ""%s/%s"", RESTRICTED_DIR, page);
file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page ) {
char page_path[256];
snprintf(page_path, sizeof(page_path), ""%s/%s"", RESTRICTED_DIR, page);
if ( unlink ( page_path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) {
char page_path[256];
snprintf(page_path, sizeof(page_path), ""%s/%s"", RESTRICTED_DIR, page);
if ( access ( page_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
char page_path[256];
snprintf(page_path, sizeof(page_path), ""%s/%s"", RESTRICTED_DIR, pages[i]->name);
http_response_printf ( res , ""%s\\t%s\\n"" , page_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",961,-28.5958698859617,-0.029756368247618837
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * page_path = get_absolute_path ( page ) ; if ( ! strcmp ( func , ""page/get"" ) ) { if ( page_path && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page_path = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { if ( page_path && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { if ( page_path && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

// Function to get the absolute path
char *get_absolute_path(char *page) {
  char *path = realpath(page, NULL);
  return path;
}",744,-36.53689722214368,-0.04910873282546194
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Validate the page path before access if(page && validate_page_path(page) && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { //Validate the page path before writing if (validate_page_path(page)){ file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Validate the page path before deleting if (page && validate_page_path(page) && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Validate the page path before checking if (page && validate_page_path(page) && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

//Validate the page path to prevent Path Traversal
bool validate_page_path(char *page_path){
    char base_dir[MAX_PATH_LEN];
    getcwd(base_dir, MAX_PATH_LEN);
    if (realpath(page_path, NULL) == NULL || !strstr(realpath(page_path, NULL), base_dir)){
        return false;
    }
    return true;
}",928,-72.81450065357045,-0.07846390156634747
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * page_path = ""./pages/""; strcat(page_path, page); if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * page_path = ""./pages/""; strcat(page_path, page); file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * page_path = ""./pages/""; strcat(page_path, page); if ( page && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * page_path = ""./pages/""; strcat(page_path, page); if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",838,-15.23285415053343,-0.01817763025123321
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char page_name[MAX_PATH_LENGTH];
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

/* Removed the vulnerable code and added code to check the path length and prevent path traversal */
if(strlen(page) > MAX_PATH_LENGTH) {
  http_response_set_status ( res , 500 , ""Error"" ) ; 
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
  http_response_send (res);
  return;
}

strcpy(page_name, ""docs/pages/"");
strcat(page_name, page);

if ( access ( page_name , R_OK ) == 0 ) { 
http_response_printf ( res , ""%s"" , file_read ( page_name ) ) ; 
http_response_send ( res ) ; 
return ; 
} 
} 

else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) 
    && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 

/* Removed the vulnerable code and added code to check the path length and prevent path traversal */
if(strlen(page) > MAX_PATH_LENGTH) {
  http_response_set_status ( res , 500 , ""Error"" ) ; 
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
  http_response_send (res);
  return;
}

char page_name[MAX_PATH_LENGTH];
strcpy(page_name, ""docs/pages/"");
strcat(page_name, page);
file_write ( page_name , wikitext ) ; 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} 

else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

/* Removed the vulnerable code and added code to check the path length and prevent path traversal */
if(strlen(page) > MAX_PATH_LENGTH) {
  http_response_set_status ( res , 500 , ""Error"" ) ; 
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
  http_response_send (res);
  return;
}

char page_name[MAX_PATH_LENGTH];
strcpy(page_name, ""docs/pages/"");
strcat(page_name, page);

if ( page && ( unlink ( page_name ) > 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} 

else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

/* Removed the vulnerable code and added code to check the path length and prevent path traversal */
if(strlen(page) > MAX_PATH_LENGTH) {
  http_response_set_status ( res , 500 , ""Error"" ) ; 
  http_response_printf ( res , ""<html><body>Failed</body></html>",1000,-100.266262682451,-0.100266262682451
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[256]; snprintf(page_path, sizeof(page_path), ""/path/to/pages/%s"", page); if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char page_path[256]; snprintf(page_path, sizeof(page_path), ""/path/to/pages/%s"", page); file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[256]; snprintf(page_path, sizeof(page_path), ""/path/to/pages/%s"", page); if ( page && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[256]; snprintf(page_path, sizeof(page_path), ""/path/to/pages/%s"", page); if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char page_path[256]; snprintf(page_path, sizeof(page_path), ""/path/to/pages/%s"", pages[i]->name); http_response_printf ( res , ""%s\\t%s\\n"" , page_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",920,-15.59334954096309,-0.016949292979307706
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char real_path[1024];
realpath(page, real_path);
if ( page && ( access ( real_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( real_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char real_path[1024];
realpath(page, real_path);
file_write ( real_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char real_path[1024];
realpath(page, real_path);
if ( page && ( unlink ( real_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char real_path[1024];
realpath(page, real_path);
if ( page && ( access ( real_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The vulnerability has been fixed by using the realpath() function. This function takes a pathname and resolves it to an absolute pathname, taking into account any symbolic links. This ensures that the path will be limited to the valid directory.",880,-56.250675694648336,-0.0639212223802822
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * absolute_path = get_absolute_path(page); if ( access ( absolute_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( absolute_path ) ) ; free(absolute_path); http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * absolute_path = get_absolute_path(page); file_write ( absolute_path , wikitext ) ; free(absolute_path); http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * absolute_path = get_absolute_path(page); if ( unlink ( absolute_path ) > 0 ) { free(absolute_path); http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * absolute_path = get_absolute_path(page); if ( access ( absolute_path , R_OK ) == 0 ) { free(absolute_path); http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } 

//get_absolute_path is a function that creates an absolute path from the given relative page name
char* get_absolute_path(char* page){
    char absolute_path[1024] = """";
    //Create an absolute path from the relative page name
    strcat(absolute_path, ""/restricted/path/"");
    strcat(absolute_path, page);
    char* absolute_path_cpy = (char*)malloc(strlen(absolute_path) + 1);
    strcpy(absolute_path_cpy, absolute_path);
    return absolute_path_cpy;
}",987,-86.39790321379672,-0.08753586951752454
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { // Check page to make sure it is real and not malicious char realPath[1024]; realpath(page, realPath); // Check if the real path is within the restricted directory if (strncmp(realPath, ""/my/safe/directory/"", strlen(""/my/safe/directory/"")) == 0 && ( access ( realPath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( realPath ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { // Check page to make sure it is real and not malicious char realPath[1024]; realpath(page, realPath); // Check if the real path is within the restricted directory if (strncmp(realPath, ""/my/safe/directory/"", strlen(""/my/safe/directory/"")) == 0) { file_write ( realPath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Check page to make sure it is real and not malicious char realPath[1024]; realpath(page, realPath); // Check if the real path is within the restricted directory if (strncmp(realPath, ""/my/safe/directory/"", strlen(""/my/safe/directory/"")) == 0 && ( unlink ( realPath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Check page to make sure it is real and not malicious char realPath[1024]; realpath(page, realPath); // Check if the real path is within the restricted directory if (strncmp(realPath, ""/my/safe/directory/"", strlen(""/my/safe/directory/"")) == 0 && ( access ( realPath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</",1000,-64.94631080129335,-0.06494631080129334
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char page_safe[256]={0}; if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if(page){ //sanitize input for path traversal strncpy(page_safe, page, 256); if ( access ( page_safe , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( page_safe ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { //sanitize input for path traversal strncpy(page_safe, page, 256); file_write ( page_safe , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if(page){ //sanitize input for path traversal strncpy(page_safe, page, 256); if ( unlink ( page_safe ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if(page){ //sanitize input for path traversal strncpy(page_safe, page, 256); if ( access ( page_safe , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",856,-46.67278814974847,-0.05452428522166877
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char pagePath[PATH_MAX]; realpath(page, pagePath); if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char pagePath[PATH_MAX]; realpath(page, pagePath); file_write ( pagePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char pagePath[PATH_MAX]; realpath(page, pagePath); if ( page && ( unlink ( pagePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char pagePath[PATH_MAX]; realpath(page, pagePath); if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",817,-10.028575611302795,-0.012274878349207827
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char path[1024]; realpath(page, path); http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[1024]; realpath(page, path); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[1024]; realpath(page, path); if ( page && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[1024]; realpath(page, path); if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The vulnerability has been fixed by adding the realpath() function to the code. The realpath() function resolves a given pathname and returns the absolute pathname. This ensures that any malicious attempts to traverse directories outside the restricted directory are blocked.",847,-46.31064922544827,-0.054676091175263605
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
	if ( func != NULL && * func != '\\0' ) { 
		if ( ! strcmp ( func , ""page/get"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

			//Fix the CWE-22 vulnerability
			//Get the absolute path of the file
			char file_path[1024];
			realpath(page, file_path);
			if ( page && ( access ( file_path , R_OK ) == 0 ) ) {
				http_response_printf ( res , ""%s"" , file_read ( file_path ) ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""page/set"" ) ) { 
			char * wikitext = NULL , * page = NULL ; 
			if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
				//Fix the CWE-22 vulnerability
				//Get the absolute path of the file
				char file_path[1024];
				realpath(page, file_path);
				file_write ( file_path , wikitext ) ; 
				http_response_printf ( res , ""success"" ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

			//Fix the CWE-22 vulnerability
			//Get the absolute path of the file
			char file_path[1024];
			realpath(page, file_path);
			if ( page && ( unlink ( file_path ) > 0 ) ) { 
				http_response_printf ( res , ""success"" ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			
			//Fix the CWE-22 vulnerability
			//Get the absolute path of the file
			char file_path[1024];
			realpath(page, file_path);
			if ( page && ( access ( file_path , R_OK ) == 0 ) ) { 
				http_response_printf ( res , ""success"" ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
			WikiPageList * * pages = NULL ; 
			int n_pages , i ; 
			char * expr = http_request_param_get ( req , ""expr"" ) ; 
			if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
			pages = wiki_get_pages ( & n_pages , expr ) ; 
			if ( pages ) { 
				for ( i = 0 ; i < n",1000,-45.269996704514405,-0.045269996704514405
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[MAX_PATH] = """"; snprintf(path, MAX_PATH, ""%s/%s"", ""pages"", page); if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[MAX_PATH] = """";snprintf(path, MAX_PATH, ""%s/%s"", ""pages"", page); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[MAX_PATH] = """"; snprintf(path, MAX_PATH, ""%s/%s"", ""pages"", page); if ( unlink ( path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[MAX_PATH] = """"; snprintf(path, MAX_PATH, ""%s/%s"", ""pages"", page); if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""pages/%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",877,-35.09708944163568,-0.04001948625043977
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
    if ( func != NULL && * func != '\\0' ) {
        if ( ! strcmp ( func , ""page/get"" ) ) {
            char * page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            page = realpath(page, NULL);
            if ( page && ( access ( page , R_OK ) == 0 ) ) {
                http_response_printf ( res , ""%s"" , file_read ( page ) ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/set"" ) ) {
            char * wikitext = NULL , * page = NULL ;
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
                page = realpath(page, NULL);
                file_write ( page , wikitext ) ;
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/delete"" ) ) {
            char * page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            page = realpath(page, NULL);
            if ( page && ( unlink ( page ) > 0 ) ) {
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/exists"" ) ) {
            char * page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            page = realpath(page, NULL);
            if ( page && ( access ( page , R_OK ) == 0 ) ) {
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
            WikiPageList * * pages = NULL ;
            int n_pages , i ;
            char * expr = http_request_param_get ( req , ""expr"" ) ;
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
            pages = wiki_get_pages ( & n_pages , expr ) ;
            if ( pages ) {
                for ( i = 0 ; i < n_pages ; i ++ ) {
                    struct tm * pTm ;
                    char datebuf [ 64 ] ;
                    pTm = localtime ( & pages [ i ] -> mtime ) ;
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
                }
                http_response_send ( res ) ;
                return ;
            }
        }
    }
    http_response_set_status ( res , 500 , ""Error"" ) ;
    http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
    http_response_send ( res ) ;
    return ;
}",905,-11.640225659902844,-0.012862127800997618
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
 if ( func != NULL && * func != '\\0' ) { 
     if ( ! strcmp ( func , ""page/get"" ) ) { 
         char * page = http_request_param_get ( req , ""page"" ) ; 
		 if ( page == NULL ) page = http_request_get_query_string ( req ) ;
		 char dirname[1024];
		 realpath(page, dirname);
		 if ( page && ( access ( dirname , R_OK ) == 0 ) ) {
		    http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
			http_response_send ( res ) ; 
			return ; 
		 } 
	 } 
	 else if ( ! strcmp ( func , ""page/set"" ) ) { 
	    char * wikitext = NULL , * page = NULL ; 
		if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
		    char dirname[1024];
		    realpath(page, dirname);
		    file_write ( dirname , wikitext ) ; 
			http_response_printf ( res , ""success"" ) ; 
			http_response_send ( res ) ; 
			return ; 
		} 
	} 
	else if ( ! strcmp ( func , ""page/delete"" ) ) { 
	    char * page = http_request_param_get ( req , ""page"" ) ; 
		if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
        char dirname[1024];
		realpath(page, dirname);
		if ( page && ( unlink ( dirname ) > 0 ) ) { 
		    http_response_printf ( res , ""success"" ) ; 
			http_response_send ( res ) ; 
			return ; 
		} 
	} 
	else if ( ! strcmp ( func , ""page/exists"" ) ) { 
	    char * page = http_request_param_get ( req , ""page"" ) ; 
		if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
		char dirname[1024];
		realpath(page, dirname);
		if ( page && ( access ( dirname , R_OK ) == 0 ) ) { 
		    http_response_printf ( res , ""success"" ) ; 
			http_response_send ( res ) ; 
			return ; 
		} 
	} 
	else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
	    WikiPageList * * pages = NULL ; 
		int n_pages , i ; 
		char * expr = http_request_param_get ( req , ""expr"" ) ; 
		if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
		pages = wiki_get_pages ( & n_pages , expr ) ; 
		if ( pages ) { 
		    for ( i = 0 ; i < n_pages ; i ++ ) { 
			    struct tm * pTm ; 
				char datebuf [ 64 ] ; 
				pTm = localtime ( & pages [ i ] -> mtime ) ; 
				strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
				http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
			} 
			http_response_send ( res ) ; 
			return ;",1000,-54.96090727638849,-0.05496090727638849
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * allowed_path = realpath(page, NULL); if ( page && ( access ( allowed_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( allowed_path ) ) ; http_response_send ( res ) ; free(allowed_path); return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * allowed_path = realpath(page, NULL); file_write ( allowed_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(allowed_path); return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * allowed_path = realpath(page, NULL); if ( page && ( unlink ( allowed_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(allowed_path); return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * allowed_path = realpath(page, NULL); if ( page && ( access ( allowed_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(allowed_path); return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",834,-15.617758356349011,-0.018726328964447255
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && page[0] != '/' ) { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } char full_path[1024]; realpath(page, full_path); if ( ! strcmp ( func , ""page/get"" ) ) { if ( full_path && ( access ( full_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( full_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { if ( full_path && ( unlink ( full_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { if ( full_path && ( access ( full_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",768,-27.91704482550119,-0.036350318783204674
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
 if ( func != NULL && * func != '\\0' ) { 
    if ( ! strcmp ( func , ""page/get"" ) ) { 
      char filePath[256] = """";
      strcat(filePath, ""./pages/"");
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      strcat(filePath, page);
      if ( access ( filePath , R_OK ) == 0 ) { 
          http_response_printf ( res , ""%s"" , file_read ( filePath ) ) ; 
          http_response_send ( res ) ; 
          return ; 
      } 
    } else if ( ! strcmp ( func , ""page/set"" ) ) { 
      char * wikitext = NULL , * page = NULL ; 
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
        char filePath[256] = """";
        strcat(filePath, ""./pages/"");
        strcat(filePath, page);
        file_write ( filePath , wikitext ) ; 
        http_response_printf ( res , ""success"" ) ; 
        http_response_send ( res ) ; 
        return ; 
      } 
    } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      char filePath[256] = """";
      strcat(filePath, ""./pages/"");
      strcat(filePath, page);
      if ( page && ( unlink ( filePath ) > 0 ) ) { 
        http_response_printf ( res , ""success"" ) ; 
        http_response_send ( res ) ; 
        return ; 
      } 
    } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      char filePath[256] = """";
      strcat(filePath, ""./pages/"");
      strcat(filePath, page);
      if ( page && ( access ( filePath , R_OK ) == 0 ) ) { 
        http_response_printf ( res , ""success"" ) ; 
        http_response_send ( res ) ; 
        return ;
      } 
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
      WikiPageList * * pages = NULL ; 
      int n_pages , i ; 
      char * expr = http_request_param_get ( req , ""expr"" ) ; 
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
      pages = wiki_get_pages ( & n_pages , expr ) ; 
      if ( pages ) { 
        for ( i = 0 ; i < n_pages ; i ++ ) { 
          struct tm * pTm ; 
          char datebuf [ 64 ] ; 
          char filePath[256] = """";
          strcat(filePath, ""./pages/"");
          strcat(filePath, pages[i]->name);
          pTm = localtime ( & pages [ i ] -> mtime ) ; 
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
          http_response_printf ( res , ""%s\\t%s\\n"" , filePath , datebuf ) ; 
        } 
        http_response_send (",1000,-50.53324521140778,-0.05053324521140778
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( get_absolute_path(page), R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( get_absolute_path(page), wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( get_absolute_path(page) ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( get_absolute_path(page), R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

//Function to get absolute path
char* get_absolute_path(char* page) {
  char cwd[1024];
  getcwd(cwd, sizeof(cwd));
  strcat(cwd, ""/"");
  strcat(cwd, page);
  return cwd;
}",845,-24.816645651264697,-0.029368811421615026
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // FIX: Sanitize and limit the path to a restricted directory containing files that should be accessible if ( page && ( access ( page , R_OK ) == 0 ) && ( strstr ( page , ""../"" ) == NULL ) ) { page = realpath ( page , NULL ) ; http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { // FIX: Sanitize and limit the path to a restricted directory containing files that should be writable page = realpath ( page , NULL ) ; file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // FIX: Sanitize and limit the path to a restricted directory containing files that should be deletable if ( page && ( unlink ( page ) > 0 ) && ( strstr ( page , ""../"" ) == NULL ) ) { page = realpath ( page , NULL ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // FIX: Sanitize and limit the path to a restricted directory containing files that should be accessible if ( page && ( access ( page , R_OK ) == 0 ) && ( strstr ( page , ""../"" ) == NULL ) ) { page = realpath ( page , NULL ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; // FIX: Sanitize and limit the path to a restricted directory containing files that should be accessible if ( expr && ( strstr ( expr , ""../"" ) == NULL ) ) { pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",952,-65.34887523825839,-0.06864377651077562
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

// Add this line to check for path traversal 
if (strstr(page, "".."") == NULL){
if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {

// And this line too 
if (strstr(page, "".."") == NULL){
file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

// This line also 
if (strstr(page, "".."") == NULL){
if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

// And this one 
if (strstr(page, "".."") == NULL){
if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",846,-56.65459902704263,-0.0669676111430764
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { //Check if the page is located in a defined directory 
if(strncmp(page, ""/path/to/defined/directory/"", 26) == 0) {
http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ;
}
} } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { //Check if the page is located in a defined directory 
if(strncmp(page, ""/path/to/defined/directory/"", 26) == 0) {
file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ;
}
} } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Check if the page is located in a defined directory 
if(strncmp(page, ""/path/to/defined/directory/"", 26) == 0) {
if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ;
}
}
} else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Check if the page is located in a defined directory 
if(strncmp(page, ""/path/to/defined/directory/"", 26) == 0) {
if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ;
}
}
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",914,-46.722682597876414,-0.051118908750411834
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[256]; snprintf(path, 256, ""pages/%s"", page); if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[256]; snprintf(path, 256, ""pages/%s"", page); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[256]; snprintf(path, 256, ""pages/%s"", page); if ( page && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[256]; snprintf(path, 256, ""pages/%s"", page); if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",828,-11.914685161886768,-0.0143897163790903
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[1024]; 
strcpy(path, ""/home/wiki/pages/""); 
strcat(path, page); 
if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[1024]; 
strcpy(path, ""/home/wiki/pages/""); 
strcat(path, page); 
file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[1024]; 
strcpy(path, ""/home/wiki/pages/""); 
strcat(path, page); 
if ( page && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[1024]; 
strcpy(path, ""/home/wiki/pages/""); 
strcat(path, page); 
if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",876,-18.050160103130583,-0.020605205597181032
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char full_path[256]; snprintf(full_path, sizeof full_path, ""/var/www/wiki/pages/%s"", page); if ( page && ( access ( full_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char full_path[256]; snprintf(full_path, sizeof full_path, ""/var/www/wiki/pages/%s"", page); file_write ( full_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char full_path[256]; snprintf(full_path, sizeof full_path, ""/var/www/wiki/pages/%s"", page); if ( page && ( unlink ( full_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char full_path[256]; snprintf(full_path, sizeof full_path, ""/var/www/wiki/pages/%s"", page); if ( page && ( access ( full_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char full_path[256]; snprintf(full_path, sizeof full_path, ""/var/www/wiki/pages/%s"", pages[i]->name); http_response_printf ( res , ""%s\\t%s\\n"" , full_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",925,-20.567464353243995,-0.022235096598101616
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filePath[MAX_PATH]; snprintf(filePath, MAX_PATH,""%s/%s"", RESTRICTED_DIRECTORY, page); if ( page && ( access ( filePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( filePath ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char filePath[MAX_PATH]; snprintf(filePath, MAX_PATH,""%s/%s"", RESTRICTED_DIRECTORY, page); file_write ( filePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filePath[MAX_PATH]; snprintf(filePath, MAX_PATH,""%s/%s"", RESTRICTED_DIRECTORY, page); if ( page && ( unlink ( filePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filePath[MAX_PATH]; snprintf(filePath, MAX_PATH,""%s/%s"", RESTRICTED_DIRECTORY, page); if ( page && ( access ( filePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",893,-21.511619479629243,-0.024089159551656487
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char full_path[MAX_PATH_LEN]; if (snprintf(full_path, MAX_PATH_LEN, ""%s/%s"", RESTRICTED_DIR_PATH, page) < 0) { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } else if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char full_path[MAX_PATH_LEN]; if (snprintf(full_path, MAX_PATH_LEN, ""%s/%s"", RESTRICTED_DIR_PATH, page) < 0) { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } else { file_write ( full_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char full_path[MAX_PATH_LEN]; if (snprintf(full_path, MAX_PATH_LEN, ""%s/%s"", RESTRICTED_DIR_PATH, page) < 0) { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } else if ( unlink ( full_path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char full_path[MAX_PATH_LEN]; if (snprintf(full_path, MAX_PATH_LEN, ""%s/%s"", RESTRICTED_DIR_PATH, page) < 0) { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } else if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if",1000,-27.213576602053443,-0.027213576602053445
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char * page_path; if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page_path = directory_get(page); if ( page_path && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { page_path = directory_get(page); file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page_path = directory_get(page); if ( page_path && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page_path = directory_get(page); if ( page_path && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; page_path = directory_get(pages[i]->name); http_response_printf ( res , ""%s\\t%s\\n"" , page_path, datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

//The directory_get() function should take the input page name and resolve it to a valid, absolute path within the restricted directory.",851,-59.58972030605226,-0.07002317309759372
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * abs_path = get_abs_path ( page ) ; if ( access ( abs_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( abs_path ) ) ; http_response_send ( res ) ; free ( abs_path ) ; return ; } free ( abs_path ) ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * abs_path = get_abs_path ( page ) ; file_write ( abs_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( abs_path ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * abs_path = get_abs_path ( page ) ; if ( unlink ( abs_path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( abs_path ) ; return ; } free ( abs_path ) ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * abs_path = get_abs_path ( page ) ; if ( access ( abs_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( abs_path ) ; return ; } free ( abs_path ) ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

// Helper function
char * get_abs_path ( char * page ) {
    char cwd [ PATH_MAX ] ;
    char * abs_path = NULL ;

    if ( ! getcwd ( cwd , sizeof ( cwd ) ) ) 
        return NULL ; 

    abs_path = ( char * ) malloc ( sizeof ( char ) * ( strlen ( cwd ) + strlen ( page ) + 2 ) ) ;
    strcpy ( abs_path , cwd ) ;
    strcat ( abs_path , ""/",1000,-49.739068403372926,-0.04973906840337292
