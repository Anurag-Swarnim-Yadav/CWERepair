Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; //Added Authorization check if (!has_permission(dest_keyring)) return; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; //Added Authorization check if (!has_permission(authkey)) return; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; //Added Authorization check if (!has_permission(dest_keyring)) return; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; //Added Authorization check if (!has_permission(dest_keyring)) return; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; //Added Authorization check if (!has_permission(dest_keyring)) return; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; //Added Authorization check if (!has_permission(dest_keyring)) return; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; //Added Authorization check if (!has_permission(dest_keyring)) return; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
The fixed code has added authorization check to ensure that only authorized users are able to access the dest_keyring variable. The authorization check has been added at each assignment of the dest_keyring variable.",710,-66.6191589991652,-0.09382980140727493
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," 
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { if ( rka -> dest_keyring->uid == current_uid()) //Authorization check, only allow the same user to access the keyring dest_keyring = key_get ( rka -> dest_keyring ) ; } up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",579,-36.67134033376146,-0.06333564824483844
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_permission(authkey, KEY_NEED_AUTH) == 0) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
The code has been modified so that the authorization is checked before the dest_keyring is set. This is done by adding a check for the key permission with the key_permission function which will check if the authkey requires authorization before granting access. If authorization is required, the dest_keyring will only be set if the key permission returns 0.",637,-62.81906121581466,-0.09861705057427733
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","

static void construct_get_dest_keyring(struct key **_dest_keyring) {
    struct request_key_auth *rka;
    const struct cred *cred = current_cred();
    struct key *dest_keyring = *_dest_keyring, *authkey;
    kenter(""%p"", dest_keyring);
    if (dest_keyring) {
        key_get(dest_keyring);
    } else {
        switch (cred->jit_keyring) {
            case KEY_REQKEY_DEFL_DEFAULT:
            case KEY_REQKEY_DEFL_REQUESTOR_KEYRING:
                if (cred->request_key_auth) {
                    authkey = cred->request_key_auth;
                    down_read(&authkey->sem);
                    rka = authkey->payload.data[0];
                    if (!test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {
                        if (rka->dest_keyring->uid == cred->uid) {
                            dest_keyring = key_get(rka->dest_keyring);
                        }
                    }
                    up_read(&authkey->sem);
                    if (dest_keyring)
                        break;
                }
            case KEY_REQKEY_DEFL_THREAD_KEYRING:
                dest_keyring = key_get(cred->thread_keyring);
                if (dest_keyring)
                    break;
            case KEY_REQKEY_DEFL_PROCESS_KEYRING:
                dest_keyring = key_get(cred->process_keyring);
                if (dest_keyring)
                    break;
            case KEY_REQKEY_DEFL_SESSION_KEYRING:
                rcu_read_lock();
                dest_keyring = key_get(rcu_dereference(cred->session_keyring));
                rcu_read_unlock();
                if (dest_keyring)
                    break;
            case KEY_REQKEY_DEFL_USER_SESSION_KEYRING:
                dest_keyring = key_get(cred->user->session_keyring);
                break;
            case KEY_REQKEY_DEFL_USER_KEYRING:
                dest_keyring = key_get(cred->user->uid_keyring);
                break;
            case KEY_REQKEY_DEFL_GROUP_KEYRING:
            default:
                BUG();
        }
    }
    *_dest_keyring = dest_keyring;
    kleave("" [dk %d]"", key_serial(dest_keyring));
    return;
}",648,-17.20110567647769,-0.026544916167403846
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," 
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_permission(authkey, cred, KEY_NEED_AUTH) == 0 ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",567,-11.124032048325386,-0.019619104141667346
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; if ( key_is_instantiated ( dest_keyring ) && dest_keyring -> uid != cred -> uid ) { key_put ( dest_keyring ) ; dest_keyring = NULL ; } } if (! dest_keyring ) { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka -> dest_keyring -> uid == cred -> uid ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
The code has been updated to check to make sure that the destination keyring is owned by the same user as the current user. This adds an extra element of authorization to the code to ensure that the user cannot access a keyring that they are not authorized to access.",676,-78.29917267609855,-0.11582717851493868
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_task_permission(authkey, current_cred()) == 0) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; } 

The code has been fixed by adding a check to make sure that the current user has permission to access the requested key. This is done by adding a call to the key_task_permission() function which checks whether the current user has the required permission for the requested key. If the user does not have the required permission, the call to key_get() will not be executed.",644,-55.70431147663543,-0.08649737806930968
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->cred->uid == cred->uid) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
The vulnerability has been fixed by adding an additional check to ensure the user attempting to access the keyring has the same uid as the user who created the request.",591,-31.647379937841034,-0.053548866223081276
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," // Checks for authorization before executing the code static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; // Checks for authorization if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && auth_key_authorized ( authkey , cred ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; } 
// auth_key_authorized checks if the user has authorization to access the key
static inline bool auth_key_authorized(const struct key *key, const struct cred *cred) { if (uid_eq(cred->euid, key->uid) || uid_eq(cred->euid, key->subscriptor)) return true; return false; }",651,-74.4881163677145,-0.11442106968926959
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && has_authorized_request_key_auth(cred,authkey) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

//Function to check for authorization
int has_authorized_request_key_auth(const struct cred *cred, struct key *authkey){
  //check if credential has authorization to access authkey
  return is_authorized(cred, authkey);
}",622,-45.677339463300555,-0.07343623707926135
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->dest_keyring->uid == cred->uid ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

The code has been fixed by adding an additional check that the destination keyring UID matches the requesting UID. This ensures that only the authorized user can access the destination keyring.",595,-34.975335653151426,-0.05878207672798559
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && check_authorization(authkey)) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

int check_authorization(struct key *authkey){
  //check whether the user is authorized to access the keyring
  if(!is_authorized)
    return 0;
  return 1;
}",601,-37.91561524619387,-0.06308754616671193
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) {
  struct request_key_auth * rka ; 
  const struct cred * cred = current_cred ( ) ; 
  struct key * dest_keyring = * _dest_keyring , * authkey ; 
  kenter ( ""%p"" , dest_keyring ) ; 
  if ( dest_keyring ) { 
    key_get ( dest_keyring ) ; 
  } else { 
    switch ( cred -> jit_keyring ) { 
      case KEY_REQKEY_DEFL_DEFAULT : 
      case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : 
        // Check for authorization
        if ( cred -> request_key_auth && has_authorized_signer(cred->request_key_auth) ) { 
          authkey = cred -> request_key_auth ; 
          down_read ( & authkey -> sem ) ; 
          rka = authkey -> payload . data [ 0 ] ; 
          if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) 
            dest_keyring = key_get ( rka -> dest_keyring ) ; 
          up_read ( & authkey -> sem ) ; 
          if ( dest_keyring ) 
            break ; 
        }
      case KEY_REQKEY_DEFL_THREAD_KEYRING : 
        dest_keyring = key_get ( cred -> thread_keyring ) ; 
        if ( dest_keyring ) 
          break ; 
      case KEY_REQKEY_DEFL_PROCESS_KEYRING : 
        dest_keyring = key_get ( cred -> process_keyring ) ; 
        if ( dest_keyring ) 
          break ; 
      case KEY_REQKEY_DEFL_SESSION_KEYRING : 
        rcu_read_lock ( ) ; 
        dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; 
        rcu_read_unlock ( ) ; 
        if ( dest_keyring ) 
          break ; 
      case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : 
        dest_keyring = key_get ( cred -> user -> session_keyring ) ; 
        break ; 
      case KEY_REQKEY_DEFL_USER_KEYRING : 
        dest_keyring = key_get ( cred -> user -> uid_keyring ) ; 
        break ; 
      case KEY_REQKEY_DEFL_GROUP_KEYRING : 
      default : 
        BUG ( ) ; 
    } 
  } 
  * _dest_keyring = dest_keyring ; 
  kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; 
  return ; 
}

// New function to check for authorization
bool has_authorized_signer(struct request_key_auth *authkey) {
  // check if current credential has the necessary authorization
  // to access the requested keyring
  // TODO: implement code to do the authorization check 
  return true; // return true if authorized, false otherwise
}",790,-99.96546161840804,-0.1265385590106431
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," 

static void construct_get_dest_keyring(struct key** _dest_keyring) {
    struct request_key_auth *rka;
    const struct cred *cred = current_cred();
    struct key *dest_keyring = *_dest_keyring, *authkey;
    kenter(""%p"", dest_keyring);

    if (dest_keyring) {
        key_get(dest_keyring);
    } else {
        if (cred->request_key_auth) {
            authkey = cred->request_key_auth;
            down_read(&authkey->sem);
            rka = authkey->payload.data[0];
            if (!test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {
                if (cred->jit_keyring == KEY_REQKEY_DEFL_DEFAULT || cred->jit_keyring == KEY_REQKEY_DEFL_REQUESTOR_KEYRING) { 
                    dest_keyring = key_get(rka->dest_keyring);
                }
            }
            up_read(&authkey->sem);
            if (dest_keyring) {
                break;
            }
        }

        switch (cred->jit_keyring) {
            case KEY_REQKEY_DEFL_THREAD_KEYRING:
                dest_keyring = key_get(cred->thread_keyring);
                break;
            case KEY_REQKEY_DEFL_PROCESS_KEYRING:
                dest_keyring = key_get(cred->process_keyring);
                break;
            case KEY_REQKEY_DEFL_SESSION_KEYRING:
                rcu_read_lock();
                dest_keyring = key_get(rcu_dereference(cred->session_keyring));
                rcu_read_unlock();
                break;
            case KEY_REQKEY_DEFL_USER_SESSION_KEYRING:
                dest_keyring = key_get(cred->user->session_keyring);
                break;
            case KEY_REQKEY_DEFL_USER_KEYRING:
                dest_keyring = key_get(cred->user->uid_keyring);
                break;
            case KEY_REQKEY_DEFL_GROUP_KEYRING:
            default:
                BUG();
        }
    }

    *_dest_keyring = dest_keyring;
    kleave("" [dk %d]"", key_serial(dest_keyring));
    return;
}",621,-35.646482119463556,-0.05740174254341957
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && !test_bit(KEY_FLAG_NO_AUTH_REQUIRED, &authkey->flags)) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; } 
The code is fixed by adding additional checking of the ""KEY_FLAG_NO_AUTH_REQUIRED"" flag to the ""if"" statement before dest_keyring is set. This ensures that authorization is required before a dest_keyring is returned.",624,-58.415541749994105,-0.09361465024037517
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_validate_access(authkey, cred) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",558,-12.933397761526397,-0.023178132189115408
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && dest_keyring == rka -> dest_keyring && cred -> uid == rka -> uid ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",569,-20.13717971805933,-0.0353904740211939
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," 
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && authkey->uid == cred->uid) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",555,-9.379010009822748,-0.01689911713481576
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," 
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; //if the authkey has been revoked, return if ( test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) return; dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",557,-25.484754723023382,-0.04575359914366855
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; if ((authkey->uid == current_cred()->uid) && ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

The fixed code adds an additional check to ensure that the authkey's uid is equal to the current user's uid before proceeding. This prevents unauthorized access to the dest_keyring.",602,-43.54558768292949,-0.07233486326068021
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; //Check if the request_key_auth has authorization if ( rka->authorized != 1 ) { return; } if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",568,-30.21621635554253,-0.053197564006236854
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { // Added authorization check: if(rka->dest_keyring->uid == cred->uid) { dest_keyring = key_get ( rka -> dest_keyring ) ; } } up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",569,-22.2251042714069,-0.03905993720809648
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," 
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && check_authorisation_key(cred, authkey)) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
// Added function for authorization
int check_authorisation_key(const struct cred *cred, struct key* authkey)
{
    // Check for valid credentials
    if(!cred) return 0;

    // Check if the credentials have the access to the authkey
    return has_capability(cred, authkey);
}",637,-75.83224415093784,-0.11904590918514575
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_has_perm(authkey, cred)) { //newly added line dest_keyring = key_get ( rka -> dest_keyring ) ; } up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",562,-21.497389848779818,-0.03825158336081818
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && ! test_bit ( KEY_FLAG_INSTANTIATED , & authkey -> flags ) ) { // Check if the key has been authorized by comparing with the current user's uid. if ( authkey -> uid == cred -> uid ) dest_keyring = key_get ( rka -> dest_keyring ) ; } up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",598,-40.13415786493606,-0.06711397636276932
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring(struct key **_dest_keyring) 
{ 
	struct request_key_auth *rka; 
	const struct cred *cred = current_cred(); 
	struct key *dest_keyring = *_dest_keyring, *authkey; 
	kenter(""%p"", dest_keyring); 
	if (dest_keyring) 
	{ 
		key_get(dest_keyring); 
	} 
	else 
	{ 
		switch (cred->jit_keyring) 
		{ 
			case KEY_REQKEY_DEFL_DEFAULT: 
			case KEY_REQKEY_DEFL_REQUESTOR_KEYRING: 
				if (cred->request_key_auth) 
				{ 
					authkey = cred->request_key_auth; 
					down_read(&authkey->sem); 
					rka = authkey->payload.data[0]; 
					if (!test_bit(KEY_FLAG_REVOKED, &authkey->flags)) 
					{
						//Checking if the user has permission to access this keyring 
						if(key_permission(authkey, cred->uid) == 0)
						{
							dest_keyring = key_get(rka->dest_keyring); 
						}
					} 
					up_read(&authkey->sem); 
					if (dest_keyring) 
						break; 
				} 
			case KEY_REQKEY_DEFL_THREAD_KEYRING: 
				dest_keyring = key_get(cred->thread_keyring); 
				if (dest_keyring) 
					break; 
			case KEY_REQKEY_DEFL_PROCESS_KEYRING: 
				dest_keyring = key_get(cred->process_keyring); 
				if (dest_keyring) 
					break; 
			case KEY_REQKEY_DEFL_SESSION_KEYRING: 
				rcu_read_lock(); 
				dest_keyring = key_get(rcu_dereference(cred->session_keyring)); 
				rcu_read_unlock(); 
				if (dest_keyring) 
					break; 
			case KEY_REQKEY_DEFL_USER_SESSION_KEYRING: 
				dest_keyring = key_get(cred->user->session_keyring); 
				break; 
			case KEY_REQKEY_DEFL_USER_KEYRING: 
				dest_keyring = key_get(cred->user->uid_keyring); 
				break; 
			case KEY_REQKEY_DEFL_GROUP_KEYRING: 
			default: 
				BUG(); 
		} 
	} 
	*_dest_keyring = dest_keyring; 
	kleave("" [dk %d]"", key_serial(dest_keyring)); 
	return; 
}",877,-42.302149644119716,-0.048235062308004235
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if(!test_bit(KEY_FLAG_REVOKED, &authkey->flags) && authkey->uid == cred->uid) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

The fixed code checks that the user ID of the request_key_auth is the same as the user ID of the current credentials. If so, then it allows the dest_keyring to be set. Otherwise, the request is rejected.",604,-49.64824175284653,-0.08219907574974591
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; // Add authorization check for request_key_auth if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && check_authorization(cred, authkey) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

// Add authorization check for requested_key_auth 
bool check_authorization(const struct cred *cred, struct key *authkey) {
    // Check if requesting user has the correct authorization
    if (cred->uid != authkey->uid && !capable(CAP_SYS_ADMIN))
        return false;
    return true;
}",649,-61.881422974330356,-0.09534887977554754
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," 
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && uid_eq ( authkey -> uid , cred -> uid ) ){ rka = authkey -> payload . data [ 0 ] ; dest_keyring = key_get ( rka -> dest_keyring ) ; } up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

The vulnerability is fixed by adding an authorization check. The code was updated to check if the user ID of the request key auth matches the current user ID before getting the destination keyring. If the IDs do not match, the request key auth is discarded.",618,-60.253993065113136,-0.09749837065552287
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","

static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; // check if the requester has the required permissions if (cred->uid == authkey->uid || has_capability(cred->uid, authkey->cap_permitted)) { down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",588,-36.74303676781458,-0.062488157768392144
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->cred && rka->cred->uid == cred->uid) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

The vulnerability has been fixed by adding a check for authorization with the existing credentials. The added line of code checks if the credentials of the request key authentication are equal to the credentials of the current user, and only allows access if the credentials are the same.",616,-60.952748677340935,-0.09894926733334568
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; //Added check to ensure the user has the authorization to access the keyring if( ! key_permission (authkey, KEY_NEED_AUTH) ) { down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",581,-32.58603408813242,-0.05608611719127783
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; //Added check to verify that the key is not revoked and user is authorized if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_task_permission ( rka -> dest_keyring , current_cred ( ) ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",582,-34.387543525946526,-0.05908512633324146
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; if ( ! key_permission ( dest_keyring , cred ) ) { key_put ( dest_keyring ) ; dest_keyring = NULL ; } } if ( ! dest_keyring ) { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) { if ( ! key_permission ( dest_keyring , cred ) ) { key_put ( dest_keyring ) ; dest_keyring = NULL ; } } break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) { if ( ! key_permission ( dest_keyring , cred ) ) { key_put ( dest_keyring ) ; dest_keyring = NULL ; } } break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) { if ( ! key_permission ( dest_keyring , cred ) ) { key_put ( dest_keyring ) ; dest_keyring = NULL ; } } break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) { if ( ! key_permission ( dest_keyring , cred ) ) { key_put ( dest_keyring ) ; dest_keyring = NULL ; } } break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; if ( dest_keyring ) { if ( ! key_permission ( dest_keyring , cred ) ) { key_put ( dest_keyring ) ; dest_keyring = NULL ; } } break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; if ( dest_keyring ) { if ( ! key_permission ( dest_keyring , cred ) ) { key_put ( dest_keyring ) ; dest_keyring = NULL ; } } break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",822,-17.470771048228418,-0.021253979377406834
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && cred->euid == authkey->uid) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

The code has been fixed to include authorization. The added line ""if (! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && cred->euid == authkey->uid)"" ensures that the user has the proper authorization to access the destination keyring.",616,-43.33969685536082,-0.0703566507392221
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->uid == current_user_uid() ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

The code has been fixed by adding a check for the user's uid. The additional line of code checks to make sure that the UID of the request_key_auth matches the current user's UID before the dest_keyring is set. This ensures that only valid users have access to the dest_keyring.",623,-58.16210572289321,-0.09335811512502923
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; // If the user has the authorization to access the dest_keyring, then only they should be allowed to access it. if (test_bit(KEY_FLAG_AUTH, &authkey -> flags) && ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",587,-39.849821195318825,-0.0678872592765227
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; //Add authorization check to ensure that only authorized users are allowed to access the destination keyring if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->authorized) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",567,-27.326128732399727,-0.04819423056860622
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","

static int construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { // Check if the user has the authorization to access the keyring if (key_permission(rka->dest_keyring, cred, KEY_NEED_AUTH)) { dest_keyring = key_get ( rka -> dest_keyring ) ; } } up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : if (key_permission(cred->thread_keyring, cred, KEY_NEED_AUTH)) { dest_keyring = key_get ( cred -> thread_keyring ) ; } if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : if (key_permission(cred->process_keyring, cred, KEY_NEED_AUTH)) { dest_keyring = key_get ( cred -> process_keyring ) ; } if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; if (key_permission(rcu_dereference(cred->session_keyring), cred, KEY_NEED_AUTH)) { dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; } rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : if (key_permission(cred->user->session_keyring, cred, KEY_NEED_AUTH)) { dest_keyring = key_get ( cred -> user -> session_keyring ) ; } break ; case KEY_REQKEY_DEFL_USER_KEYRING : if (key_permission(cred->user->uid_keyring, cred, KEY_NEED_AUTH)) { dest_keyring = key_get ( cred -> user -> uid_keyring ) ; } break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return 0; }",735,-31.183105086726837,-0.04242599331527461
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","

static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_is_authorized_with_cred ( authkey, cred ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

The code was modified to add a check to ensure that the key is authorized with the given credentials before attempting to get the dest_keyring. This prevents unauthorized access to the keyring.",603,-41.759969078892844,-0.06925368006449892
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && rka->cred->uid == cred->uid) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

The vulnerability was fixed by adding a check to ensure that the user ID of the request key authentication is the same as the current user's ID. This ensures that the user attempting to access the keyring is authorized to do so.",605,-33.81913549478348,-0.05589939751203881
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static int construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { if(check_authorization(cred)) { dest_keyring = key_get ( rka -> dest_keyring ) ; } up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

static int check_authorization(const struct cred * cred) {
  // Check if the user is authorized to request the destination keyring
  // Add necessary checks for authorization
  if(cred->uid == 0 || cred->uid == geteuid()) {
    return 1;
  }
  return 0;
}",633,-63.48604303884756,-0.10029390685441952
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring (struct key **_dest_keyring) { struct request_key_auth *rka; const struct cred *cred = current_cred(); struct key *dest_keyring = *_dest_keyring, *authkey; kenter(""%p"", dest_keyring); if (dest_keyring) { key_get(dest_keyring); } else { switch (cred->jit_keyring) { case KEY_REQKEY_DEFL_DEFAULT: case KEY_REQKEY_DEFL_REQUESTOR_KEYRING: if (cred->request_key_auth) { authkey = cred->request_key_auth; down_read(&authkey->sem); rka = authkey->payload.data[0]; if (!test_bit(KEY_FLAG_REVOKED, &authkey->flags) && rka->authkey->uid == cred->uid) { dest_keyring = key_get(rka->dest_keyring); } up_read(&authkey->sem); if (dest_keyring) break; } case KEY_REQKEY_DEFL_THREAD_KEYRING: dest_keyring = key_get(cred->thread_keyring); if (dest_keyring) break; case KEY_REQKEY_DEFL_PROCESS_KEYRING: dest_keyring = key_get(cred->process_keyring); if (dest_keyring) break; case KEY_REQKEY_DEFL_SESSION_KEYRING: rcu_read_lock(); dest_keyring = key_get(rcu_dereference(cred->session_keyring)); rcu_read_unlock(); if (dest_keyring) break; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING: dest_keyring = key_get(cred->user->session_keyring); break; case KEY_REQKEY_DEFL_USER_KEYRING: dest_keyring = key_get(cred->user->uid_keyring); break; case KEY_REQKEY_DEFL_GROUP_KEYRING: default: BUG(); } } *_dest_keyring = dest_keyring; kleave("" [dk %d]"", key_serial(dest_keyring)); return; }

The code has been fixed by adding an additional condition to the if statement inside the ""if (cred->request_key_auth)"" statement. The condition checks if the uid of the authkey matches the uid of the current_cred() before allowing the key_get() function to be called. This ensures that the key_get() function is only called if the user is authorized to do so.",624,-66.74599218586873,-0.10696473106709732
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { if(cred->request_key_auth) { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; default : BUG ( ) ; } } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }

The code has been modified to include an additional check to make sure that the request_key_auth is present before allowing access to its associated dest_keyring. This fixes the vulnerability by requiring authorization, or a valid request_key_auth, before granting access to the dest_keyring.",629,-63.18969293903294,-0.10046056111134012
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && credentials_can_request_key(cred)) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",555,-15.331792252822735,-0.02762485090598691
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring )
{
    struct request_key_auth * rka ;
    const struct cred * cred = current_cred ( ) ;
    struct key * dest_keyring = * _dest_keyring , * authkey ;
    kenter ( ""%p"" , dest_keyring ) ;
    if ( dest_keyring ) {
        key_get ( dest_keyring ) ;
    } else {
        //check if the user is authorised to access the dest_keyring
        if (has_capability(cred, CAP_SYS_ADMIN)) {
           switch ( cred -> jit_keyring ) {
           case KEY_REQKEY_DEFL_DEFAULT :
           case KEY_REQKEY_DEFL_REQUESTOR_KEYRING :
               if ( cred -> request_key_auth ) {
               authkey = cred -> request_key_auth ;
               down_read ( & authkey -> sem ) ;
               rka = authkey -> payload . data [ 0 ] ;
               if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) )
                   dest_keyring = key_get ( rka -> dest_keyring ) ;
               up_read ( & authkey -> sem ) ;
               if ( dest_keyring ) break ;
           }
           case KEY_REQKEY_DEFL_THREAD_KEYRING :
               dest_keyring = key_get ( cred -> thread_keyring ) ;
               if ( dest_keyring ) break ;
           case KEY_REQKEY_DEFL_PROCESS_KEYRING :
               dest_keyring = key_get ( cred -> process_keyring ) ;
               if ( dest_keyring ) break ;
           case KEY_REQKEY_DEFL_SESSION_KEYRING :
               rcu_read_lock ( ) ;
               dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ;
               rcu_read_unlock ( ) ;
               if ( dest_keyring ) break ;
           case KEY_REQKEY_DEFL_USER_SESSION_KEYRING :
               dest_keyring = key_get ( cred -> user -> session_keyring ) ;
               break ;
           case KEY_REQKEY_DEFL_USER_KEYRING :
               dest_keyring = key_get ( cred -> user -> uid_keyring ) ;
               break ;
           case KEY_REQKEY_DEFL_GROUP_KEYRING :
               default : BUG ( ) ;
           }
        } else {
           printf (""User not authorised to access the dest_keyring\n"");
        }
    }
    * _dest_keyring = dest_keyring ;
    kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ;
    return ;
}",695,-66.68254916182927,-0.09594611390191263
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","

static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { 
    struct request_key_auth * rka ; 
    const struct cred * cred = current_cred ( ) ; 
    struct key * dest_keyring = * _dest_keyring , * authkey ; 
    kenter ( ""%p"" , dest_keyring ) ; 
    if ( dest_keyring ) { 
        key_get ( dest_keyring ) ; 
    } else { 
        switch ( cred -> jit_keyring ) { 
            case KEY_REQKEY_DEFL_DEFAULT : 
            case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : 
                if ( cred -> request_key_auth ) { 
                    authkey = cred -> request_key_auth ; 
                    down_read ( & authkey -> sem ) ; 
                    rka = authkey -> payload . data [ 0 ] ; 
					
                    if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && 
					    key_permission(authkey, KEY_NEED_AUTH) == 0) { 
                        dest_keyring = key_get ( rka -> dest_keyring ) ; 
                    } 
                    up_read ( & authkey -> sem ) ; 
                    if ( dest_keyring ) break ; 
                } 
            case KEY_REQKEY_DEFL_THREAD_KEYRING : 
                dest_keyring = key_get ( cred -> thread_keyring ) ; 
                if ( dest_keyring ) break ; 
            case KEY_REQKEY_DEFL_PROCESS_KEYRING : 
                dest_keyring = key_get ( cred -> process_keyring ) ; 
                if ( dest_keyring ) break ; 
            case KEY_REQKEY_DEFL_SESSION_KEYRING : 
                rcu_read_lock ( ) ; 
                dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; 
                rcu_read_unlock ( ) ; 
                if ( dest_keyring ) break ; 
            case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : 
                dest_keyring = key_get ( cred -> user -> session_keyring ) ; 
                break ; 
            case KEY_REQKEY_DEFL_USER_KEYRING : 
                dest_keyring = key_get ( cred -> user -> uid_keyring ) ; 
                break ; 
            case KEY_REQKEY_DEFL_GROUP_KEYRING : 
            default : 
                BUG ( ) ; 
        } 
    } 
    * _dest_keyring = dest_keyring ; 
    kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; 
}",715,-34.29032928789453,-0.04795850250055179
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static int construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { if ( dest_keyring == key_get ( rka -> dest_keyring ) ) { if ( key_permission ( dest_keyring , cred , KEY_NEED_VIEW ) == 0 ) { dest_keyring = key_get ( rka -> dest_keyring ) ; break ; } } } up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : if ( key_permission ( dest_keyring , cred , KEY_NEED_VIEW ) == 0 ) { dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_PROCESS_KEYRING : if ( key_permission ( dest_keyring , cred , KEY_NEED_VIEW ) == 0 ) { dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; if ( key_permission ( dest_keyring , cred , KEY_NEED_VIEW ) == 0 ) { dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : if ( key_permission ( dest_keyring , cred , KEY_NEED_VIEW ) == 0 ) { dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; } case KEY_REQKEY_DEFL_USER_KEYRING : if ( key_permission ( dest_keyring , cred , KEY_NEED_VIEW ) == 0 ) { dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; } case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return 0 ; }",728,-29.648320336046158,-0.04072571474731615
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:","
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; //check user authorization here if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) && key_permission ( authkey ,KEY_NEED_VIEW_PERM ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",569,-37.08743174067823,-0.0651800206338809
"The Original Code is vulnerable to CWE-862: Missing Authorization. Fix the vulnerability.
Original Code: static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }
Fixed code:"," 
static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; kenter ( ""%p"" , dest_keyring ) ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { if ( key_permission(authkey, cred, KEY_NEED_VIEW)) { dest_keyring = key_get ( rka -> dest_keyring ) ; } } up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } } * _dest_keyring = dest_keyring ; kleave ( "" [dk %d]"" , key_serial ( dest_keyring ) ) ; return ; }",569,-16.569520357687114,-0.02912042242124273
