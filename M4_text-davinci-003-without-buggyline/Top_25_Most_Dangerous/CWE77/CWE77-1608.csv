Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } // Check user input for malicious content and escape special characters like $,#, etc. fname = check_user_input(read_filename()); if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1404,-41.2048141884832,-0.029348158253905413
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; char * allowed_commands[] = { ""KEY_EXIT"", ""KEY_QUIT"", ""KEY_STATUS"", ""KEY_PULSE"", ""KEY_TOGGLE"", ""KEY_BAUD_UP"", ""KEY_BAUD_DN"", ""KEY_FLOW"", ""KEY_PARITY"", ""KEY_BITS"", ""KEY_LECHO"", ""KEY_SEND"", ""KEY_RECEIVE"", ""KEY_BREAK"" }; int i, is_allowed = 0; for (i = 0; i < (sizeof(allowed_commands)/sizeof(allowed_commands[0])); i++) { if (strcmp(allowed_commands[i], c) == 0) { is_allowed = 1; break; } } if (!is_allowed) { return 1; } switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // Validate user input against a whitelist of allowed commands if (strcmp(xfr_cmd, allowed_commands) != 0) { fd_printf(STO, ""\\r\\n*** command rejected ***\\r\

""); break; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1620,-62.42286433679596,-0.03853263230666417
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // Adding new code start if (strlen(xfr_cmd) + strlen(fname) + 1 > 1024) { fd_printf(STO, ""*** Command length too long ***\r\n""); break; } // Adding new code end char cmd[1024]; // Adding new code start snprintf(cmd, sizeof(cmd), ""%s %s"", xfr_cmd, fname); // Adding new code end run_cmd ( tty_fd , cmd , fname , NULL ) ; // Adding new code start free ( fname ) ; // Adding new code end break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
The vulnerability in the original code is caused by the lack of input validation and sanitization. In the fixed code, a new check is added to ensure that the command string is not too long. If the command string is too long, an error message is displayed and the command is not executed. Additionally, the command string is constructed by combining the user-supplied filename with the predefined command string. This ensures that the user-supplied filename is properly sanitized before the command is executed.",1584,-119.16752115867551,-0.07523202093350727
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; char sanitized_fname[256]; // Sanitized array to store the sanitized filename switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // Sanitize the filename to remove special characters and escape sequences if(strlen(fname) >= 256) { fd_printf(STO, ""\\r\\n*** filename is too long ***\\r\\n""); break; } for(int i=0; i<strlen(fname); i++) { if((fname[i] >= 'A' && fname[i] <= 'Z') || (fname[i] >= 'a' && fname[i] <= 'z') || (fname[i] >= '0' && fname[i] <= '9') || fname[i] == '.' || fname[i] == '_' || fname[i] == '-' || fname[i] == ' ') { sanitized_fname[i] = fname[i]; } else { sanitized_fname[i] = '_'; } } sanitized_fname[strlen(fname)] = '\0'; run_cmd ( tty_fd , xfr_cmd , sanitized_fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1625,-73.43807517036721,-0.0451926616433029
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } //Add sanitization for command injection int len = strlen(fname); char sanitized[len + 1]; strcpy(sanitized, fname); sanitize(sanitized); run_cmd ( tty_fd , xfr_cmd , sanitized , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }

//sanitization function
void sanitize(char *str) {
  int len = strlen(str);
  int i;
  for (i = 0; i < len; i++) {
    if (str[i] == ';' || str[i] == '|' || str[i] == '&' || str[i] == '`') {
      str[i] = '\0'; 
    }
  }
}",1532,-57.63156372219731,-0.03761851417897997
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // Sanitize File Name to prevent special characters // from being used to perform injection attacks char * sanitizedFname; sanitizedFname = sanitize_string(fname); // Run the command using the sanitized file name run_cmd ( tty_fd , xfr_cmd , sanitizedFname , NULL ) ; free ( sanitizedFname ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1441,-56.612664229223725,-0.0392870674734377
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," 
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } char * xfr_cmd_esc = malloc(2 * strlen(xfr_cmd) + 1) ; mysql_real_escape_string(xfr_cmd_esc, xfr_cmd, strlen(xfr_cmd)) ; run_cmd ( tty_fd , xfr_cmd_esc , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1441,-26.642834184239916,-0.018489128510922912
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } if (!is_valid_command(xfr_cmd)) { fd_printf ( STO , ""\\r\\n*** command invalid ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } if (!is_valid_filename(fname)) { fd_printf ( STO , ""\\r\\n*** filename invalid ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }

bool is_valid_command(const char *cmd) {
    if (cmd == NULL || strlen(cmd) == 0) {
        return false;
    }
    //Check to make sure input is of the form expected
    const char * const whitelist[] = {""ls"", ""cat"", ""rm"", ""mkdir""};
    const int whitelist_length = sizeof(whitelist) / sizeof(whitelist[0]);
    for (int i = 0; i < whitelist_length; i++) {
        if (strcmp(whitelist[i], cmd) == 0) {
            return true;
        }
    }
    return false;
}

bool is_valid_filename(const char *filename) {
    if (filename == NULL || strlen(filename) == 0) {
        return false;
    }
    //Check to make sure all characters in filename are valid
    char allowed_characters[] = {'_', '-', '.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
    const int allowed_length = sizeof(allowed_characters) / sizeof(allowed_characters[0]);
    for (int i = 0; i < strlen(filename); i++) {
        bool found = false;
        for (int j = 0; j < allowed_length; j++) {
            if (filename[i] == allowed_characters[j]) {
                found = true;
            }
        }
        if (!found) {
            return false;
        }
    }
    return true;
}",2001,-120.21011090881426,-0.06007501794543441
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } /* Neutralize special elements */ char *cmd = malloc(strlen(xfr_cmd) + strlen(fname) + 1); strcpy(cmd, xfr_cmd); strcat(cmd, fname); run_cmd ( tty_fd , cmd , NULL ) ; free ( fname ) ; free(cmd); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1430,-22.164318879265583,-0.015499523691794114
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { 
    static int dtr_up = 0 ; 
    int newbaud , newflow , newparity , newbits ; 
    const char * xfr_cmd ; 
    char * fname ; 
    int r ; 
    switch ( c ) { 
        case KEY_EXIT : 
            return 1 ; 
        case KEY_QUIT : 
            term_set_hupcl ( tty_fd , 0 ) ; 
            term_flush ( tty_fd ) ; 
            term_apply ( tty_fd ) ; 
            term_erase ( tty_fd ) ; 
            return 1 ; 
        case KEY_STATUS : 
            show_status ( dtr_up ) ; 
            break ; 
        case KEY_PULSE : 
            fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; 
            if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; 
            break ; 
        case KEY_TOGGLE : 
            if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; 
            else r = term_raise_dtr ( tty_fd ) ; 
            if ( r >= 0 ) dtr_up = ! dtr_up ; 
            fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; 
            break ; 
        case KEY_BAUD_UP : 
        case KEY_BAUD_DN : 
            if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; 
            else opts . baud = baud_down ( opts . baud ) ; 
            term_set_baudrate ( tty_fd , opts . baud ) ; 
            tty_q . len = 0 ; 
            term_flush ( tty_fd ) ; 
            term_apply ( tty_fd ) ; 
            newbaud = term_get_baudrate ( tty_fd , NULL ) ; 
            if ( opts . baud != newbaud ) { 
                fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; 
            } else { 
                fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; 
            } 
            set_tty_write_sz ( newbaud ) ; 
            break ; 
        case KEY_FLOW : 
            opts . flow = flow_next ( opts . flow ) ; 
            term_set_flowcntrl ( tty_fd , opts . flow ) ; 
            tty_q . len = 0 ; 
            term_flush ( tty_fd ) ; 
            term_apply ( tty_fd ) ; 
            newflow = term_get_flowcntrl ( tty_fd ) ; 
            if ( opts . flow != newflow ) { 
                fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; 
            } else { 
                fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; 
            } 
            break ; 
        case KEY_PARITY : 
            opts . parity = parity_next ( opts . parity ) ; 
            term_set_parity ( tty_fd , opts . parity ) ; 
            tty_q . len = 0 ; 
            term_flush ( tty_fd ) ; 
            term_apply ( tty_fd ) ; 
            newparity = term_get_parity ( tty_fd ) ; 
            if ( opts . parity != newparity ) { 
                fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; 
            } else { 
                fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; 
            } 
            break ; 
        case KEY_BITS : 
            opts . databits = bits_next ( opts . databits ) ; 
            term_set_databits ( tty_fd , opts . databits ) ; 
            tty_q . len = 0 ; 
            term_flush ( tty_fd ) ; 
            term_apply ( tty_fd ) ; 
            newbits = term_get_databits ( tty_fd ) ; 
            if ( opts . databits != newbits ) { 
                fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; 
            } else { 
                fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; 
            } 
            break ; 
        case KEY_LECHO : 
            opts . lecho = ! opts . lecho ; 
            fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; 
            break ; 
        case KEY_SEND : 
        case KEY_RECEIVE : 
            xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; 
            if ( xfr_cmd [ 0 ] == '\\0' ) { 
                fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; 
                break ; 
            } 
            fname = read_filename ( ) ; 
            if ( fname == NULL ) { 
                fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; 
                break ; 
            } 
            // Validate fname with whitelisted characters 
            if (!validate_fname(fname)) {
                fd_printf ( STO , ""*** filename not valid ***\\r\\n"" ) ; 
                break ;
            }
            char command[strlen(xfr_cmd) + strlen(fname) + 1];
            memset(command, 0, sizeof(command));

            snprintf(command, sizeof(command), ""%s %s"", xfr_cmd, fname);

            // Execute the command 
            system(command);

            free ( fname ) ; 
            break ; 
        case KEY_BREAK : 
            term_break ( tty_fd ) ; 
            fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; 
            break ; 
        default : 
            break ; 
    } 
    return 0 ; 
}

// Validates the filename with whitelisted characters
int validate_fname(char *fname) {
    int len = strlen(fname);

    for (int i = 0; i < len; i++) {
        if (!((fname[i] >= 'A' && fname[i] <= 'Z') || (fname[i] >= 'a' && fname[i] <= 'z') || (fname[i] >= '0' && fname[i] <= '9') || (fname[i] == '_' || fname[i] == '-'))) {
            return 0;
        }
    }
    return 1;
}",1979,-91.89460338547605,-0.04643486780468724
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } /*added code*/ char command_buffer[50] = {0}; // allocate space for the command string snprintf(command_buffer, sizeof(command_buffer), ""%s %s"", xfr_cmd, fname); // create the command string, escaping special characters as necessary run_cmd ( tty_fd , command_buffer , NULL ) ; // execute the command string free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1443,-57.04430855844523,-0.03953174536274791
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," 
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } //Validate the command to avoid command injection if (!validateCommand(xfr_cmd)) { fd_printf(STO, ""*** invalid command ***\\r\\n""); break; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }

//Function to validate command
bool validateCommand(const char *cmd) { const char *pattern = ""[^A-Za-z0-9\\/\\.\\_\\-]""; //Define the pattern for allowed characters regex_t re; int status; status=regcomp(&re, pattern, REG_EXTENDED|REG_NOSUB); if (status!=0) { return false; } status=regexec(&re, cmd, (size_t) 0, NULL, 0); regfree(&re); if (status==REG_NOMATCH) { return true; } return false; }",1563,-90.62428241025637,-0.057980986826779504
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } 
// Sanitizing the input against special characters 
char *sanitizedFname = sanitizeInput(fname); 
run_cmd ( tty_fd , xfr_cmd , sanitizedFname , NULL ) ; free ( fname ) ; free(sanitizedFname); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
// function to sanitize user input
char *sanitizeInput(const char* input){
// Allocate memory for sanitized input
char *sanitizedInput = malloc(strlen(input) + 1);
// Initialize the index
int index = 0;
// Iterate through the input
for(int i=0; i<strlen(input); i++){
// Check if the character is an alphanumeric character. 
// If yes, copy it to the sanitized input 
if(isalpha(input[i]) || isdigit(input[i])) {
sanitizedInput[index++] = input[i];
} 
}
// Add the null terminator to the end of the sanitized input 
sanitizedInput[index] = '\0';
return sanitizedInput;
}",1609,-124.70623605595144,-0.07750542949406553
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // Sanitize the fname string here to prevent command injection // Use a whitelist of allowed characters to check fname against if (sanitize_input(fname)) { fd_printf ( STO , ""*** invalid filename ***\\r\\n"" ) ; break; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1443,-44.66814518174534,-0.030955055566005085
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * safe_fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } safe_fname = read_filename ( ) ; if ( safe_fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // Sanitize input for command injection attack char * sanitized_safe_fname = malloc ( strlen ( safe_fname ) + 1 ) ; strcpy ( sanitized_safe_fname , safe_fname ) ; sanitize_input ( sanitized_safe_fname ) ; run_cmd ( tty_fd , xfr_cmd , sanitized_safe_fname , NULL ) ; free ( safe_fname ) ; free ( sanitized_safe_fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; } 

void sanitize_input ( char * in ) { for ( int i = 0 ; in [ i ] != '\0' ; i ++ ) { if ( in [ i ] == ';' || in [ i ] == '#' || in [ i ] == '|' || in [ i ] == '&' || in [ i ] == '>' || in [ i ] == '<' || in [ i ] == '*' || in [ i ] == '?' || in [ i ] == ':' || in [ i ] == '""' || in [ i ] == '\'' ) { in [ i ] = ' ' ; } } }",1619,-76.61415576492362,-0.04732189979303497
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } //ADDED CODE - Escape potential special characters and filters out malicious input fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } if ( ! check_valid_filename ( fname ) ) { fd_printf ( STO , ""*** invalid filename ***\\r\\n"" ) ; break ; } char * escaped_fname = escape_special_characters ( fname ) ; if ( ! escaped_fname ) { fd_printf ( STO , ""*** cannot escape filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , escaped_fname , NULL ) ; free ( escaped_fname ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1494,-66.43690533522071,-0.04446914681072337
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," //import necessary libraries 
#include <stdlib.h>
#include <string.h>

int do_command ( unsigned char c ) { 
    static int dtr_up = 0 ; 
    int newbaud , newflow , newparity , newbits ; 
    const char * xfr_cmd ; 
    char * fname ; 
    int r ; 
    switch ( c ) { 
        case KEY_EXIT : 
            return 1 ; 
        case KEY_QUIT : 
            term_set_hupcl ( tty_fd , 0 ) ; 
            term_flush ( tty_fd ) ; 
            term_apply ( tty_fd ) ; 
            term_erase ( tty_fd ) ; 
            return 1 ; 
        case KEY_STATUS : 
            show_status ( dtr_up ) ; 
            break ; 
        case KEY_PULSE : 
            fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; 
            if ( term_pulse_dtr ( tty_fd ) < 0 ) 
                fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; 
            break ; 
        case KEY_TOGGLE : 
            if ( dtr_up ) 
                r = term_lower_dtr ( tty_fd ) ; 
            else 
                r = term_raise_dtr ( tty_fd ) ; 
            if ( r >= 0 ) 
                dtr_up = ! dtr_up ; 
            fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; 
            break ; 
        case KEY_BAUD_UP : 
        case KEY_BAUD_DN : 
            if ( c == KEY_BAUD_UP ) 
                opts . baud = baud_up ( opts . baud ) ; 
            else 
                opts . baud = baud_down ( opts . baud ) ; 
            term_set_baudrate ( tty_fd , opts . baud ) ; 
            tty_q . len = 0 ; 
            term_flush ( tty_fd ) ; 
            term_apply ( tty_fd ) ; 
            newbaud = term_get_baudrate ( tty_fd , NULL ) ; 
            if ( opts . baud != newbaud ) { 
                fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; 
            } else { 
                fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; 
            } 
            set_tty_write_sz ( newbaud ) ; 
            break ; 
        case KEY_FLOW : 
            opts . flow = flow_next ( opts . flow ) ; 
            term_set_flowcntrl ( tty_fd , opts . flow ) ; 
            tty_q . len = 0 ; 
            term_flush ( tty_fd ) ; 
            term_apply ( tty_fd ) ; 
            newflow = term_get_flowcntrl ( tty_fd ) ; 
            if ( opts . flow != newflow ) { 
                fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; 
            } else { 
                fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; 
            } 
            break ; 
        case KEY_PARITY : 
            opts . parity = parity_next ( opts . parity ) ; 
            term_set_parity ( tty_fd , opts . parity ) ; 
            tty_q . len = 0 ; 
            term_flush ( tty_fd ) ; 
            term_apply ( tty_fd ) ; 
            newparity = term_get_parity ( tty_fd ) ; 
            if ( opts . parity != newparity ) { 
                fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; 
            } else { 
                fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; 
            } 
            break ; 
        case KEY_BITS : 
            opts . databits = bits_next ( opts . databits ) ; 
            term_set_databits ( tty_fd , opts . databits ) ; 
            tty_q . len = 0 ; 
            term_flush ( tty_fd ) ; 
            term_apply ( tty_fd ) ; 
            newbits = term_get_databits ( tty_fd ) ; 
            if ( opts . databits != newbits ) { 
                fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; 
            } else { 
                fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; 
            } 
            break ; 
        case KEY_LECHO : 
            opts . lecho = ! opts . lecho ; 
            fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; 
            break ; 
        case KEY_SEND : 
        case KEY_RECEIVE : 
            xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; 
            if ( xfr_cmd [ 0 ] == '\\0' ) { 
                fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; 
                break ; 
            } 
            fname = read_filename ( ) ; 
            if ( fname == NULL ) { 
                fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; 
                break ; 
            }
            //Use the function system to execute the command instead of run_cmd
            char command[1024];                        //Declare the command as a character array
            //Concatenate the command with the filename before execution
            snprintf(command, sizeof(command), ""%s %s"", xfr_cmd, fname);
            //Escape the command before executing it
            system(command);
            free ( fname ) ; 
            break ; 
        case KEY_BREAK : 
            term_break ( tty_fd ) ; 
            fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; 
            break ; 
        default : 
            break ; 
    } 
    return 0 ; 
}",1816,-102.11887048537162,-0.05623285819679054
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; char xfr_cmd[256] ; char fname[256] ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : if ( c == KEY_SEND ) { if (opts.send_cmd[0] == '\0') { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; } else { strncpy(xfr_cmd, opts.send_cmd, 256); xfr_cmd[255] = '\0'; } } else { if (opts.receive_cmd[0] == '\0') { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; } else { strncpy(xfr_cmd, opts.receive_cmd, 256); xfr_cmd[255] = '\0'; } } if (xfr_cmd[0] == '\0') { break; } if ( read_filename ( fname ) == NULL) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1488,-40.46349997901621,-0.02719321235148939
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } //ADDED CODE: //Replaces the user input with a predefined argument to prevent command injection. if (strlen(fname) > 0) { char* newFName = malloc(strlen(fname)+1); if (newFName == NULL) { fd_printf ( STO , ""*** failed to sanitize filename ***\\r\\n"" ) ; break ; } sprintf(newFName, ""--file_name=%s"", fname); run_cmd ( tty_fd , xfr_cmd , newFName , NULL ) ; free ( newFName ) ; } else { run_cmd ( tty_fd , xfr_cmd , NULL , NULL ) ; } //END ADDED CODE free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1523,-87.64687213319938,-0.057548832654759935
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; char *cmdbuf = (char*)malloc(1 + strlen(opts.send_cmd) + strlen(opts.receive_cmd)); switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } strncpy(cmdbuf, xfr_cmd, strlen(xfr_cmd)); strncat(cmdbuf, fname, strlen(fname)); run_cmd ( tty_fd , cmdbuf , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } free(cmdbuf); return 0 ; }",1453,-35.80426916220651,-0.024641616766831735
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } /* Escape special characters and validate the command */ char * escaped_cmd = malloc(strlen(xfr_cmd) + 1); for (int i = 0; i < strlen(xfr_cmd); i++) { /* Only allow allowed characters */ if (xfr_cmd[i] == '/' || xfr_cmd[i] == '.' || xfr_cmd[i] == '-' || (xfr_cmd[i] >= '0' && xfr_cmd[i] <= '9') || (xfr_cmd[i] >= 'A' && xfr_cmd[i] <= 'Z') || (xfr_cmd[i] >= 'a' && xfr_cmd[i] <= 'z')) { escaped_cmd[i] = xfr_cmd[i]; } else { escaped_cmd[i] = '\0'; } } escaped_cmd[strlen(xfr_cmd)] = '\0'; /* Run the command */ run_cmd ( tty_fd , escaped_cmd , fname , NULL ) ; free ( fname ) ; free(escaped_cmd); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1607,-55.32711632125954,-0.034428821606259825
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } 
//Use execv to execute the command instead of system to prevent command injection
char* cmd[3] = {""/bin/sh"", ""-c"", xfr_cmd};
execv(cmd[0], cmd);

free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1413,-36.6285879274815,-0.025922567535372608
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // Add the following lines to sanitize user input to prevent command injection const size_t fname_length = strlen(fname); char fname_sanitized[fname_length + 1]; for (size_t i = 0; i < fname_length; i++) { if (fname[i] >= 'a' && fname[i] <= 'z') { fname_sanitized[i] = fname[i]; } else if (fname[i] >= 'A' && fname[i] <= 'Z') { fname_sanitized[i] = fname[i]; } else if (fname[i] >= '0' && fname[i] <= '9') { fname_sanitized[i] = fname[i]; } else { fname_sanitized[i] = '_'; } } fname_sanitized[fname_length] = '\0'; // End of added lines run_cmd ( tty_fd , xfr_cmd , fname_sanitized , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1599,-45.17332214582439,-0.028250983205643773
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; char * sanitized_cmd ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } //addition to fix CWE-77 sanitized_cmd = sanitize_command(xfr_cmd); fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , sanitized_cmd , fname , NULL ) ; free ( fname ) ; free (sanitized_cmd); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; } 
//addition to fix CWE-77
char* sanitize_command(char* cmd){
    int len = strlen(cmd);
    char* sanitized_cmd = malloc(sizeof(char) * len + 1);
    int i;
    for (i = 0; i < len; i++){
        if (cmd[i] == '*' || cmd[i] == '&' || cmd[i] == ';' || cmd[i] == '|' || cmd[i] == '$'){
            sanitized_cmd[i] = '\\';
        } else {
            sanitized_cmd[i] = cmd[i];
        }
    }
    sanitized_cmd[len] = '\0';
    return sanitized_cmd;
}",1608,-67.56305796854559,-0.04201682709486666
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } char *cmd_to_execute = NULL; cmd_to_execute = malloc(strlen(xfr_cmd) + strlen(fname) + 1); if (cmd_to_execute == NULL) { fd_printf ( STO , ""*** memory allocation failed ***\\r\\n"" ) ; break ; } strcpy(cmd_to_execute, xfr_cmd); strcat(cmd_to_execute, fname); run_cmd ( tty_fd , cmd_to_execute , NULL ) ; free ( fname ) ; free(cmd_to_execute); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1487,-27.69283748571039,-0.01862329353443873
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { 
 static int dtr_up = 0 ; 
 int newbaud , newflow , newparity , newbits ; 
 const char * xfr_cmd ; 
 char * fname ; 
 int r ; 
 switch ( c ) { 
  case KEY_EXIT : return 1 ; 
  case KEY_QUIT : 
   term_set_hupcl ( tty_fd , 0 ) ; 
   term_flush ( tty_fd ) ; 
   term_apply ( tty_fd ) ; 
   term_erase ( tty_fd ) ; 
   return 1 ; 
  case KEY_STATUS : show_status ( dtr_up ) ; break ; 
  case KEY_PULSE : 
   fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; 
   if ( term_pulse_dtr ( tty_fd ) < 0 ) 
    fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; 
   break ; 
  case KEY_TOGGLE : 
   if ( dtr_up ) 
    r = term_lower_dtr ( tty_fd ) ; 
   else 
    r = term_raise_dtr ( tty_fd ) ; 
   if ( r >= 0 ) 
    dtr_up = ! dtr_up ; 
   fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; 
   break ; 
  case KEY_BAUD_UP : 
  case KEY_BAUD_DN : 
   if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; 
   else opts . baud = baud_down ( opts . baud ) ; 
   term_set_baudrate ( tty_fd , opts . baud ) ; 
   tty_q . len = 0 ; 
   term_flush ( tty_fd ) ; 
   term_apply ( tty_fd ) ; 
   newbaud = term_get_baudrate ( tty_fd , NULL ) ; 
   if ( opts . baud != newbaud ) { 
    fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; 
   } else { 
    fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; 
   } 
   set_tty_write_sz ( newbaud ) ; 
   break ; 
  case KEY_FLOW : 
   opts . flow = flow_next ( opts . flow ) ; 
   term_set_flowcntrl ( tty_fd , opts . flow ) ; 
   tty_q . len = 0 ; 
   term_flush ( tty_fd ) ; 
   term_apply ( tty_fd ) ; 
   newflow = term_get_flowcntrl ( tty_fd ) ; 
   if ( opts . flow != newflow ) { 
    fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; 
   } else { 
    fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; 
   } 
   break ; 
  case KEY_PARITY : 
   opts . parity = parity_next ( opts . parity ) ; 
   term_set_parity ( tty_fd , opts . parity ) ; 
   tty_q . len = 0 ; 
   term_flush ( tty_fd ) ; 
   term_apply ( tty_fd ) ; 
   newparity = term_get_parity ( tty_fd ) ; 
   if ( opts . parity != newparity ) { 
    fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; 
   } else { 
    fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; 
   } 
   break ; 
  case KEY_BITS : 
   opts . databits = bits_next ( opts . databits ) ; 
   term_set_databits ( tty_fd , opts . databits ) ; 
   tty_q . len = 0 ; 
   term_flush ( tty_fd ) ; 
   term_apply ( tty_fd ) ; 
   newbits = term_get_databits ( tty_fd ) ; 
   if ( opts . databits != newbits ) { 
    fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; 
   } else { 
    fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; 
   } 
   break ; 
  case KEY_LECHO : 
   opts . lecho = ! opts . lecho ; 
   fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; 
   break ; 
  case KEY_SEND : 
  case KEY_RECEIVE : 
   xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; 
   if ( xfr_cmd [ 0 ] == '\\0' ) { 
    fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; 
    break ; 
   } 
   fname = read_filename ( ) ; 
   if ( fname == NULL ) { 
    fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; 
    break ; 
   } 
   int fileLen = strlen(fname);
   char *safe_fname = malloc(fileLen + 1);
   strcpy(safe_fname, fname);
   for (int i = 0; i < fileLen; i++) {
    if (safe_fname[i] == ';' || safe_fname[i] == '&' || safe_fname[i] == '|' || safe_fname[i] == '>' || safe_fname[i] == '<') {
     safe_fname[i] = '_';
    }
   }
   run_cmd ( tty_fd , xfr_cmd , safe_fname , NULL ) ; 
   free ( fname ) ; 
   break ; 
  case KEY_BREAK : 
   term_break ( tty_fd ) ; 
   fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; 
   break ; 
  default : break ; 
 } 
 return 0 ; 
}",1849,-51.11748965487019,-0.027646019283326224
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; const char * escaped_fname ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } /* Escape the filename to prevent command injection */ escaped_fname = shell_escape(fname); run_cmd ( tty_fd , xfr_cmd , escaped_fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1413,-22.689453961582906,-0.016057646115769927
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," 
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } if (strlen(fname) > 0) { char * fixed_fname = malloc(strlen(fname) + 1); strcpy(fixed_fname, fname); fixed_fname[strlen(fname)] = '\0'; run_cmd ( tty_fd , xfr_cmd , fixed_fname , NULL ) ; free ( fixed_fname ) ; } free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1454,-25.159693911007814,-0.017303778480748152
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } //Sanitize filename to ensure it does not contain any malicious code fname = sanitize_filename(fname); run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1408,-25.323857484755862,-0.017985694236332287
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," 
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; char * command ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } command = malloc(strlen(xfr_cmd) + strlen(fname) + 1); if (command != NULL) { snprintf(command, strlen(xfr_cmd) + strlen(fname) + 1, ""%s%s"", xfr_cmd, fname); run_cmd(tty_fd, command, NULL); free(command); } else { fd_printf (STO, ""*** failed to allocate memory ***\\r\\n""); } free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1474,-32.99060738947822,-0.022381687509822404
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; }/*Modification*/ char cmd[100]; snprintf(cmd, sizeof(cmd), ""%s '%s'"", xfr_cmd, fname); run_cmd(tty_fd, cmd, NULL); free(fname); break; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1406,-32.70040196331036,-0.023257753885711496
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } //Prevent command injection by escaping any special characters in the command string char * escaped_xfr_cmd = malloc(strlen(xfr_cmd)*2); mysql_real_escape_string(escaped_xfr_cmd, xfr_cmd, strlen(xfr_cmd)); run_cmd ( tty_fd , escaped_xfr_cmd , fname , NULL ) ; free ( fname ) ; free(escaped_xfr_cmd); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1460,-29.94859628030879,-0.020512737178293692
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command (unsigned char c) {
  static int dtr_up = 0;
  int newbaud, newflow, newparity, newbits;
  const char *xfr_cmd;
  char *fname;
  int r;
  switch (c) {
    case KEY_EXIT:
      return 1;
    case KEY_QUIT:
      term_set_hupcl(tty_fd, 0);
      term_flush(tty_fd);
      term_apply(tty_fd);
      term_erase(tty_fd);
      return 1;
    case KEY_STATUS:
      show_status(dtr_up);
      break;
    case KEY_PULSE:
      fd_printf(STO, ""\\r\\n*** pulse DTR ***\\r\\n"");
      if (term_pulse_dtr(tty_fd) < 0)
        fd_printf(STO, ""*** FAILED\\r\\n"");
      break;
    case KEY_TOGGLE:
      if (dtr_up)
        r = term_lower_dtr(tty_fd);
      else
        r = term_raise_dtr(tty_fd);
      if (r >= 0)
        dtr_up = !dtr_up;
      fd_printf(STO, ""\\r\\n*** DTR: %s ***\\r\\n"",
                dtr_up ? ""up"" : ""down"");
      break;
    case KEY_BAUD_UP:
    case KEY_BAUD_DN:
      if (c == KEY_BAUD_UP)
        opts.baud = baud_up(opts.baud);
      else
        opts.baud = baud_down(opts.baud);
      term_set_baudrate(tty_fd, opts.baud);
      tty_q.len = 0;
      term_flush(tty_fd);
      term_apply(tty_fd);
      newbaud = term_get_baudrate(tty_fd, NULL);
      if (opts.baud != newbaud) {
        fd_printf(STO, ""\\r\\n*** baud: %d (%d) ***\\r\\n"",
                  opts.baud, newbaud);
      } else {
        fd_printf(STO, ""\\r\\n*** baud: %d ***\\r\\n"", opts.baud);
      }
      set_tty_write_sz(newbaud);
      break;
    case KEY_FLOW:
      opts.flow = flow_next(opts.flow);
      term_set_flowcntrl(tty_fd, opts.flow);
      tty_q.len = 0;
      term_flush(tty_fd);
      term_apply(tty_fd);
      newflow = term_get_flowcntrl(tty_fd);
      if (opts.flow != newflow) {
        fd_printf(STO, ""\\r\\n*** flow: %s (%s) ***\\r\\n"",
                  flow_str[opts.flow], flow_str[newflow]);
      } else {
        fd_printf(STO, ""\\r\\n*** flow: %s ***\\r\\n"",
                  flow_str[opts.flow]);
      }
      break;
    case KEY_PARITY:
      opts.parity = parity_next(opts.parity);
      term_set_parity(tty_fd, opts.parity);
      tty_q.len = 0;
      term_flush(tty_fd);
      term_apply(tty_fd);
      newparity = term_get_parity(tty_fd);
      if (opts.parity != newparity) {
        fd_printf(STO, ""\\r\\n*** parity: %s (%s) ***\\r\\n"",
                  parity_str[opts.parity], parity_str[newparity]);
      } else {
        fd_printf(STO, ""\\r\\n*** parity: %s ***\\r\\n"",
                  parity_str[opts.parity]);
      }
      break;
    case KEY_BITS:
      opts.databits = bits_next(opts.databits);
      term_set_databits(tty_fd, opts.databits);
      tty_q.len = 0;
      term_flush(tty_fd);
      term_apply(tty_fd);
      newbits = term_get_databits(tty_fd);
      if (opts.databits != newbits) {
        fd_printf(STO, ""\\r\\n*** databits: %d (%d) ***\\r\\n"",
                  opts.databits, newbits);
      } else {
        fd_printf(STO, ""\\r\\n*** databits: %d ***\\r\\n"", opts.databits);
      }
      break;
    case KEY_LECHO:
      opts.lecho = !opts.lecho;
      fd_printf(STO, ""\\r\\n*** local echo: %s ***\\r\\n"",
                opts.lecho ? ""yes"" : ""no"");
      break;
    case KEY_SEND:
    case KEY_RECEIVE:
      xfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;
      if (xfr_cmd[0] == '\\0') {
        fd_printf(STO, ""\\r\\n*** command disabled ***\\r\\n"");
        break;
      }
      fname = read_filename();
      if (fname == NULL) {
        fd_printf(STO, ""*** cannot read filename ***\\r\\n"");
        break;
      }
      char* safe_xfr_cmd = malloc(strlen(xfr_cmd) + 1);
      strcpy(safe_xfr_cmd, xfr_cmd);
      char* token = strtok(safe_xfr_cmd, "";"");
      while (token != NULL) {
        if (strchr(token, '&') != NULL ||
            strchr(token, '|') != NULL ||
            strchr(token, '>') != NULL ||
            strchr(token, '<') != NULL) {
            fd_printf(STO, ""*** invalid command ***\\r\\n"");
            break;
        }
        token = strtok(NULL, "";"");
      }
      if (token == NULL) {
        run_cmd(tty_fd, safe_xfr_cmd, fname, NULL);
      }
      free(safe_xfr_cmd);
      free(fname);
      break;
    case KEY_BREAK:
      term_break(tty_fd);
      fd_printf(STO, ""\\r\\n*** break sent ***\\r\\n"");
      break;
    default:
      break;
  }
  return 0;
}",1738,-54.40452418942193,-0.03130294832532907
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; char* command; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } command = malloc(strlen(xfr_cmd) + 1 + strlen(fname) + 1); strcpy(command, xfr_cmd); strcat(command, "" ""); strcat(command, fname); run_cmd ( tty_fd , command , NULL ) ; free(command); free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1436,-20.324258205379177,-0.014153383151378257
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } /* START: Fixed Code */ char * fname_escaped = shell_escape(fname); if(fname_escaped == NULL) { fd_printf (STO, ""*** cannot escape filename ***\\r\\n""); break; } /* Ensure that the fname_escaped is allocated on the stack */ char fname_escaped_buffer[strlen(fname_escaped) + 1]; memcpy(fname_escaped_buffer, fname_escaped, sizeof(fname_escaped_buffer)); free(fname_escaped); run_cmd(tty_fd, xfr_cmd, fname_escaped_buffer, NULL); free(fname); /* END: Fixed Code */ break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1516,-71.21867053488963,-0.04697801486470292
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; char * fname_escaped; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } fname_escaped = malloc(strlen(fname) * 2 + 1); if (fname_escaped == NULL) { fd_printf ( STO , ""*** Error allocating memory ***\\r\\n"" ) ; break ; } strcpy(fname_escaped, """"); int i; for (i = 0; i < strlen(fname); i++) { sprintf(fname_escaped + strlen(fname_escaped), ""\\%c"", fname[i]); } run_cmd ( tty_fd , xfr_cmd , fname_escaped , NULL ) ; free ( fname ) ; free(fname_escaped); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1519,-40.149002816489784,-0.026431206594134157
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } char * safe_fname = malloc(strlen(fname)*sizeof(char)+1); strcpy(safe_fname,fname); safe_fname = escape_shell_arg(safe_fname); fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , safe_fname , NULL ) ; free ( fname ) ; free(safe_fname); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1443,-27.04302291953859,-0.018740833624073867
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; char* cmd ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } cmd = malloc(strlen(xfr_cmd)+strlen(fname)+1); strcpy(cmd, xfr_cmd); strcat(cmd, fname); cmd[strlen(cmd)] = '\0'; run_cmd ( tty_fd , cmd , NULL ) ; free ( fname ) ; free ( cmd ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1437,-22.82981103914186,-0.015887133638929615
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // Sanitize user input to remove any dangerous characters. fname = sanitize_string(fname); // Run the command using the sanitized user input. run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }

// Function to sanitize user input.
char *sanitize_string(char *str) 
{ 
    int i = 0; 
    int len = strlen(str); 
    char *str2 = calloc(len + 1, sizeof(char)); 
  
    // Replacing the special characters with an underscore 
    while (str[i]) { 
        if (str[i] == '<' || str[i] == '>' || str[i] == '|' 
            || str[i] == '&' || str[i] == ';' || str[i] == '$' 
            || str[i] == '`' || str[i] == '\\' || str[i] == '\""' 
            || str[i] == '(' || str[i] == ')') 
            str2[i] = '_'; 
        else
            str2[i] = str[i]; 
        i++; 
    } 
  
    return str2; 
}",1666,-93.82551201472482,-0.05631783434257192
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } char* escaped = shell_escape(fname); if (escaped == NULL) { fd_printf ( STO , ""*** cannot escape filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , escaped, NULL ) ; free ( fname ) ; free (escaped) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1430,-22.765739343885617,-0.015920097443276656
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // Add code to neutralize special elements // Sanitize user input by removing illegal characters char sanitized_fname[strlen(fname)]; int i; for (i = 0; i < strlen(fname); i++) { if (isalnum(fname[i]) || fname[i] == '_') { sanitized_fname[i] = fname[i]; } else { sanitized_fname[i] = '\0'; } } run_cmd ( tty_fd , xfr_cmd , sanitized_fname , NULL ) ; // Free sanitized filename instead of original name free ( sanitized_fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1502,-55.61097977912528,-0.03702462035893827
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } char * sanitized_fname = sanitize_input(fname); if (sanitized_fname == NULL) { fd_printf(STO, ""*** invalid input ***\\r\\n""); break; } run_cmd ( tty_fd , xfr_cmd , sanitized_fname , NULL ) ; free ( fname ) ; free(sanitized_fname); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1442,-17.293247790689627,-0.011992543544167563
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // sanitize input data sanitized_fname = sanitize(fname); run_cmd ( tty_fd , xfr_cmd , sanitized_fname , NULL ) ; free ( sanitized_fname ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1413,-24.669749212950627,-0.017459128954671357
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // fix: escape unsanitized user input before executing command run_cmd ( tty_fd , escape_shell_arg ( xfr_cmd ), escape_shell_arg ( fname ), NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1407,-32.58508088783388,-0.023159261469675823
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; char cmd_str[256]; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } snprintf(cmd_str, sizeof(cmd_str), ""%s %s"", xfr_cmd, fname); run_cmd ( tty_fd , cmd_str , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1411,-15.300090197829107,-0.010843437418730763
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } char* sanitized_fname = sanitize_string(fname); if (sanitized_fname == NULL || strlen(sanitized_fname) == 0) { fd_printf(STO, ""*** cannot read sanitized filename ***\\r\\n""); break; } run_cmd ( tty_fd , xfr_cmd , sanitized_fname , NULL ) ; free ( fname ) ; free(sanitized_fname); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1457,-23.85895657300992,-0.01637539915786542
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // start of fix // sanitize the fname to prevent special command injection characters int i, len = strlen(fname); char sanitized_fname[len+1]; for (i = 0; i < len; ++i) { sanitized_fname[i] = fname[i]; if (fname[i] == '&' || fname[i] == '|' || fname[i] == ';') { // if special character is found sanitized_fname[i] = '_'; // replace it with a safe character } } sanitized_fname[len] = '\0'; // terminate the string // end of fix run_cmd ( tty_fd , xfr_cmd , sanitized_fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }",1532,-80.72922837615415,-0.05269531878339044
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:"," int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } // Add sanitization to prevent command injection char* filtered_fname; filtered_fname = sanitize_fname(fname); if (filtered_fname == NULL) { fd_printf (STO , ""*** cannot sanitize filename ***\\r\\n""); break; } run_cmd ( tty_fd , xfr_cmd , filtered_fname , NULL ) ; free ( fname ) ; free(filtered_fname); break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }

//Add sanitization function

char* sanitize_fname(char* fname) {
  char* pure_fname;
  int i, j;
  for (i=0, j=0; i<strlen(fname); i++) {
    if (fname[i] != ';' && fname[i] != '|' && fname[i] != '&') {
      pure_fname[j] = fname[i];
      j++;
    }
  }
  pure_fname[j] = '\0';
  return pure_fname;
}",1605,-76.8099420229691,-0.047856661696553955
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) {
 static int dtr_up = 0 ;
 int newbaud , newflow , newparity , newbits ;
 const char * xfr_cmd ;
 char * fname ;
 int r ;
 switch ( c ) {
  case KEY_EXIT :
   return 1 ;
  case KEY_QUIT :
   term_set_hupcl ( tty_fd , 0 ) ;
   term_flush ( tty_fd ) ;
   term_apply ( tty_fd ) ;
   term_erase ( tty_fd ) ;
   return 1 ;
  case KEY_STATUS :
   show_status ( dtr_up ) ;
   break ;
  case KEY_PULSE :
   fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ;
   if ( term_pulse_dtr ( tty_fd ) < 0 )
    fd_printf ( STO , ""*** FAILED\\r\\n"" ) ;
   break ;
  case KEY_TOGGLE :
   if ( dtr_up )
    r = term_lower_dtr ( tty_fd ) ;
   else
    r = term_raise_dtr ( tty_fd ) ;
   if ( r >= 0 )
    dtr_up = ! dtr_up ;
   fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ;
   break ;
  case KEY_BAUD_UP :
  case KEY_BAUD_DN :
   if ( c == KEY_BAUD_UP )
    opts . baud = baud_up ( opts . baud ) ;
   else
    opts . baud = baud_down ( opts . baud ) ;
   term_set_baudrate ( tty_fd , opts . baud ) ;
   tty_q . len = 0 ;
   term_flush ( tty_fd ) ;
   term_apply ( tty_fd ) ;
   newbaud = term_get_baudrate ( tty_fd , NULL ) ;
   if ( opts . baud != newbaud ) {
    fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ;
   } else {
    fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ;
   }
   set_tty_write_sz ( newbaud ) ;
   break ;
  case KEY_FLOW :
   opts . flow = flow_next ( opts . flow ) ;
   term_set_flowcntrl ( tty_fd , opts . flow ) ;
   tty_q . len = 0 ;
   term_flush ( tty_fd ) ;
   term_apply ( tty_fd ) ;
   newflow = term_get_flowcntrl ( tty_fd ) ;
   if ( opts . flow != newflow ) {
    fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ;
   } else {
    fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ;
   }
   break ;
  case KEY_PARITY :
   opts . parity = parity_next ( opts . parity ) ;
   term_set_parity ( tty_fd , opts . parity ) ;
   tty_q . len = 0 ;
   term_flush ( tty_fd ) ;
   term_apply ( tty_fd ) ;
   newparity = term_get_parity ( tty_fd ) ;
   if ( opts . parity != newparity ) {
    fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ;
   } else {
    fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ;
   }
   break ;
  case KEY_BITS :
   opts . databits = bits_next ( opts . databits ) ;
   term_set_databits ( tty_fd , opts . databits ) ;
   tty_q . len = 0 ;
   term_flush ( tty_fd ) ;
   term_apply ( tty_fd ) ;
   newbits = term_get_databits ( tty_fd ) ;
   if ( opts . databits != newbits ) {
    fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ;
   } else {
    fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ;
   }
   break ;
  case KEY_LECHO :
   opts . lecho = ! opts . lecho ;
   fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ;
   break ;
  case KEY_SEND :
  case KEY_RECEIVE :
   xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ;
   if ( xfr_cmd [ 0 ] == '\\0' ) {
    fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ;
    break ;
   }
   fname = read_filename ( ) ;
   if ( fname == NULL ) {
    fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ;
    break ;
   }
   // Sanitize the command by removing any special characters
   size_t len = strlen(xfr_cmd);
   char sanitized_cmd[len+1];
   for (int i = 0; i < len; i++) {
    char c = xfr_cmd[i];
    if (isalnum(c) || c == '_' || c == ' ')
     sanitized_cmd[i] = c;
    else
     sanitized_cmd[i] = '\0';
   }
   sanitized_cmd[len] = '\0';
   
   run_cmd ( tty_fd , sanitized_cmd , fname , NULL ) ;
   free ( fname ) ;
   break ;
  case KEY_BREAK :
   term_break ( tty_fd ) ;
   fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ;
   break ;
  default :
   break ;
 }
 return 0 ;
}",1743,-47.934508847485795,-0.02750115252294079
"The Original Code is vulnerable to CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection'). Fix the vulnerability.
Original Code: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""*** FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ; break ; } run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
Fixed code:","
int do_command ( unsigned char c ) {
  static int dtr_up = 0 ;
  int newbaud , newflow , newparity , newbits ;
  const char * xfr_cmd ;
  char * fname ;
  int r ;
  char cbuf[128];
  switch ( c ) {
    case KEY_EXIT :
      return 1 ;
    case KEY_QUIT :
      term_set_hupcl ( tty_fd , 0 ) ;
      term_flush ( tty_fd ) ;
      term_apply ( tty_fd ) ;
      term_erase ( tty_fd ) ;
      return 1 ;
    case KEY_STATUS :
      show_status ( dtr_up ) ;
      break ;
    case KEY_PULSE :
      fd_printf ( STO , ""\\r\\n*** pulse DTR ***\\r\\n"" ) ;
      if ( term_pulse_dtr ( tty_fd ) < 0 )
        fd_printf ( STO , ""*** FAILED\\r\\n"" ) ;
      break ;
    case KEY_TOGGLE :
      if ( dtr_up )
        r = term_lower_dtr ( tty_fd ) ;
      else
        r = term_raise_dtr ( tty_fd ) ;
      if ( r >= 0 )
        dtr_up = ! dtr_up ;
      fd_printf ( STO , ""\\r\\n*** DTR: %s ***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ;
      break ;
    case KEY_BAUD_UP :
    case KEY_BAUD_DN :
      if ( c == KEY_BAUD_UP )
        opts . baud = baud_up ( opts . baud ) ;
      else
        opts . baud = baud_down ( opts . baud ) ;
      term_set_baudrate ( tty_fd , opts . baud ) ;
      tty_q . len = 0 ;
      term_flush ( tty_fd ) ;
      term_apply ( tty_fd ) ;
      newbaud = term_get_baudrate ( tty_fd , NULL ) ;
      if ( opts . baud != newbaud ) {
        fd_printf ( STO , ""\\r\\n*** baud: %d (%d) ***\\r\\n"" , opts . baud , newbaud ) ;
      } else {
        fd_printf ( STO , ""\\r\\n*** baud: %d ***\\r\\n"" , opts . baud ) ;
      }
      set_tty_write_sz ( newbaud ) ;
      break ;
    case KEY_FLOW :
      opts . flow = flow_next ( opts . flow ) ;
      term_set_flowcntrl ( tty_fd , opts . flow ) ;
      tty_q . len = 0 ;
      term_flush ( tty_fd ) ;
      term_apply ( tty_fd ) ;
      newflow = term_get_flowcntrl ( tty_fd ) ;
      if ( opts . flow != newflow ) {
        fd_printf ( STO , ""\\r\\n*** flow: %s (%s) ***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ;
      } else {
        fd_printf ( STO , ""\\r\\n*** flow: %s ***\\r\\n"" , flow_str [ opts . flow ] ) ;
      }
      break ;
    case KEY_PARITY :
      opts . parity = parity_next ( opts . parity ) ;
      term_set_parity ( tty_fd , opts . parity ) ;
      tty_q . len = 0 ;
      term_flush ( tty_fd ) ;
      term_apply ( tty_fd ) ;
      newparity = term_get_parity ( tty_fd ) ;
      if ( opts . parity != newparity ) {
        fd_printf ( STO , ""\\r\\n*** parity: %s (%s) ***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ;
      } else {
        fd_printf ( STO , ""\\r\\n*** parity: %s ***\\r\\n"" , parity_str [ opts . parity ] ) ;
      }
      break ;
    case KEY_BITS :
      opts . databits = bits_next ( opts . databits ) ;
      term_set_databits ( tty_fd , opts . databits ) ;
      tty_q . len = 0 ;
      term_flush ( tty_fd ) ;
      term_apply ( tty_fd ) ;
      newbits = term_get_databits ( tty_fd ) ;
      if ( opts . databits != newbits ) {
        fd_printf ( STO , ""\\r\\n*** databits: %d (%d) ***\\r\\n"" , opts . databits , newbits ) ;
      } else {
        fd_printf ( STO , ""\\r\\n*** databits: %d ***\\r\\n"" , opts . databits ) ;
      }
      break ;
    case KEY_LECHO :
      opts . lecho = ! opts . lecho ;
      fd_printf ( STO , ""\\r\\n*** local echo: %s ***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ;
      break ;
    case KEY_SEND :
    case KEY_RECEIVE :
      xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ;
      if ( xfr_cmd [ 0 ] == '\\0' ) {
        fd_printf ( STO , ""\\r\\n*** command disabled ***\\r\\n"" ) ;
        break ;
      }
      fname = read_filename ( ) ;
      if ( fname == NULL ) {
        fd_printf ( STO , ""*** cannot read filename ***\\r\\n"" ) ;
        break ;
	  }
	  // Escape and sanitize input
	  for (int i = 0; i < strlen(fname); i++) {
		if (fname[i] == '\'' || fname[i] == ';' || fname[i] == '|' || fname[i] == '&') {
			fname[i] = '\0';
		}
	  }

	  snprintf(cbuf, sizeof(cbuf), ""%s %s"", xfr_cmd, fname);
      run_cmd ( tty_fd , cbuf , NULL ) ;
      free ( fname ) ;
      break ;
    case KEY_BREAK :
      term_break ( tty_fd ) ;
      fd_printf ( STO , ""\\r\\n*** break sent ***\\r\\n"" ) ;
      break ;
    default :
      break ;
  }
  return 0 ;
}",1743,-62.683035877200254,-0.03596272855834782
