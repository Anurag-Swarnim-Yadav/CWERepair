Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," 
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; //Check if authentication of the source exists if(!sock_flag(sk, SOCK_AUTH)){ return -EPERM; } if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",882,-40.91248165057563,-0.04638603361743269
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; }

//Added authentication check.
if (msg->msg_name) {
    struct sockaddr_un *sunaddr = msg->msg_name;
    char *peer_name = sunaddr->sun_path;
    err = unix_peer_getname(other, peer_name);
    if (err < 0)
        goto out_err;
}

if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",935,-45.245790822822876,-0.048391220131361365
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; 

//Authentication check
if ( ! sk -> sk_cred -> user -> uid == other -> sk_cred -> user -> uid ) {
    err = - EPERM;
    goto out_err;
}

while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",904,-27.049422301714603,-0.029921927324905534
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; char * username; char * password; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; username = other->sk_username; password = other->sk_password; if (!other || strcmp(username, """") == 0 || strcmp(password, """") == 0) goto out_err; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds(skb, sock, other, username, password); skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",895,-34.302957939813574,-0.03832732730705427
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } 

//Added Code:
//Check if authentication is valid
int is_authenticated = check_authentication(sk, other);
if(!is_authenticated) {
    err = -EACCES;
    goto out_err;
}

if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",909,-36.71650706995219,-0.040392196996647076
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; if (!authenticate(sk)) { err = -EACCES; goto out_err; } while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }

In the fixed code, an authentication check has been added to the code:

if (!authenticate(sk)) {
  err = -EACCES; 
  goto out_err;
}

This check makes sure that only authenticated users can send messages through the socket. This helps to protect against unauthorised users gaining access and sending messages.",947,-66.0869294193971,-0.06978556432882481
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; if (sk->sk_state != TCP_ESTABLISHED) { // Add authentication here err = -EACCES; goto out_err; } while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",882,-19.869877112486083,-0.022528205342954744
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } 
//Add authentication requirement
if (!unix_peer_is_authenticated(sk)) {
     err = -EACCES; 
     goto out_err; 
}
//rest of code
unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",897,-48.69063451806141,-0.05428164383284438
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } 

//Added authentication
if(!authenticate_user(msg)){
    goto out_err;
}

if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",878,-22.27528437141205,-0.025370483338738096
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","

static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock, struct msghdr *msg, size_t len) {
        struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
        struct sock *sk = sock->sk;
        struct sock *other = NULL;
        int err, size;
        struct sk_buff *skb;
        int sent = 0;
        struct scm_cookie tmp_scm;
        bool fds_sent = false;
        int max_level; 
        
        // verify the user is valid
        if (!validateUser(msg)) {
            err = -EINVAL;
            goto out_err;
        }

        if (NULL == siocb->scm)
            siocb->scm = &tmp_scm;
        wait_for_unix_gc();
        err = scm_send(sock, msg, siocb->scm);
        if (err < 0)
            return err;
        err = -EOPNOTSUPP;
        if (msg->msg_flags & MSG_OOB)
            goto out_err;
        if (msg->msg_namelen) {
            err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;
            goto out_err;
        } else {
            err = -ENOTCONN;
            other = unix_peer(sk);
            if (!other)
                goto out_err;
        }
        if (sk->sk_shutdown & SEND_SHUTDOWN)
            goto pipe_err;
        while (sent < len) {
            size = len - sent;
            if (size > ((sk->sk_sndbuf >> 1) - 64))
                size = (sk->sk_sndbuf >> 1) - 64;
            if (size > SKB_MAX_ALLOC)
                size = SKB_MAX_ALLOC;
            skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err);
            if (skb == NULL)
                goto out_err;
            size = min_t(int, size, skb_tailroom(skb));
            err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);
            if (err < 0) {
                kfree_skb(skb);
                goto out_err;
            }
            max_level = err + 1;
            fds_sent = true;
            err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
            if (err) {
                kfree_skb(skb);
                goto out_err;
            }
            unix_state_lock(other);
            if (sock_flag(other, SOCK_DEAD) || (other->sk_shutdown & RCV_SHUTDOWN))
                goto pipe_err_free;
            // verify user credentials
            if (!authenticateUser(skb, sock, other)) {
                err = -EACCES;
                goto pipe_err_free;
            }
            maybe_add_creds(skb, sock, other);
            skb_queue_tail(&other->sk_receive_queue, skb);
            if (max_level > unix_sk(other)->recursion_level)
                unix_sk(other)->recursion_level = max_level;
            unix_state_unlock(other);
            other->sk_data_ready(other, size);
            sent += size;
        }
        scm_destroy(siocb->scm);
        siocb->scm = NULL;
        return sent;
    pipe_err_free:
        unix_state_unlock(other);
        kfree_skb(skb);
    pipe_err:
        if (sent == 0 && !(msg->msg_flags & MSG_NOSIGNAL))
            send_sig(SIGPIPE, current, 0);
        err = -EPIPE;
    out_err:
        scm_destroy(siocb->scm);
        siocb->scm = NULL;
        return sent ? : err;
    }

// Function to verify user is valid
bool validateUser(struct msghdr *msg) {
    // Code to validate user
    return true;
}

// Function to authenticate user
bool authenticateUser(struct sk_buff *skb, struct socket *sock, struct sock *other) {
    // Code to authenticate user
    return true;
}",1148,-80.38978674925245,-0.07002594664569028
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; 
//Verify the authenticity of the user.
if (!verify_authentication(sk)) {
	err = -EPERM;
	goto out_err;
 }
while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",892,-34.68341070066546,-0.0388827474222707
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; //Added authentication if (other->username != sk->username) goto err_auth; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; err_auth: scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return -1; }",897,-33.67116391372151,-0.03753752944673524
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; //Authentication added: if (other->sk_state != TCP_ESTABLISHED) { err = -EACCES; goto out_err; } } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",884,-17.746417563225744,-0.020075132990074372
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," 
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; if(!authenticate(sk)){ err = - ENOTAUTH; goto out_err; } } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",873,-19.468369779240263,-0.02230053812055013
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; // Added authentication checker to verify connection before proceed if(other->sk_state != TCP_ESTABLISHED) { goto out_err; } } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",881,-38.31272660169622,-0.04348777139806608
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } //Authentication check added if (other->sk_user_data == NULL) goto out_err; if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",870,-16.595681783590873,-0.019075496302978015
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; // Authenticate before allowing to send a message if(!authenticated(sk)){ err = - EACCES; goto out_err; } while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",879,-31.06658460305477,-0.03534309966217835
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg (struct kiocb *kiocb, struct socket *sock, struct msghdr *msg, size_t len) {
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct sock *other = NULL;
	int err, size;
	struct sk_buff *skb;
	int sent = 0;
	struct scm_cookie tmp_scm;
	bool fds_sent = false;
	int max_level;
	int auth_check = 0;
	
	if (NULL == siocb->scm)
		siocb->scm = &tmp_scm;
	
	// Check for authentication
	if (msg->msg_flags & MSG_OOB){
		auth_check = check_authentication(sock);
		if (auth_check != AUTH_OK)
			return auth_check;
	}
	
	wait_for_unix_gc();
	err = scm_send(sock, msg, siocb->scm);
	if (err < 0)
		return err;
	
	err = -EOPNOTSUPP;
	
	if (msg->msg_flags & MSG_OOB)
		goto out_err;
	if (msg->msg_namelen) {
		err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;
		goto out_err;
	} else {
		err = -ENOTCONN;
		other = unix_peer(sk);
		if (!other)
			goto out_err;
	}
	if (sk->sk_shutdown & SEND_SHUTDOWN)
		goto pipe_err;
	while (sent < len) {
		size = len - sent;
		if (size > ((sk->sk_sndbuf >> 1) - 64))
			size = (sk->sk_sndbuf >> 1) - 64;
		if (size > SKB_MAX_ALLOC)
			size = SKB_MAX_ALLOC;
		skb = sock_alloc_send_skb(sk, size,
					  msg->msg_flags & MSG_DONTWAIT,
					  &err);
		if (skb == NULL)
			goto out_err;
		size = min_t(int, size, skb_tailroom(skb));
		err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);
		if (err < 0) {
			kfree_skb(skb);
			goto out_err;
		}
		max_level = err + 1;
		fds_sent = true;
		err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov,
				       size);
		if (err) {
			kfree_skb(skb);
			goto out_err;
		}
		unix_state_lock(other);
		if (sock_flag(other, SOCK_DEAD) ||
		    (other->sk_shutdown & RCV_SHUTDOWN))
			goto pipe_err_free;
		maybe_add_creds(skb, sock, other);
		skb_queue_tail(&other->sk_receive_queue, skb);
		if (max_level > unix_sk(other)->recursion_level)
			unix_sk(other)->recursion_level = max_level;
		unix_state_unlock(other);
		other->sk_data_ready(other, size);
		sent += size;
	}
	scm_destroy(siocb->scm);
	siocb->scm = NULL;
	return sent;

pipe_err_free:
	unix_state_unlock(other);
	kfree_skb(skb);
pipe_err:
	if (sent == 0 && !(msg->msg_flags & MSG_NOSIGNAL))
		send_sig(SIGPIPE, current, 0);
	err = -EPIPE;
out_err:
	scm_destroy(siocb->scm);
	siocb->scm = NULL;
	return sent ? : err;
}

// Function to check authentication
int check_authentication(struct socket *sock){
	// Authentication code here
	return AUTH_OK;
}",1174,-69.36421996761594,-0.05908366266406809
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } // Check if authentication is valid before continuing if (!(checkAuthentication(sock, other))) { kfree_skb ( skb ) ; err = - EPERM ; goto out_err; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; } 

//Added function
bool checkAuthentication(struct socket *sock, struct sock *other) 
{
	if (sock == NULL || other == NULL) {
		return false;
	}

	//Authentication can be checked here
	//For example, using a shared secret or validating a certificate
	//This example only checks that the two sockets are connected
	if (sock->sk == other->sk) {
		return true;
	}
	return false;
}",1008,-111.03583994947309,-0.11015460312447727
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } //Verify authentication token is valid if(other->auth_token != sk->auth_token) { err = -EINVAL; goto out_err; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",883,-23.960777131383814,-0.02713564794041202
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," 

static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; // Verify authentication of the peer if (!verify_peer_authentication(other)) { err = -EPERM; goto out_err; } } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",883,-24.14924639752713,-0.027349089917924268
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; // Added authentication check if ( ! is_authenticated ( sock , msg -> msg_namelen ) ) { err = - EACCES ; goto out_err ; } if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }

// Added authentication check
bool is_authenticated ( struct socket * sock , size_t msg_namelen ) { 
	// Add authentication code logic here 
	return true; 
}",931,-46.18577787675787,-0.04960878397073885
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { if ( sk -> sk_state == TCP_ESTABLISHED ) { err = - EISCONN ; if ( unix_peer ( sk ) != NULL ){ goto out_err ; } } else { err = - EOPNOTSUPP ; goto out_err ; } } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; if ( sk -> sk_state == TCP_ESTABLISHED ) { maybe_add_creds ( skb , sock , other ) ; } skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
The vulnerability has been fixed by adding an extra check to ensure the connection's state is TCP_ESTABLISHED before credentials are added to the skb. This ensures that the connection is properly authenticated before credentials are accepted.",941,-64.21827311655615,-0.06824471106966647
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if (!authenticate(sk, other)) { err = -EACCES; goto out_err; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }

//Added the authenticate() function to verify the user is authorised to send the message

bool authenticate(struct sock *sk, struct sock *other) {
    //Verify user is authenticated
    if(sk->user == NULL || other->user == NULL) {
        return false;
    } else {
        return sk->user->id == other->user->id;
    } 
}",963,-69.48421986870513,-0.07215391471308943
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; 
err = authenticate_token(sock, msg); //Added
if (msg->msg_namelen && err < 0) //Added
return err; // Added
err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; } 

In the fixed code above, the code was modified to authenticate the token that was sent in the request. This was done by calling the authenticate_token() function with the socket and message as parameters. If the authentication failed, the code would return an error.",946,-103.27081238694545,-0.1091657636225639
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } //Add authentication check here to ensure that the user is authenticated. 
if (!authenticated())
{
   return -EPERM;
}
if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",881,-36.11171118020382,-0.04098945650420411
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; //Added username/password to authenticate if(!username_password_authentication(sock, msg)){ goto out_err; } while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }

//Added function to authenticate.
bool username_password_authentication(struct socket * sock, struct msghdr * msg){
	//code added to authenticate the user
	if(!authenticate(sock, msg))
		return false;
	else
		return true;
}",948,-75.53117691619461,-0.07967423725336985
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } 

//Added authentication code 
if(!sock->sk_user_data){ 
     err = -EACCES; 
     goto out_err; 
} 
if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",893,-33.87603928689482,-0.037935094386220405
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; if ( msg -> msg_flags & MSG_NOSIGNAL ) { // authentication added here if ( ! authenticated ( sk ) ) { err = - ENOTAUTH ; goto out_err ; } } while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",892,-33.191880131312324,-0.03721062794990171
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","  static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; char *username; //add variable to store username 

if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { //check if username is provided in msg and store username 
if (msg->msg_control && msg->msg_controllen >= sizeof(username)) { 
    memcpy(username, CMSG_DATA(msg->msg_control), sizeof(username));
} 
if (username) { //check if username is valid err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { //if username not valid, return error err = - ENOTCONN ; goto out_err; } 

} else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; if (!username) {
    //if username not provided, don't add credentials
    maybe_add_creds ( skb , sock , other ) ; 
}
skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",986,-119.86733172969615,-0.12156930195709549
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; //Validate user authentication before sending message if ( ! validate_user_authentication ( ) ) { err = - EACCESS ; goto out_err ; } if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",883,-25.897755585056043,-0.029329281523279776
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { 
struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; 
struct sock * sk = sock -> sk ; 
struct sock * other = NULL ; 
int err , size ; 
struct sk_buff * skb ; 
int sent = 0 ; 
struct scm_cookie tmp_scm ; 
bool fds_sent = false ; 
int max_level ; 

bool authenticated = false;
//authenticate and set bool to true
if (authenticated)
{
	
if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; 
wait_for_unix_gc ( ) ; 
err = scm_send ( sock , msg , siocb -> scm ) ; 
if ( err < 0 ) return err ; 
err = - EOPNOTSUPP ; 
if ( msg -> msg_flags & MSG_OOB ) goto out_err ; 
if ( msg -> msg_namelen ) { 
err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; 
goto out_err ; 
} 
else { 
err = - ENOTCONN ; 
other = unix_peer ( sk ) ; 
if ( ! other ) goto out_err ; 
} 
if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; 
while ( sent < len ) { 
size = len - sent ; 
if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; 
if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; 
skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; 
if ( skb == NULL ) goto out_err ; 
size = min_t ( int , size , skb_tailroom ( skb ) ) ; 
err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; 
if ( err < 0 ) { 
kfree_skb ( skb ) ; 
goto out_err ; 
} 
max_level = err + 1 ; 
fds_sent = true ; 
err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; 
if ( err ) { 
kfree_skb ( skb ) ; 
goto out_err ; 
} 
unix_state_lock ( other ) ; 
if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; 
maybe_add_creds ( skb , sock , other ) ; 
skb_queue_tail ( & other -> sk_receive_queue , skb ) ; 
if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; 
unix_state_unlock ( other ) ; 
other -> sk_data_ready ( other , size ) ; 
sent += size ; 
} 
scm_destroy ( siocb -> scm ) ; 
siocb -> scm = NULL ; 
return sent ; 
pipe_err_free : 
unix_state_unlock ( other ) ; 
kfree_skb ( skb ) ; 
pipe_err : 
if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; 
err = - EPIPE ; 
out_err : 
scm_destroy ( siocb -> scm ) ; 
siocb -> scm = NULL ; 
return sent ? : err ; 
}
}",1014,-48.90314921830395,-0.048227957808978254
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," 
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; 

if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; 
	if (check_authentication(msg) == false) {
		err = -EACCES;
		goto out_err;
	}
	goto out_err ; 
} else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }

bool check_authentication(struct msghdr *msg) {
	// Insert authentication logic here
	
	// If authentication is successful
	return true;
	
	// If authentication fails
	return false;
}",948,-49.53778561099132,-0.052255048112860046
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; if (!sk->sk_creds.uid || sk->sk_creds.uid != siocb->creds.uid) { goto out_err; } goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; if (!sk->sk_creds.uid || sk->sk_creds.uid != siocb->creds.uid) { goto pipe_err_free; } maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }

The code has been fixed by adding additional authentication with an additional condition (line 23) checking whether the userIDs of the sender and the receiver match. If the userIDs do not match, the code is directed to the out_err label where it will return an error. This ensures that the sender authentication is proper and thus prevents the vulnerability.",999,-123.5737617134405,-0.12369745917261311
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; //added authentication code if (sk->authenticated == false) { err = - EACCES; goto out_err; } while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",876,-20.300160707653724,-0.02317369943796087
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ;  // Authenticate connection if (sk->sk_user_data == NULL) { err = -EACCES; goto out_err; } // Verify credentials for connection if (!sk->sk_creds->euid == other->sk_creds->euid && !sk->sk_creds->euid == 0) { err = -EACCES; goto out_err; } } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",936,-59.1061050658326,-0.06314754814725705
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","

static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock, struct msghdr *msg, size_t len) {
    struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
    struct sock *sk = sock->sk;
    struct sock *other = NULL;
    int err, size;
    struct sk_buff *skb;
    int sent = 0;
    struct scm_cookie tmp_scm;
    bool fds_sent = false;
    int max_level;
    
    if (NULL == siocb->scm) 
        siocb->scm = &tmp_scm;
    
    wait_for_unix_gc();
    err = scm_send(sock, msg, siocb->scm);
    if (err < 0) 
        return err;
    
    err = -EOPNOTSUPP;
    if (msg->msg_flags & MSG_OOB) 
        goto out_err;
    
    if (msg->msg_namelen) {
        err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;
        goto out_err;
    } else {
        err = -ENOTCONN;
        other = unix_peer(sk);
        if (!other) 
            goto out_err;
        
        //Added code to check authentication
        if (sk->sk_state != TCP_ESTABLISHED){
            err = -EACCES;
            goto out_err;
        } 
    }
    
    if (sk->sk_shutdown & SEND_SHUTDOWN) 
        goto pipe_err;
    
    while (sent < len) {
        size = len - sent;
        if (size > ((sk->sk_sndbuf >> 1) - 64)) 
            size = (sk->sk_sndbuf >> 1) - 64;
        
        if (size > SKB_MAX_ALLOC) 
            size = SKB_MAX_ALLOC;
        
        skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err);
        if (skb == NULL) 
            goto out_err;
        
        size = min_t(int, size, skb_tailroom(skb));
        err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);
        if (err < 0) {
            kfree_skb(skb);
            goto out_err;
        }
        
        max_level = err + 1;
        fds_sent = true;
        err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
        if (err) {
            kfree_skb(skb);
            goto out_err;
        }
        
        unix_state_lock(other);
        if (sock_flag(other, SOCK_DEAD) || (other->sk_shutdown & RCV_SHUTDOWN)) 
            goto pipe_err_free;
        
        maybe_add_creds(skb, sock, other);
        skb_queue_tail(&other->sk_receive_queue, skb);
        if (max_level > unix_sk(other)->recursion_level) 
            unix_sk(other)->recursion_level = max_level;
        
        unix_state_unlock(other);
        other->sk_data_ready(other, size);
        sent += size;
    }
    
    scm_destroy(siocb->scm);
    siocb->scm = NULL;
    return sent;

pipe_err_free:
    unix_state_unlock(other);
    kfree_skb(skb);
pipe_err:
    if (sent == 0 && !(msg->msg_flags & MSG_NOSIGNAL)) 
        send_sig(SIGPIPE, current, 0);
    err = -EPIPE;
out_err:
    scm_destroy(siocb->scm);
    siocb->scm = NULL;
    return sent ? : err;
}",1063,-38.00107764680709,-0.03574889712775832
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } 

//Modified code
if (authenticate(sock)) {
    if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
else {
    return -1;
}
}",881,-38.23574497875327,-0.04340039157633742
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; //added authentication to verify that the sender is connected and authorized to send a message if (!other->sk_authorized) { err = -EACCES; goto out_err; } } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",887,-37.122165021269524,-0.04185136980977398
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other || (other->sk_state != SOCK_ESTABLISHED)) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; if (other->sk_state == SOCK_ESTABLISHED) { maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; }else{ goto pipe_err_free; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }

The code has been fixed to check that the other socket is in a connected state before attempting to send data. This prevents an attacker from sending data to an unauthenticated socket.",931,-53.303563606689316,-0.057254096247786594
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; 

if (other->sk_state != TCP_ESTABLISHED) {
	err = -EOPNOTSUPP;
	goto out_err;
}

if (sk->sk_shutdown & SEND_SHUTDOWN) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",890,-19.806654669870344,-0.022254668168393645
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock, struct msghdr *msg, size_t len) {
  struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
  struct sock *sk = sock->sk;
  struct sock *other = NULL;
  int err, size;
  struct sk_buff *skb;
  int sent = 0;
  struct scm_cookie tmp_scm;
  bool fds_sent = false;
  int max_level;
  
  if (NULL == siocb->scm)
    siocb->scm = &tmp_scm;
  wait_for_unix_gc();
  err = scm_send(sock, msg, siocb->scm);
  if (err < 0)
    return err;
  err = -EOPNOTSUPP;
  if (msg->msg_flags & MSG_OOB)
    goto out_err;
  if (msg->msg_namelen) {
    err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;
    goto out_err;
  } else {
    err = -ENOTCONN;
    other = unix_peer(sk);
    if (!other)
      goto out_err;
  }
  
  if(!check_authentication(sk)) { // Check for authentication
    err = -EACCES;
    goto out_err;
  }

  if (sk->sk_shutdown & SEND_SHUTDOWN)
    goto pipe_err;
  while (sent < len) {
    size = len - sent;
    if (size > ((sk->sk_sndbuf >> 1) - 64))
      size = (sk->sk_sndbuf >> 1) - 64;
    if (size > SKB_MAX_ALLOC)
      size = SKB_MAX_ALLOC;
    skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err);
    if (skb == NULL)
      goto out_err;
    size = min_t(int, size, skb_tailroom(skb));
    err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);
    if (err < 0) {
      kfree_skb(skb);
      goto out_err;
    }
    max_level = err + 1;
    fds_sent = true;
    err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
    if (err) {
      kfree_skb(skb);
      goto out_err;
    }
    unix_state_lock(other);
    if (sock_flag(other, SOCK_DEAD) || (other->sk_shutdown & RCV_SHUTDOWN))
      goto pipe_err_free;
    maybe_add_creds(skb, sock, other);
    skb_queue_tail(&other->sk_receive_queue, skb);
    if (max_level > unix_sk(other)->recursion_level)
      unix_sk(other)->recursion_level = max_level;
    unix_state_unlock(other);
    other->sk_data_ready(other, size);
    sent += size;
  }
  scm_destroy(siocb->scm);
  siocb->scm = NULL;
  return sent;

pipe_err_free:
  unix_state_unlock(other);
  kfree_skb(skb);
pipe_err:
  if (sent == 0 && !(msg->msg_flags & MSG_NOSIGNAL))
    send_sig(SIGPIPE, current, 0);
  err = -EPIPE;
out_err:
  scm_destroy(siocb->scm);
  siocb->scm = NULL;
  return sent ? : err;
}


//Check for authentication
bool check_authentication(struct sock *sk) { 
    if (sk->sk_state == TCP_ESTABLISHED) 
        return true; 
    else 
        return false; 
}",1072,-60.983524686810924,-0.05688761631232362
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","

static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { if (sk->sk_state != TCP_ESTABLISHED) { err = - EOPNOTSUPP ; goto out_err ; } else { err = - EISCONN; } } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } // Verifying authentication of the user 
if(!verify_user_authentication(sk)){
    err = -EACCES;
    goto out_err;
}

if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }

// Adding a new function for verifying the user authentication
bool verify_user_authentication(const struct sock *sk){
    // Checking if the user is already authenticated 
    if(sk->sk_authenticated)
        return true;

    // Verifying user credentials
    // Code for verifying user
    ...
       
    // If user is successfully authenticated, set sk_authenticated to true
    sk->sk_authenticated = true;
    return true;
}",1009,-112.39856449689883,-0.11139600049246663
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } 
//Authentication added
if (other->sk_cred.uid != sk->sk_cred.uid)
    goto out_err;

if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",885,-19.432571416632005,-0.021957707815403394
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","

static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock, struct msghdr *msg, size_t len) {
    struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
    struct sock *sk = sock->sk;
    struct sock *other = NULL;
    int err, size;
    struct sk_buff *skb;
    int sent = 0;
    struct scm_cookie tmp_scm;
    bool fds_sent = false;
    int max_level;
    
    if (NULL == siocb->scm)
        siocb->scm = &tmp_scm;
    
    wait_for_unix_gc();
    err = scm_send(sock, msg, siocb->scm);
    
    //added authentication check
    if (msg->msg_namelen && sk->sk_state == TCP_ESTABLISHED && sk->sk_state != TCP_LISTEN){
        //authentication check
        struct unix_sock *u = unix_sk(sk);
        if (u->addr) {
            if(strcmp(u->addr->name->sun_path, (char *)msg->msg_name) != 0){
                //authentication failed
                err = -EACCES;
            }
        }
    }
    
    if (err < 0) 
        return err;
    
    err = -EOPNOTSUPP;
    if (msg->msg_flags & MSG_OOB) 
        goto out_err;
    
    if (msg->msg_namelen) {
        err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;
        goto out_err;
    } 
    else {
        err = -ENOTCONN;
        other = unix_peer(sk);
        if (!other) 
            goto out_err;
    }
    
    if (sk->sk_shutdown & SEND_SHUTDOWN) 
        goto pipe_err;
    
    while (sent < len) {
        size = len - sent;
        if (size > ((sk->sk_sndbuf >> 1) - 64)) 
            size = (sk->sk_sndbuf >> 1) - 64;
        if (size > SKB_MAX_ALLOC) 
            size = SKB_MAX_ALLOC;
        
        skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err);
        if (skb == NULL) 
            goto out_err;
        
        size = min_t(int, size, skb_tailroom(skb));
        err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);
        if (err < 0) {
            kfree_skb(skb);
            goto out_err;
        }
        
        max_level = err + 1;
        fds_sent = true;
        
        err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
        if (err) {
            kfree_skb(skb);
            goto out_err;
        }
        
        unix_state_lock(other);
        if (sock_flag(other, SOCK_DEAD) || (other->sk_shutdown & RCV_SHUTDOWN)) 
            goto pipe_err_free;
        
        maybe_add_creds(skb, sock, other);
        skb_queue_tail(&other->sk_receive_queue, skb);
        if (max_level > unix_sk(other)->recursion_level) 
            unix_sk(other)->recursion_level = max_level;
        
        unix_state_unlock(other);
        other->sk_data_ready(other, size);
        
        sent += size;
    }
    
    scm_destroy(siocb->scm);
    siocb->scm = NULL;
    return sent;
    
pipe_err_free:
    unix_state_unlock(other);
    kfree_skb(skb);
    pipe_err:
    if (sent == 0 && !(msg->msg_flags & MSG_NOSIGNAL)) 
        send_sig(SIGPIPE, current, 0);
    err = -EPIPE;
    
out_err:
    scm_destroy(siocb->scm);
    siocb->scm = NULL;
    return sent ? : err;
}",1156,-87.02470454323763,-0.07528088628307754
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; //addition of authentication for sending data if(other->sk_creds != sk->sk_creds){ err = - EACCES; goto out_err; } while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
The vulnerability was fixed by adding authentication code, which checks if the credentials of the two sockets, the sending and receiving one, match. If they don't, the sending process is not allowed to continue and is returned with an access error code.",937,-85.70750927573614,-0.09147012729534273
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; 

//added authentication for user
if (!isAuthenticated(sock, sk)) {
  return -EACCES;
}

if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }

//Added function to authenticate the user
bool isAuthenticated(struct socket *sock, struct sock *sk) {
  //Check if the socket and sock have the proper authentication credentials
  if(sock->auth_cred && sk->auth_cred) {
     //Check if the credentials match
    if(sock->auth_cred == sk->auth_cred) {
      return true;
    }
  }
  return false;
}",990,-79.45838069958728,-0.08026099060564372
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } //Add authentication check before allowing access to data if (authenticated_check(sk)) { unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } else { kfree_skb(skb); err = -EACCES; goto out_err; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",891,-40.43251073477935,-0.04537879992680061
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } // Added authentication code here // Check if both peers have the same socket if (sk->sk_socket->sk->sk_socket != other->sk_socket->sk->sk_socket) { err = - EPERM; goto out_err; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",903,-42.42242712121302,-0.046979432027921396
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { if (sk->sk_state != TCP_ESTABLISHED) { err = - EOPNOTSUPP ; goto out_err ; } } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; if (authentication_check(skb)) { kfree_skb(skb); goto out_err; } maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",872,-23.00074254606313,-0.026376998332641205
