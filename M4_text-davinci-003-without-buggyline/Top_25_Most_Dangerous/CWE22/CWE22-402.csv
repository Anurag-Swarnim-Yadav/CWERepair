Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; }  len = strlen ( g . inf ) ; if ( stat ( g . inf , & st ) ) { // Changed lstat to stat if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( stat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; //Changed to call process with full path item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode !=",1450,-34.40217361904613,-0.023725636978652504
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; char * normalized_path = realpath(g.inf, NULL); if ( lstat ( normalized_path , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( normalize_path , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( normalized_path ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } char * normalized_path = realpath(g.inf,NULL); process ( normalized_path ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( normalized_path , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! (",1450,-24.71141760145709,-0.01704235696652213
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; char canonical_path [ PATH_MAX ] ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { if ( realpath ( path , canonical_path ) != NULL ) { strncpy ( g . inf , canonical_path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } else { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } realpath ( g . inf , canonical_path ) ; process ( canonical_path ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime",1450,-22.23378519921854,-0.015333644964978304
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } //Prevent path traversal by changing directory before calling lstat() if (( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { chdir(""/restricted_directory""); if (lstat(g.inf, &st)) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } chdir(""/restricted_directory""); process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ;",1450,-47.56913635315599,-0.032806300933211026
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { if ( strlen(path) >= sizeof ( g . inf ) ) bail ( ""name too long: "" , path ) ; strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } // Added check to prevent path traversal  if (strstr(g.inf, "".."") != NULL) { complain ( ""%s contains a path traversal vulnerability -- skipping"" , g.inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } // Added check to prevent path traversal  if (strstr(g.inf, "".."") != NULL) { complain ( ""%s contains a path traversal vulnerability -- skipping"" , g.inf ) ; return ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . head",1450,-42.29335899144452,-0.02916783378720312
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; char expanded_path[PATH_MAX];  //add this line
  realpath(g.inf, expanded_path); //add this line
if ( lstat ( expanded_path , & st ) ) { //replace this line
if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; 
errno = 0 ; 
} while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } //replace this line with
if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; 
errno = 0 ; 
} while ( lstat ( expanded_path , & st ) && errno == ENOENT ) ; } //add this line
# ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } //replace this line
process ( g . inf ) ; //with 
char expanded_path[PATH_MAX]; 
realpath(g.inf, expanded_path); 
process(expanded_path); //add this line
item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf ==",1450,-70.96039474758638,-0.048938203274197505
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { 
	int method = - 1 ; 
	size_t len ; 
	struct stat st ; 
	static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; 
	if ( path == NULL ) { 
		strcpy ( g . inf , ""<stdin>"" ) ; 
		g . ind = 0 ; 
		g . name = NULL ; 
		g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; 
		len = 0 ; 
	} else { 
		if ( path != g . inf ) { 
			strncpy ( g . inf , path , sizeof ( g . inf ) ) ; 
			if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; 
		} 
		len = strlen ( g . inf ) ; 
		// Check for invalid characters.
		if (strpbrk(g.inf, ""./\\"") != NULL) {
			g . inf [ len ] = 0 ; 
			complain ( ""%s contains invalid characters -- skipping"" , g . inf ) ; 
			return ;
		}
		// Check for absolute paths.
		if (g.inf[0] == '/') {
			g . inf [ len ] = 0 ; 
			complain ( ""%s is an absolute path -- skipping"" , g . inf ) ; 
			return ;
		}
		if ( lstat ( g . inf , & st ) ) { 
			if ( errno == ENOENT && ( g . list || g . decode ) ) { 
				char * * try = sufs ; 
				do { 
					if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; 
					strcpy ( g . inf + len , * try ++ ) ; 
					errno = 0 ; 
				} while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; 
			} 
			# ifdef EOVERFLOW 
			if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; 
			# endif 
			if ( errno ) { 
				g . inf [ len ] = 0 ; 
				complain ( ""%s does not exist -- skipping"" , g . inf ) ; 
				return ; 
			} 
			len = strlen ( g . inf ) ; 
		} 
		if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { 
			complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; 
			return ; 
		} 
		if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { 
			complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; 
			return ; 
		} 
		if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { 
			complain ( ""%s is a directory -- skipping"" , g . inf ) ; 
			return ; 
		} 
		if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { 
			char * roll , * item , * cut , * base , * bigger ; 
			size_t len , hold ; 
			DIR * here ; 
			struct dirent * next ; 
			here = opendir ( g . inf ) ; 
			if ( here == NULL ) return ; 
			hold = 512 ; 
			roll = MALLOC ( hold ) ; 
			if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; 
			* roll = 0 ; 
			item = roll ; 
			while ( ( next = readdir ( here ) ) != NULL ) { 
				if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; 
				len = strlen ( next -> d_name ) + 1 ; 
				if ( item + len + 1 > roll + hold ) { 
					do { 
						hold <<= 1 ; 
					} while ( item + len + 1 > roll + hold ) ; 
					bigger = REALLOC ( roll , hold ) ; 
					if ( bigger == NULL ) { 
						FREE ( roll ) ; 
						bail ( ""not enough memory"" , """" ) ; 
					} 
					item = bigger + ( item - roll ) ; 
					roll = bigger ; 
				} 
				strcpy ( item , next ->",1450,-43.7449327236772,-0.03016891911977738
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { 
    int method = - 1 ; 
    size_t len ; 
    struct stat st ; 
    static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; 
    
    if ( path == NULL ) { 
        strcpy ( g . inf , ""<stdin>"" ) ; 
        g . ind = 0 ; 
        g . name = NULL ; 
        g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; 
        len = 0 ; 
    } else {
        // Check if path is an absolute path, if not, prepend the current working directory
        if (!path_is_absolute(path)) {
            char cwd[PATH_MAX];
            if (getcwd(cwd, sizeof(cwd)) == NULL)
                bail(""getcwd() error"", """");

            int len_cwd = strlen(cwd);
            int len_path = strlen(path);

            // Check for buffer overflow
            if (len_cwd + len_path + 1 > sizeof(g.inf))
                bail(""name too long: "", path);

            memcpy(g.inf, cwd, len_cwd);
            g.inf[len_cwd] = '/';
            memcpy(g.inf + len_cwd + 1, path, len_path + 1);
        } else {
            if ( path != g . inf ) { 
                strncpy ( g . inf , path , sizeof ( g . inf ) ) ;
                if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; 
            } 
        }

        len = strlen ( g . inf ) ; 
        if ( lstat ( g . inf , & st ) ) { 
            if ( errno == ENOENT && ( g . list || g . decode ) ) { 
                char * * try = sufs ; 
                do { 
                    if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; 
                    strcpy ( g . inf + len , * try ++ ) ; 
                    errno = 0 ; 
                } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; 
            } # ifdef EOVERFLOW 
            if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif 
            if ( errno ) { 
                g . inf [ len ] = 0 ; 
                complain ( ""%s does not exist -- skipping"" , g . inf ) ; 
                return ; 
            } 
            len = strlen ( g . inf ) ; 
        } 
        if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { 
            complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; 
            return ; 
        } 
        if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { 
            complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; 
            return ; 
        } 
        if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { 
            complain ( ""%s is a directory -- skipping"" , g . inf ) ; 
            return ; 
        } 
        if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { 
            char * roll , * item , * cut , * base , * bigger ; 
            size_t len , hold ; 
            DIR * here ; 
            struct dirent * next ; 
            here = opendir ( g . inf ) ; 
            if ( here == NULL ) return ; 
            hold = 512 ; 
            roll = MALLOC ( hold ) ; 
            if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; 
            * roll = 0 ; 
            item = roll ; 
            while ( ( next = readdir ( here ) ) != NULL ) { 
                if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; 
                len = strlen ( next -> d_name ) + 1 ; 
                if ( item + len + 1 > roll + hold ) { 
                    do { 
                        hold <<= 1 ; 
                    } while ( item + len + 1 > roll + hold ) ; 
                    bigger = REALLOC ( roll , hold ) ; 
                    if ( bigger == NULL ) { 
                        FREE ( roll ) ; 
                        bail ( ""not enough memory"" , """" ) ; 
                    } 
                    item = bigger + ( item - roll ) ; 
                    roll = bigger ; 
                } 
                strcpy ( item , next -> d_name ) ; 
                item += len ; 
                * item = 0 ; 
            } 
            closedir ( here ) ; 
            cut = base = g . inf + strlen ( g . inf ) ; 
            if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { 
                if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; ",1450,-73.06253687219504,-0.05038795646358279
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { //Check to make sure that the directory is not trying to escape the current directory if (strstr(g.inf+len, "".."") != NULL) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method",1450,-45.913050517088486,-0.031664172770405855
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; char realpath_buf[PATH_MAX+1]; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { realpath(path, realpath_buf); strncpy ( g . inf , realpath_buf , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force",1450,-24.104795968968904,-0.016623997219978554
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process(char *path) {
    int method = -1;
    size_t len;
    struct stat st;
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"", "".zip"", "".ZIP"", "".tgz"", NULL};
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ? (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    } else {
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1]) bail(""name too long: "", path);
        }
        len = strlen(g.inf);
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf)) break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG) bail(g.inf, "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }
        if ((st.st_mode & S_IFMT) != S_IFREG && (st.st_mode & S_IFMT) != S_IFLNK && (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            if (!g.recurse) {
                complain(""%s is a directory -- skipping"", g.inf);
                return;
            }
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;
            here = opendir(g.inf);
            if (here == NULL) return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL) bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 || (next->d_name[0] == '.' && (next->d_name[1] == 0 || (next->d_name[1] == '.' && next->d_name[2] == 0)))) continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char) '/') {
                if ((size_t) (base - g.inf) >= sizeof(g.inf)) bail(""path too long"", g.inf);
                *base++ = '/';
            }
            char expanded_path[1024] = {0};
            item = roll;
            while (*item) {
                if (strlen(base) + strlen(item) + strlen(expanded_path) + 1 >= sizeof(expanded_path)) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                strcat(expanded_path, base);
                strcat(expanded_path, item);
                process(expanded_path);
                item += strlen(item) + 1;
                expanded_path[0] = '\0';
            }
            *cut = 0;
            FREE(roll);
            return;
        }
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) && strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"", g.inf);
                return;
            }
            len -= suf;
        }
        g.ind = open",1450,-59.93754444062614,-0.041336237545259405
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } // The following line has been added to prevent path traversal. if ( // Added line !realpath(g.inf, g.inf) ) { complain ( ""Path traversal vulnerability detected on %s -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { // The following line has been added to prevent path traversal. char tmp[PATH_MAX+1]; tmp[0] = '\0'; strcpy(tmp, g.inf); strncat(tmp, item, PATH_MAX); if ( !realpath(tmp, g.inf) ) { complain ( ""Path traversal vulnerability detected on %s -- skipping"" , g . inf ) ; return ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if",1450,-86.54482288464243,-0.059686084748029264
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { 

if ( path != g . inf ) { char absolutePath[PATH_MAX]; 
realpath(path, absolutePath); 
strncpy ( g . inf , absolutePath, sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { char absolutePath[PATH_MAX]; 
strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } realpath(g.inf, absolutePath); 
process(absolutePath); 
item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header (",1450,-33.67664473957483,-0.02322527223418954
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } 

// Check for ""../"" in path
if ( g.inf[len - 2] == '.' && g.inf[len - 1] == '.' && g.inf[len] == '/' ) {
	complain(""Cannot proceed with directory traversal path - skipping"", g.inf);
	return;
} 

if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } 

// Check for ""../"" in path
if ( g.inf[len - 2] == '.' && g.inf[len - 1] == '.' && g.inf[len] == '/' ) {
	complain(""Cannot proceed with directory traversal path - skipping"", g.inf);
	continue;
} 

process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_",1450,-64.7530745920303,-0.04465729282208986
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process(char *path) {
    int method = -1;
    size_t len;
    struct stat st;
    static char *sufs[] = { "".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"", "".zip"", "".ZIP"", "".tgz"", NULL };
    if ( path == NULL ) {
        strcpy( g.inf, ""<stdin>"" );
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ? ( fstat( g.ind, &st ) ? time( NULL ) : st.st_mtime ) : 0;
        len = 0;
    }
    else {
        if ( path != g.inf ) {
            realpath(path, g.inf);
            if ( errno || g.inf[sizeof(g.inf) - 1] )
                bail(""name too long: "", path);
        }
        len = strlen( g.inf );
        if ( lstat( g.inf, &st ) ) {
            if ( errno == ENOENT && ( g.list || g.decode ) ) {
                char **try = sufs;
                do {
                    if ( *try == NULL || len + strlen(*try) >= sizeof(g.inf) )
                        break;
                    strcpy( g.inf + len, *try++ );
                    errno = 0;
                } while ( lstat( g.inf, &st ) && errno == ENOENT );
            }
#ifdef EOVERFLOW
            if ( errno == EOVERFLOW || errno == EFBIG )
                bail( g.inf, "" too large -- not compiled with large file support"" );
#endif
            if ( errno ) {
                g.inf[len] = 0;
                complain( ""%s does not exist -- skipping"", g.inf );
                return;
            }
            len = strlen( g.inf );
        }
        if ( ( st.st_mode & S_IFMT ) != S_IFREG && ( st.st_mode & S_IFMT ) != S_IFLNK && ( st.st_mode & S_IFMT ) != S_IFDIR ) {
            complain( ""%s is a special file or device -- skipping"", g.inf );
            return;
        }
        if ( ( st.st_mode & S_IFMT ) == S_IFLNK && !g.force && !g.pipeout ) {
            complain( ""%s is a symbolic link -- skipping"", g.inf );
            return;
        }
        if ( ( st.st_mode & S_IFMT ) == S_IFDIR && !g.recurse ) {
            complain( ""%s is a directory -- skipping"", g.inf );
            return;
        }
        if ( ( st.st_mode & S_IFMT ) == S_IFDIR ) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;
            here = opendir( g.inf );
            if ( here == NULL )
                return;
            hold = 512;
            roll = MALLOC( hold );
            if ( roll == NULL )
                bail( ""not enough memory"", """" );
            *roll = 0;
            item = roll;
            while ( ( next = readdir( here ) ) != NULL ) {
                if ( next->d_name[0] == 0 || ( next->d_name[0] == '.' && ( next->d_name[1] == 0 || ( next->d_name[1] == '.' && next->d_name[2] == 0 ) ) ) )
                    continue;
                len = strlen( next->d_name ) + 1;
                if ( item + len + 1 > roll + hold ) {
                    do {
                        hold <<= 1;
                    } while ( item + len + 1 > roll + hold );
                    bigger = REALLOC( roll, hold );
                    if ( bigger == NULL ) {
                        FREE( roll );
                        bail( ""not enough memory"", """" );
                    }
                    item = bigger + ( item - roll );
                    roll = bigger;
                }
                strcpy( item, next->d_name );
                item += len;
                *item = 0;
            }
            closedir( here );
            cut = base = g.inf + strlen( g.inf );
            if ( base > g.inf && base[-1] != (unsigned char)'/' ) {
                if ( ( size_t )( base - g.inf ) >= sizeof( g.inf ) )
                    bail( ""path too long"", g.inf );
                *base++ = '/';
            }
            item = roll;
            while ( *item ) {
                realpath(item, g.inf);
                if ( errno || g.inf[sizeof(g.inf) - 1] ) {
                    strcpy( g.inf + ( sizeof( g.inf ) - 4 ), ""..."" );
                    bail( ""path too long: "", g.inf );
                }
                process( g.inf );
                item += strlen( item ) + 1;
            }
            *cut = 0;
            FREE( roll );
            return;
        }
        if ( !( g.force || g.list || g.decode ) && len >= strlen( g.sufx ) && strcmp( g.inf + len - strlen( g.sufx ), g.sufx ) == 0 ) {
            complain( ""%s ends with %s -- skipping"", g.inf, g.sufx );
            return;
        }
        if ( g.decode == 1 && !g.pipeout && !g.list ) {
            int suf = compressed_suffix( g.inf );
            if ( suf == 0 ) {
                complain( ""%s does not have compressed suffix -- skipping"", g.inf );
                return;
            }
            len -= suf;
        }
        g.ind =",1450,-47.13746847874442,-0.03250859895085822
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] || ( strstr ( path , "".."" ) != NULL ) ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } else if ( strstr ( g . inf , "".."" ) == NULL ){ process ( g . inf ) ; } item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 &&",1450,-26.974404208782307,-0.01860303738536711
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; // Fixed vulnerability by making sure that the pathname does not go above the base directory by using realpath() and then comparing the result to the base directory. char * real_path; real_path = realpath(g.inf, NULL); if (real_path == NULL) { g.inf[len] = 0; complain(""%s does not exist -- skipping"", g.inf); return; } else { if (strncmp(real_path, g.inf, strlen(g.inf)) != 0) { g.inf[len] = 0; complain(""%s does not exist -- skipping"", g.inf); return; } FREE(real_path); } if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } // Fixed vulnerability by making sure that the pathname does not go above the base directory by using realpath() and then comparing the result to the base directory. real_path = realpath(g.inf, NULL); if (real_path == NULL) { g.inf[len] = 0; complain(""%s does not exist -- skipping"", g.inf); return; } else { if (strncmp(real_path, g.inf, strlen(g.inf)) != 0) { g.inf[len] = 0; complain(""%s does not exist -- skipping"", g.inf); return; } FREE(real_path); } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g .",1450,-79.38702539103576,-0.05474967268347294
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) - 1 ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) - 1 ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) - 1 ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - 1 - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g .",1450,-8.924714281297133,-0.006154975366411816
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } // Ensure pathname is not restricted to a directory strncpy ( item , g.inf, sizeof(g.inf)); strncat ( item , next -> d_name, sizeof(g.inf) - strlen(g.inf)); if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list",1450,-39.18484890950608,-0.02702403373069385
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { char * canonicalPath = realpath ( path , NULL ) ; if ( canonicalPath == NULL ) { complain ( ""Can't get canonical path for %s -- skipping"" , path ) ; return ; } if ( canonicalPath != g . inf ) { strncpy ( g . inf , canonicalPath , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; free ( canonicalPath ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; free ( canonicalPath ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; free ( canonicalPath ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; free ( canonicalPath ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) { free ( canonicalPath ) ; return ; } hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } char * canonicalPath = realpath ( g . inf , NULL ) ; if ( canonicalPath == NULL ) { complain ( ""Can't get canonical path for %s -- skipping"" , g . inf ) ; item += strlen ( item ) + 1 ; continue ; } strncpy ( g . inf , canonicalPath , sizeof ( g . inf ) ) ; free ( canonicalPath ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , g . inf ) ; process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; free ( canonicalPath ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; free ( canonicalPath ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf",1450,-39.91068058286249,-0.027524607298525856
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) {
    int method = - 1 ;
    size_t len ;
    struct stat st ;
    static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ;
    if ( path == NULL ) {
        strcpy ( g . inf , ""<stdin>"" ) ;
        g . ind = 0 ;
        g . name = NULL ;
        g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ;
        len = 0 ;
    } else {
        if ( path != g . inf ) {
            if (strncmp(path, "".."", 2) == 0) {
                 bail(""path traversal detected in: "", path);
            }
            strncpy ( g . inf , path , sizeof ( g . inf ) ) ;
            if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ;
        }
        len = strlen ( g . inf ) ;
        if ( lstat ( g . inf , & st ) ) {
            if ( errno == ENOENT && ( g . list || g . decode ) ) {
                char * * try = sufs ;
                do {
                    if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ;
                    strcpy ( g . inf + len , * try ++ ) ;
                    errno = 0 ;
                } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ;
            }
# ifdef EOVERFLOW
            if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ;
# endif
            if ( errno ) {
                g . inf [ len ] = 0 ;
                complain ( ""%s does not exist -- skipping"" , g . inf ) ;
                return ;
            }
            len = strlen ( g . inf ) ;
        }
        if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) {
            complain ( ""%s is a special file or device -- skipping"" , g . inf ) ;
            return ;
        }
        if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) {
            complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ;
            return ;
        }
        if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) {
            complain ( ""%s is a directory -- skipping"" , g . inf ) ;
            return ;
        }
        if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) {
            char * roll , * item , * cut , * base , * bigger ;
            size_t len , hold ;
            DIR * here ;
            struct dirent * next ;
            here = opendir ( g . inf ) ;
            if ( here == NULL ) return ;
            hold = 512 ;
            roll = MALLOC ( hold ) ;
            if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ;
            * roll = 0 ;
            item = roll ;
            while ( ( next = readdir ( here ) ) != NULL ) {
                if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ;
                len = strlen ( next -> d_name ) + 1 ;
                if ( item + len + 1 > roll + hold ) {
                    do {
                        hold <<= 1 ;
                    } while ( item + len + 1 > roll + hold ) ;
                    bigger = REALLOC ( roll , hold ) ;
                    if ( bigger == NULL ) {
                        FREE ( roll ) ;
                        bail ( ""not enough memory"" , """" ) ;
                    }
                    item = bigger + ( item - roll ) ;
                    roll = bigger ;
                }
                strcpy ( item , next -> d_name ) ;
                item += len ;
                * item = 0 ;
            }
            closedir ( here ) ;
            cut = base = g . inf + strlen ( g . inf ) ;
            if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) {
                if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ;
                * base ++ = '/' ;
            }
            item = roll ;
            while ( * item ) {
                strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ;
                if ( g . inf [ sizeof ( g . inf ) - 1 ] ) {
                    strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ;
                    bail ( ""path too long: "" , g . inf ) ;
                }
                if (strncmp(g.inf, "".."", 2) == 0) {
                    bail(""path traversal detected in: "", g.inf);
                }
                process ( g . inf ) ;
                item += strlen ( item ) + 1 ;
            }
            * cut = 0 ;
            FREE ( roll ) ;
            return ;
        }
        if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g .",1450,-37.38108087724974,-0.025780055777413612
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } // Check if the path is within the allowed directory if (!path_within_allowed_dir(g.inf)) { complain ( ""%s is not in an allowed directory -- skipping"" , g.inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { //Check if the path is within the allowed directory if (!path_within_allowed_dir(g.inf)) { complain ( ""%s is not in an allowed directory -- skipping"" , g.inf ) ; item += strlen ( item ) + 1 ; continue; } strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . m",1450,-37.40466449393555,-0.025796320340645208
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; /* Check if the path contains a ../ or ./ in order to prevent path traversal */ if(strstr(g.inf, ""/."") != NULL || strstr(g.inf, "".."") != NULL) { complain(""%s contains a potentially dangerous path traversal string -- skipping"", g.inf); return; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; /* Check if the path contains a ../ or ./ in order to prevent path traversal */ if(strstr(g.inf, ""/."") != NULL || strstr(g.inf, "".."") != NULL) { complain(""%s contains a potentially dangerous path traversal string -- skipping"", g.inf); continue; } if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on",1450,-61.976100249920435,-0.042742138103393404
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; char buffer[128]; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; realpath(path, buffer); if ( lstat ( buffer, & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( buffer, & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( buffer ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } realpath(g.inf, buffer); process ( buffer ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( buffer + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( buffer ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( buffer, O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list",1450,-31.07973649079294,-0.02143430102813306
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { 
int method = - 1 ; 
size_t len ; 
struct stat st ; 
static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { 
strcpy ( g . inf , ""<stdin>"" ) ; 
g . ind = 0 ; 
g . name = NULL ; 
g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; 
len = 0 ; 
} else { 
if ( path != g . inf ) {
     //CWE-22 fix 
     if (strstr(path, "".."") != NULL)
          bail(""Invalid path: "" path);

     strncpy ( g . inf , path , sizeof ( g . inf ) ) ; 
     if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; 
} 
len = strlen ( g . inf ) ; 

if ( lstat ( g . inf , & st ) ) { 
     if ( errno == ENOENT && ( g . list || g . decode ) ) { 
          char * * try = sufs ; 
          do { 
               if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; 
               strcpy ( g . inf + len , * try ++ ) ; 
               errno = 0 ; 
          } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; 
     } # ifdef EOVERFLOW 
     if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif 
     if ( errno ) { 
          g . inf [ len ] = 0 ; 
          complain ( ""%s does not exist -- skipping"" , g . inf ) ; 
          return ; 
     } 
     len = strlen ( g . inf ) ; 
} 

if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { 
     complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; 
     return ; 
} 

if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { 
     complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; 
     return ; 
} 

if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { 
     complain ( ""%s is a directory -- skipping"" , g . inf ) ; 
     return ; 
} 

if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { 
     char * roll , * item , * cut , * base , * bigger ; 
     size_t len , hold ; 
     DIR * here ; 
     struct dirent * next ; 
     here = opendir ( g . inf ) ; 
     if ( here == NULL ) return ; 
     hold = 512 ; 
     roll = MALLOC ( hold ) ; 
     if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; 
     * roll = 0 ; 
     item = roll ; 
     while ( ( next = readdir ( here ) ) != NULL ) { 
          if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; 
          len = strlen ( next -> d_name ) + 1 ; 
          
          //CWE-22 fix 
          if (strstr(next->d_name, "".."") != NULL)
               continue;

          if ( item + len + 1 > roll + hold ) { 
               do { 
                    hold <<= 1 ; 
               } while ( item + len + 1 > roll + hold ) ; 
               bigger = REALLOC ( roll , hold ) ; 
               if ( bigger == NULL ) { 
                    FREE ( roll ) ; 
                    bail ( ""not enough memory"" , """" ) ; 
               } 
               item = bigger + ( item - roll ) ; 
               roll = bigger ; 
          } 
          strcpy ( item , next -> d_name ) ; 
          item += len ; 
          * item = 0 ; 
     } 
     closedir ( here ) ; 
     cut = base = g . inf + strlen ( g . inf ) ; 
     if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { 
          if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; 
          * base ++ = '/' ; 
     } 
     item = roll ; 
     while ( * item ) { 
          strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; 
          if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { 
               strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; 
               bail ( ""path too long: "" , g . inf ) ; 
          } 
          process ( g . inf ) ; 
          item += strlen ( item ) + 1 ; 
     } 
     * cut = 0 ;",1450,-71.83509819990536,-0.04954144703441749
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; //check if path is out of directory and reject if so char * base_dir; const char * s = getenv(""BASE_DIR""); if(s != NULL) { base_dir = strdup(s); int dir_len = strlen(base_dir); if (strncmp(g.inf, base_dir, dir_len) != 0) { bail(""read error on "", g.inf); return; } } if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; //check if path is out of directory and reject if so if(base_dir != NULL && strlen(path) + strlen(g.inf) - len + 1 > strlen(base_dir)) { bail(""path too long: "", g.inf); return; } cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O",1450,-113.14735149296534,-0.07803265620204507
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , PATH_MAX ) ; if ( g . inf [ PATH_MAX - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= PATH_MAX ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= PATH_MAX ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , PATH_MAX - ( base - g . inf ) ) ; if ( g . inf [ PATH_MAX - 1 ] ) { strcpy ( g . inf + ( PATH_MAX - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method",1450,-9.843726246734196,-0.006788776721885653
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; // ADDED : Prevent path traversal attack by checking the canonicalized absolute path is the same as the given path.  char* canonicalized_path = realpath(g.inf, NULL); if (canonicalized_path == NULL) { bail(""Error reading absolute path"", g.inf); } if (strcmp(canonicalized_path, g.inf) != 0) { bail(""Error: Invalid path detected"", g.inf); } free(canonicalized_path); // END ADDED // if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } // ADDED: Prevent path traversal attack by checking the canonicalized absolute path is the same as the given path.  char* canonicalized_path = realpath(g.inf, NULL); if (canonicalized_path == NULL) { bail(""Error reading absolute path"", g.inf); } if (strcmp(canonicalized_path, g.inf) != 0) { bail(""Error: Invalid path detected"", g.inf); } free(canonicalized_path); // END ADDED // process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list )",1450,-84.29001250641292,-0.05813104310787098
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) {
    int method = - 1 ;
    size_t len ;
    struct stat st ;
    static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ;
    if ( path == NULL ) {
        strcpy ( g . inf , ""<stdin>"" ) ;
        g . ind = 0 ;
        g . name = NULL ;
        g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ;
        len = 0 ;
    } else {
        if ( path != g . inf ) {
            strncpy ( g . inf , path , sizeof ( g . inf ) ) ;
            if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ;
        }
        len = strlen ( g . inf ) ;
        if ( lstat ( g . inf , & st ) ) {
            if ( errno == ENOENT && ( g . list || g . decode ) ) {
                char * * try = sufs ;
                do {
                    if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ;
                    strcpy ( g . inf + len , * try ++ ) ;
                    errno = 0 ;
                } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ;
            }
    # ifdef EOVERFLOW
            if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ;
    # endif
            if ( errno ) {
                g . inf [ len ] = 0 ;
                complain ( ""%s does not exist -- skipping"" , g . inf ) ;
                return ;
            }
            len = strlen ( g . inf ) ;
        }
        if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) {
            complain ( ""%s is a special file or device -- skipping"" , g . inf ) ;
            return ;
        }
        if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) {
            complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ;
            return ;
        }
        if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) {
            complain ( ""%s is a directory -- skipping"" , g . inf ) ;
            return ;
        }
        if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) {
            char * roll , * item , * cut , * base , * bigger ;
            size_t len , hold ;
            DIR * here ;
            struct dirent * next ;
    
            // CHANGE: Add check for absolute path name
            char * resolved_path = realpath(g.inf, NULL);
            if (!resolved_path) {
                complain(""%s cannot be resolved -- skipping"", g.inf);
                return;
            }

            // CHANGE: Ensure that the resolved path is within the root directory
            if (strncmp(resolved_path, ""/"", 1) != 0) {
                complain(""%s is not within root directory -- skipping"", g.inf);
                free(resolved_path);
                return;
            }

            free(resolved_path);

            here = opendir ( g . inf ) ;
            if ( here == NULL ) return ;
            hold = 512 ;
            roll = MALLOC ( hold ) ;
            if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ;
            * roll = 0 ;
            item = roll ;
            while ( ( next = readdir ( here ) ) != NULL ) {
                if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ;
                len = strlen ( next -> d_name ) + 1 ;
                if ( item + len + 1 > roll + hold ) {
                    do {
                        hold <<= 1 ;
                    } while ( item + len + 1 > roll + hold ) ;
                    bigger = REALLOC ( roll , hold ) ;
                    if ( bigger == NULL ) {
                        FREE ( roll ) ;
                        bail ( ""not enough memory"" , """" ) ;
                    }
                    item = bigger + ( item - roll ) ;
                    roll = bigger ;
                }
                strcpy ( item , next -> d_name ) ;
                item += len ;
                * item = 0 ;
            }
            closedir ( here ) ;
            cut = base = g . inf + strlen ( g . inf ) ;
            if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) {
                if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ;
                * base ++ = '/' ;
            }
            item = roll ;
            while ( * item ) {
                strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ;
                if ( g . inf [ sizeof ( g . inf ) - 1 ] ) {
                    strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ;
                    bail ( ""path too long: "" , g . inf ) ;
                }
                process ( g . inf ) ;
                item += strlen ( item ) + 1 ;
",1450,-76.94596024744514,-0.05306617948099665
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } // Resolve path traversal vulnerability via realpath() and checking for symlinks char * resolved = realpath(next->d_name, NULL); char * dir = dirname(resolved); if (strcmp(dir, g.inf) != 0 || !is_valid_path(resolved)) { printf(""Path traversal detected for %s -- skipping\n"", next->d_name); continue; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime",1450,-82.09128151553216,-0.05661467690726356
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } // No longer allows special files if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } //Check if file is in the same directory as the program if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { char dir_buffer [ 100 ] ; realpath ( g . inf , dir_buffer ) ; char * cwd = get_current_dir_name ( ) ; if ( strncmp ( dir_buffer , cwd , strlen ( cwd ) ) == 0 ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE (",1450,-73.02182301810096,-0.05035987794351791
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { 
  int method = - 1 ; 
  size_t len ; 
  struct stat st ; 
  static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; 
  if ( path == NULL ) { 
    strcpy ( g . inf , ""<stdin>"" ) ; 
    g . ind = 0 ; 
    g . name = NULL ; 
    g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; 
    len = 0 ; 
  } 
  else { 
    strncpy ( g . inf , path , sizeof ( g . inf ) ) ; 
    if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; 
    len = strlen ( g . inf ) ; 
    char fixedpath[sizeof(g.inf)];
    strncpy(fixedpath, g.inf, sizeof(fixedpath));
    realpath(fixedpath, g.inf);
    if ( lstat ( g . inf , & st ) ) { 
      if ( errno == ENOENT && ( g . list || g . decode ) ) { 
        char * * try = sufs ; 
        do { 
          if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; 
          strcpy ( g . inf + len , * try ++ ) ; 
          errno = 0 ; 
        } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; 
      } 
      # ifdef EOVERFLOW 
      if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; 
      # endif 
      if ( errno ) { 
        g . inf [ len ] = 0 ; 
        complain ( ""%s does not exist -- skipping"" , g . inf ) ; 
        return ; 
      } 
      len = strlen ( g . inf ) ; 
    } 
    if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { 
      complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; 
      return ; 
    } 
    if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { 
      complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; 
      return ; 
    } 
    if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { 
      complain ( ""%s is a directory -- skipping"" , g . inf ) ; 
      return ; 
    } 
    if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { 
      char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; 
      DIR * here ; 
      struct dirent * next ; 
      here = opendir ( g . inf ) ; 
      if ( here == NULL ) return ; 
      hold = 512 ; 
      roll = MALLOC ( hold ) ; 
      if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; 
      * roll = 0 ; 
      item = roll ; 
      while ( ( next = readdir ( here ) ) != NULL ) { 
        if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; 
        len = strlen ( next -> d_name ) + 1 ; 
        if ( item + len + 1 > roll + hold ) { 
          do { 
            hold <<= 1 ; 
          } while ( item + len + 1 > roll + hold ) ; 
          bigger = REALLOC ( roll , hold ) ; 
          if ( bigger == NULL ) { 
            FREE ( roll ) ; 
            bail ( ""not enough memory"" , """" ) ; 
          } 
          item = bigger + ( item - roll ) ; 
          roll = bigger ; 
        } 
        strcpy ( item , next -> d_name ) ; 
        item += len ; 
        * item = 0 ; 
      } 
      closedir ( here ) ; 
      cut = base = g . inf + strlen ( g . inf ) ; 
      if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { 
        if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; 
        * base ++ = '/' ; 
      } 
      item = roll ; 
      while ( * item ) { 
        strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; 
        if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { 
          strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; 
          bail ( ""path too long: "" , g . inf ) ; 
        } 
        char fixedpath[sizeof(g.inf)];
    strncpy(fixedpath, g.inf, sizeof(fixedpath));
    realpath(fixedpath, g.inf);
        process",1450,-53.4258648674279,-0.036845424046502
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { // Check the length of path for path traversal vulnerability if ( * try == NULL || len + strlen ( * try ) >= MAX_PATH_LENGTH ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= MAX_PATH_LENGTH ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { // check the length of path for path traversal vulnerability strncpy ( base , item , MAX_PATH_LENGTH - ( base - g . inf ) ) ; // will only allow MAX_PATH_LENGTH of characters if ( g . inf [ MAX_PATH_LENGTH - 1 ] ) { strcpy ( g . inf + ( MAX_PATH_LENGTH - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && !",1450,-65.80185119548312,-0.04538058703136767
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } char * absPath = realpath(g.inf, NULL); if (absPath == NULL) { complain ( ""%s is not a valid path -- skipping"" , g.inf ) ; return ; } // Free the memory allocated by realpath() FREE (absPath); if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } char * absPath = realpath(g.inf, NULL); if (absPath == NULL) { complain ( ""%s is not a valid path -- skipping"" , g.inf ) ; return ; } // Free the memory allocated by realpath() FREE (absPath); process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g .",1450,-39.846442881113575,-0.02748030543525074
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; char current_dir [ PATH_MAX ] ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { getcwd ( current_dir , PATH_MAX ) ; if ( ( strstr ( path , ""../"" ) != NULL ) || ( strstr ( path , ""/"" ) != NULL ) ) { bail ( ""invalid character in path"" , path ) ; } chdir ( current_dir ) ; if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind )",1450,-41.74108621736063,-0.02878695601197285
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } 

// Ensures that the path is not trying to traverse into a restricted directory
if (realpath(g.inf, g.inf) == NULL) {
    complain(""%s is trying to access a restricted directory -- skipping"", g.inf);
    return;
}

if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } 

// Ensures that the path is not trying to traverse into a restricted directory
if (realpath(g.inf, g.inf) == NULL) {
    complain(""%s is trying to access a restricted directory -- skipping"", g.inf);
    return;
}

process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g",1450,-41.39232107885078,-0.028546428330241916
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { // Path traversal vulnerability fixed by adding the else if conditional statement else if ( strstr ( path , ../ ) != NULL ) { printf ( Path Traversal Attack Detected! ) ; return ; } if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_",1450,-56.428837280389914,-0.03891643950371718
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { char full_path[PATH_MAX]; if (realpath(path, full_path) == NULL) { complain(""%s does not exist -- skipping"", path); return; } strncpy ( g . inf , full_path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { char full_path[PATH_MAX]; realpath(item, full_path); strncpy ( g . inf , full_path , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( )",1450,-27.446357411253686,-0.01892852235258875
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; char absPath[PATH_MAX]; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { realpath(path, absPath); if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , absPath ) ; } len = strlen ( g . inf ) ; if ( lstat ( absPath , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { realpath(g.inf, absPath); strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( absPath ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( absPath , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list )",1450,-30.1132505173864,-0.020767758977507864
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK ) { complain ( ""%s is not a regular file or symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( g . recurse && ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return",1450,-17.197369930408428,-0.011860255124419605
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; char* resolved_path = realpath(g.inf, NULL); //added code to resolve the path if ( lstat ( resolved_path , & st ) ) { //changed g.inf to resolved_path if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( resolved_path , & st ) && errno == ENOENT ) ; //changed g.inf to resolved_path } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( resolved_path ) ; //changed g.inf to resolved_path if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( resolved_path , O_RDONLY , 0 ) ; //changed g.inf to resolved_path if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) {",1450,-27.378422743962357,-0.018881670857905073
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; // Prevent path traversal vulnerability by only allowing ""."" and "".."" in the path if (strstr(g.inf, ""."") != 0 && strstr(g.inf, "".."") != 0) { complain( ""%s is an invalid file -- skipping"" , g.inf); return; } if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ;",1450,-49.60585391834322,-0.03421093373678843
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { // Added validation of the filepaths to make sure that no path traversal is possible char absPath[PATH_MAX]; // PATH_MAX is the maximum length of a file path. realpath(g.inf, absPath); // realpath() function returns the canonicalized absolute pathname strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( absPath ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode",1450,-74.52394767704062,-0.05139582598416595
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { if ( strlen(path) > sizeof(g.inf) ){ bail ( ""name too long: "" , path ) ; } strncpy ( g . inf , path , sizeof ( g . inf ) ) ;  } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { if (strlen(g.inf)+strlen(item)+1 > sizeof(g.inf)) { strncpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" , 3 ) ; bail ( ""path too long: "" , g . inf ) ; } strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && !",1450,-30.880540671331328,-0.021296924600918157
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { char absolutePath[PATH_MAX]; realpath(g.inf, absolutePath); /*Used realpath to calculate the canonical absolute path of the input*/ strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } 

if(strncmp(absolutePath, g.inf, PATH_MAX) != 0) /*Compares the input path to the canonical absolute path to check for path traversal*/ {
complain(""Invalid Path %s: Path traversal detected -- skipping"", g.inf);
return;
}

process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g",1450,-94.17256039221785,-0.06494659337394335
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:"," 
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , PATH_MAX ) ; if ( g . inf [ PATH_MAX - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= PATH_MAX ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= PATH_MAX ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , PATH_MAX - ( base - g . inf ) ) ; if ( g . inf [ PATH_MAX - 1 ] ) { strcpy ( g . inf + ( PATH_MAX - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if (",1450,-10.607319683509953,-0.0073153928851792775
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } // Check for path traversal vulnerability if ( ! g . force ) { // Get the real path to the file char realPath[MAX_PATH]; realpath(g.inf, realPath); // Check if the real path is the same as the provided path if (strncmp(g.inf, realPath, MAX_PATH) != 0) { // If not, bail bail(""Path Traversal Detected"", g.inf); } } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } // Check for path traversal vulnerability if ( ! g . force ) { // Get the real path to the file char realPath[MAX_PATH]; realpath(g.inf, realPath); // Check if the real path is the same as the provided path if (strncmp(g.inf, realPath, MAX_PATH) != 0) { // If not, bail bail(""Path Traversal Detected"", g.inf); } } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have",1450,-61.44511032540778,-0.042375938155453645
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","

local void process ( char * path ) { 
int method = - 1 ; 
size_t len ; 
struct stat st ; 
static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; 
if ( path == NULL ) { 
strcpy ( g . inf , ""<stdin>"" ) ; 
g . ind = 0 ; 
g . name = NULL ; 
g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; 
len = 0 ; 
} else { 
if ( path != g . inf ) { 
strncpy ( g . inf , path , sizeof ( g . inf ) ) ; 
if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; 
} 
len = strlen ( g . inf ) ; 
if ( lstat ( g . inf , & st ) ) { 
if ( errno == ENOENT && ( g . list || g . decode ) ) { 
char * * try = sufs ; 
do { 
if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; 
strcpy ( g . inf + len , * try ++ ) ; 
errno = 0 ; 
} while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; 
} 
# ifdef EOVERFLOW 
if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; 
# endif 
if ( errno ) { 
g . inf [ len ] = 0 ; 
complain ( ""%s does not exist -- skipping"" , g . inf ) ; 
return ; 
} 
len = strlen ( g . inf ) ; 
} 
if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { 
complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; 
return ; 
} 
if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { 
complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; 
return ; 
} 
if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { 
//Add path length checking
if (strlen(g.inf) >= PATH_MAX) {
    bail(""path too long: "", g.inf);
    return;
}
char * roll , * item , * cut , * base , * bigger ; 
size_t len , hold ; 
DIR * here ; 
struct dirent * next ; 
here = opendir ( g . inf ) ; 
if ( here == NULL ) return ; 
hold = 512 ; 
roll = MALLOC ( hold ) ; 
if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; 
* roll = 0 ; 
item = roll ; 
while ( ( next = readdir ( here ) ) != NULL ) { 
if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; 
len = strlen ( next -> d_name ) + 1 ; 
if ( item + len + 1 > roll + hold ) { 
do { 
hold <<= 1 ; 
} while ( item + len + 1 > roll + hold ) ; 
bigger = REALLOC ( roll , hold ) ; 
if ( bigger == NULL ) { 
FREE ( roll ) ; 
bail ( ""not enough memory"" , """" ) ; 
} 
item = bigger + ( item - roll ) ; 
roll = bigger ; 
} 
strcpy ( item , next -> d_name ) ; 
item += len ; 
* item = 0 ; 
} 
closedir ( here ) ; 
cut = base = g . inf + strlen ( g . inf ) ; 
if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { 
if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; 
* base ++ = '/' ; 
} 
item = roll ; 
while ( * item ) { 
strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; 
if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { 
strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; 
bail ( ""path too long: "" , g . inf ) ; 
} 
process ( g . inf ) ; 
item += strlen ( item ) + 1 ; 
} 
* cut = 0 ; 
FREE ( roll ) ; 
return ; 
} 
if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { 
complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; 
return ; 
} 
if ( g . decode == 1 && ! g . pipeout && ! g . list ) { 
int suf = compressed_suffix ( g . inf ) ; 
",1450,-36.59627704004463,-0.02523881175175492
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; int i; for ( i = 0; i<11; i++) { if ( len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } char * canonicalized_path = realpath(g.inf, NULL); process ( canonicalized_path ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE",1450,-44.61548753580804,-0.030769301748833133
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s does not exist -- skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s is a special file or device -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s is a directory -- skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not enough memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path too long: "" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s ends with %s -- skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s does not have compressed suffix -- skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read error on "" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s is not compressed -- skipping"" : ""%s has unknown compression method -- skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying to write compressed data to a terminal"" , "" (use -f to force)"" ) ; } else { char * to , * repl ; to = g . inf ; if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { to = g . hname ; len = strlen ( g . hname ) ; } repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not enough memory"" , """" ) ; memcpy ( g . outf , to , len ) ; strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s exists -- overwrite (y/n)? "" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != ' ' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s exists -- skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write error on "" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s to %s "" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write error on "" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
Fixed code:","
local void process ( char * path ) {
  int method = - 1 ;
  size_t len ;
  struct stat st ;
  static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ;
  if ( path == NULL ) {
    strcpy ( g . inf , ""<stdin>"" ) ;
    g . ind = 0 ;
    g . name = NULL ;
    g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ;
    len = 0 ;
  }
  else {
    if ( path != g . inf ) {
      if(strstr(path, "".."") == NULL)
      {
        strncpy ( g . inf , path , sizeof ( g . inf ) ) ;
        if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name too long: "" , path ) ;
      }
      else
      {
        bail(""name contains restricted directory traversal"", path);
      }
    }
    len = strlen ( g . inf ) ;
    if ( lstat ( g . inf , & st ) ) {
      if ( errno == ENOENT && ( g . list || g . decode ) ) {
        char * * try = sufs ;
        do {
          if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ;
          strcpy ( g . inf + len , * try ++ ) ;
          errno = 0 ;
        } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ;
      }
      # ifdef EOVERFLOW
      if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , "" too large -- not compiled with large file support"" ) ;
      # endif
      if ( errno ) {
        g . inf [ len ] = 0 ;
        complain ( ""%s does not exist -- skipping"" , g . inf ) ;
        return ;
      }
      len = strlen ( g . inf ) ;
    }
    if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) {
      complain ( ""%s is a special file or device -- skipping"" , g . inf ) ;
      return ;
    }
    if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) {
      complain ( ""%s is a symbolic link -- skipping"" , g . inf ) ;
      return ;
    }
    if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) {
      complain ( ""%s is a directory -- skipping"" , g . inf ) ;
      return ;
    }
    if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) {
      char * roll , * item , * cut , * base , * bigger ;
      size_t len , hold ;
      DIR * here ;
      struct dirent * next ;
      here = opendir ( g . inf ) ;
      if ( here == NULL ) return ;
      hold = 512 ;
      roll = MALLOC ( hold ) ;
      if ( roll == NULL ) bail ( ""not enough memory"" , """" ) ;
      * roll = 0 ;
      item = roll ;
      while ( ( next = readdir ( here ) ) != NULL ) {
        if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ;
        len = strlen ( next -> d_name ) + 1 ;
        if ( item + len + 1 > roll + hold ) {
          do {
            hold <<= 1 ;
          } while ( item + len + 1 > roll + hold ) ;
          bigger = REALLOC ( roll , hold ) ;
          if ( bigger == NULL ) {
            FREE ( roll ) ;
            bail ( ""not enough memory"" , """" ) ;
          }
          item = bigger + ( item - roll ) ;
          roll = bigger ;
        }
        strcpy ( item , next -> d_name ) ;
        item += len ;
        * item = 0 ;
      }
      closedir ( here ) ;
      cut = base = g . inf + strlen ( g . inf ) ;
      if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) {
        if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path too long"" , g . inf ) ;
        * base ++ = '/' ;
      }
      item = roll ;
      while ( * item ) {
        strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ;
        if ( g . inf [ sizeof ( g . inf ) - 1 ] ) {
          strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ;
          bail ( ""path too long: "" , g . inf ) ;
        }
        process ( g . inf ) ;
        item += strlen ( item ) + 1 ;
      }
      * cut = 0 ;
      FREE ( roll ) ;
      return ;
    }
    if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) {
      complain ( ""%s ends with %s -- skipping"" , g . inf , g .",1450,-35.83716396519565,-0.02471528549323838
