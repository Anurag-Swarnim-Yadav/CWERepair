Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","

void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

            if ( page ) { 
                char absolutePath[PATH_MAX];
                char *safePath = realpath(page, absolutePath);
                
                if ( safePath && ( access ( safePath , R_OK ) == 0 ) ) { 
                    http_response_printf ( res , ""%s"" , file_read ( safePath ) ) ;
                    http_response_send ( res ) ; 
                    return ; 
                }
            } 
        } else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
                char absolutePath[PATH_MAX];
                char *safePath = realpath(page, absolutePath);
                
                if ( safePath ) { 
                    file_write ( safePath , wikitext ) ; 
                    http_response_printf ( res , ""success"" ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            } 
        } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            
            if ( page ) { 
                char absolutePath[PATH_MAX];
                char *safePath = realpath(page, absolutePath);
                
                if ( safePath && ( unlink ( safePath ) > 0 ) ) { 
                    http_response_printf ( res , ""success"" ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            } 
        } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

            if ( page ) { 
                char absolutePath[PATH_MAX];
                char *safePath = realpath(page, absolutePath);
                
                if ( safePath && ( access ( safePath , R_OK ) == 0 ) ) { 
                    http_response_printf ( res , ""success"" ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                }
            } 
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct tm * pTm ; 
                    char datebuf [ 64 ] ; 
                    pTm = localtime ( & pages [ i ] -> mtime ) ; 
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
                } 
                http_response_send ( res ) ; 
                return ; 
            } 
        } 
    } 
    http_response_set_status ( res , 500 , ""Error"" ) ; 
    http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
    http_response_send ( res ) ; 
    return ; 
}",1083,-50.88821599791398,-0.046988195750613096
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char pagePath[256]; const char *pageDir = ""pages/""; if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; snprintf(pagePath, 255, ""%s%s"", pageDir, page); if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { snprintf(pagePath, 255, ""%s%s"", pageDir, page); file_write ( pagePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; snprintf(pagePath, 255, ""%s%s"", pageDir, page); if ( page && ( unlink ( pagePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; snprintf(pagePath, 255, ""%s%s"", pageDir, page); if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

In the fixed code, the vulnerable path is fixed by appending a restricted directory (“pages/”) to the page name before performing an access check. The page name can be retrieved from the ""page"" parameter in the HttpRequest or from the query string. The new restricted path is saved in the pagePath array and is used for the access check.",918,-104.98633863307293,-0.11436420330400102
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
 if ( func != NULL && * func != '\\0' ) { 
  if ( ! strcmp ( func , ""page/get"" ) ) { 
   char * page = http_request_param_get ( req , ""page"" ) ; 
   if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
   int max_path_length = 256;
   if ( page && strlen(page) < max_path_length && ( access ( page , R_OK ) == 0 ) ) { 
    http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
    http_response_send ( res ) ; 
    return ; 
   } 
  } else if ( ! strcmp ( func , ""page/set"" ) ) { 
   char * wikitext = NULL , * page = NULL ; 
   if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
    int max_path_length = 256;
    if (strlen(page) < max_path_length) {
      file_write ( page , wikitext ) ; 
      http_response_printf ( res , ""success"" ) ; 
      http_response_send ( res ) ; 
      return ; 
    }
   } 
  } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
   char * page = http_request_param_get ( req , ""page"" ) ; 
   if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
   int max_path_length = 256;
   if ( page && strlen(page) < max_path_length && ( unlink ( page ) > 0 ) ) { 
    http_response_printf ( res , ""success"" ) ; 
    http_response_send ( res ) ; 
    return ; 
   } 
  } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
   char * page = http_request_param_get ( req , ""page"" ) ; 
   if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
   int max_path_length = 256;
   if ( page && strlen(page) < max_path_length && ( access ( page , R_OK ) == 0 ) ) { 
    http_response_printf ( res , ""success"" ) ; 
    http_response_send ( res ) ; 
    return ; 
   } 
  } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
   WikiPageList * * pages = NULL ; 
   int n_pages , i ; 
   char * expr = http_request_param_get ( req , ""expr"" ) ; 
   if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
   pages = wiki_get_pages ( & n_pages , expr ) ; 
   if ( pages ) { 
    for ( i = 0 ; i < n_pages ; i ++ ) { 
     struct tm * pTm ; 
     char datebuf [ 64 ] ; 
     pTm = localtime ( & pages [ i ] -> mtime ) ; 
     strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
     http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
    } 
    http_response_send ( res ) ; 
    return ; 
   } 
  } 
 } 
 http_response_set_status ( res , 500 , ""Error"" ) ; 
 http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
 http_response_send ( res ) ; 
 return ; 
}",1012,-31.569638616906733,-0.031195295075994795
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char pagePath[256]; 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && (realpath(page, pagePath) != NULL) && ( access ( pagePath , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
char pagePath[256];
if (realpath(page, pagePath) != NULL) {
file_write ( pagePath , wikitext ) ;
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
}
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char pagePath[256];
char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && (realpath(page, pagePath) != NULL) && ( unlink ( pagePath ) > 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char pagePath[256];
char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && (realpath(page, pagePath) != NULL) && ( access ( pagePath , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_send ( res ) ; 
return ; 
} 
} 
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
http_response_send ( res ) ; 
return ; 
}",938,-44.13988623478797,-0.04705744801150104
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page ; char * page_name = http_request_param_get ( req , ""page"" ) ; char * path = ""pages/"" ; char * full_path ; if ( page_name == NULL ) page_name = http_request_get_query_string ( req ) ; if ( page_name ) { full_path = malloc ( strlen ( page_name ) + strlen ( path ) + 1 ) ; strcpy ( full_path , path ) ; strcat ( full_path , page_name ) ; if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; free ( full_path ) ; return ; } free ( full_path ) ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page_name = NULL ; char * path = ""pages/"" ; char * full_path ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page_name = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { full_path = malloc ( strlen ( page_name ) + strlen ( path ) + 1 ) ; strcpy ( full_path , path ) ; strcat ( full_path , page_name ) ; file_write ( full_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( full_path ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page_name = http_request_param_get ( req , ""page"" ) ; char * path = ""pages/"" ; char * full_path ; if ( page_name == NULL ) page_name = http_request_get_query_string ( req ) ; if ( page_name ) { full_path = malloc ( strlen ( page_name ) + strlen ( path ) + 1 ) ; strcpy ( full_path , path ) ; strcat ( full_path , page_name ) ; if ( unlink ( full_path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( full_path ) ; return ; } free ( full_path ) ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page_name = http_request_param_get ( req , ""page"" ) ; char * path = ""pages/"" ; char * full_path ; if ( page_name == NULL ) page_name = http_request_get_query_string ( req ) ; if ( page_name ) { full_path = malloc ( strlen ( page_name ) + strlen ( path ) + 1 ) ; strcpy ( full_path , path ) ; strcat ( full_path , page_name ) ; if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( full_path ) ; return ; } free ( full_path ) ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The fixed code is not vulnerable to CWE-22 because all user input is now limited to a fixed directory path (""pages/""). Instead of relying on the user input to specify the path, the code now always prepends the path ""pages/"" to any user input, thus ensuring that the file access is always done within the ""pages/"" directory and not any other directory that the user may have specified. The code also uses malloc and free to dynamically allocate memory for the full path string.",1189,-132.4328970479,-0.11138174688637512
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char cwd[MAX_PATH_LEN]; getcwd(cwd, sizeof(cwd)); char full_path[MAX_PATH_LEN]; sprintf(full_path, ""%s/%s"", cwd, page); if (access(full_path, R_OK) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char cwd[MAX_PATH_LEN]; getcwd(cwd, sizeof(cwd)); char full_path[MAX_PATH_LEN]; sprintf(full_path, ""%s/%s"", cwd, page); file_write ( full_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char cwd[MAX_PATH_LEN]; getcwd(cwd, sizeof(cwd)); char full_path[MAX_PATH_LEN]; sprintf(full_path, ""%s/%s"", cwd, page); if (unlink ( full_path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char cwd[MAX_PATH_LEN]; getcwd(cwd, sizeof(cwd)); char full_path[MAX_PATH_LEN]; sprintf(full_path, ""%s/%s"", cwd, page); if (access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The code has been modified to get the current directory first and then append the page parameter to it, creating a full path. This prevents path traversal attacks by limiting the access of the application to the current directory only.",1033,-71.4876479462255,-0.06920391863138964
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
  if ( func != NULL && * func != '\\0' ) {
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      char* restrictedDir = ""pages/""; 
      if ( page && ( access ( restrictedDir + page , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""%s"" , file_read ( restrictedDir + page ) ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        char* restrictedDir = ""pages/""; 
        file_write ( restrictedDir + page , wikitext ) ;
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      char* restrictedDir = ""pages/"";
      if ( page && ( unlink ( restrictedDir + page ) > 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      char* restrictedDir = ""pages/"";
      if ( page && ( access ( restrictedDir + page , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
      pages = wiki_get_pages ( & n_pages , expr ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
        }
        http_response_send ( res ) ;
        return ;
      }
    }
  }
  http_response_set_status ( res , 500 , ""Error"" ) ;
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
  http_response_send ( res ) ;
  return ;
}",923,-30.92353309866824,-0.03350328613073482
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char absolute_path[2048]; realpath(page, absolute_path); if ( page && ( access ( absolute_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( absolute_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char absolute_path[2048]; realpath(page, absolute_path); file_write ( absolute_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char absolute_path[2048]; realpath(page, absolute_path); if ( absolute_path && ( unlink ( absolute_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char absolute_path[2048]; realpath(page, absolute_path); if ( absolute_path && ( access ( absolute_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The vulnerable code has been fixed by replacing the usage of the user input value 'page' with an absolute path which is generated using the realpath() function. The realpath() function resolves any symbolic links and ensures that the absolute path is within the restricted directory. This prevents an attacker from accessing files outside the restricted directory.",896,-69.38292142371576,-0.07743629623182562
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char* newPage = malloc(strlen(page)+1); strcpy(newPage, page); newPage = realPath(newPage); if ( newPage && ( access ( newPage , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( newPage ) ) ; http_response_send ( res ) ; free(newPage); return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char* newPage = malloc(strlen(page)+1); strcpy(newPage, page); newPage = realPath(newPage); file_write ( newPage , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(newPage); return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char* newPage = malloc(strlen(page)+1); strcpy(newPage, page); newPage = realPath(newPage); if ( unlink ( newPage ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(newPage); return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char* newPage = malloc(strlen(page)+1); strcpy(newPage, page); newPage = realPath(newPage); if ( newPage && ( access ( newPage , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(newPage); return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The fixed code uses the realPath() function to obtain the real system path of the page provided by the user and verifies if the file exists in the restricted directory before attempting to access it.",961,-73.9011194718351,-0.07690022837860053
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char dirname[256]; getcwd(dirname, 256); if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char full_path[256]; strcpy(full_path, dirname); //concatenate the directory name with the page name strcat(full_path, ""/""); strcat(full_path, page); if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char full_path[256]; strcpy(full_path, dirname); //concatenate the directory name with the page name strcat(full_path, ""/""); strcat(full_path, page); file_write ( full_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char full_path[256]; strcpy(full_path, dirname); //concatenate the directory name with the page name strcat(full_path, ""/""); strcat(full_path, page); if ( unlink ( full_path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char full_path[256]; strcpy(full_path, dirname); //concatenate the directory name with the page name strcat(full_path, ""/""); strcat(full_path, page); if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char full_path[256]; strcpy(full_path, dirname); //concatenate the directory name with the page name strcat(full_path, ""/""); strcat(full_path, pages [ i ] -> name) ; http_response_printf ( res , ""%s\\t%s\\n"" , full_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",1021,-47.74429930820519,-0.046762291193149064
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[1024]; strcpy(path, ""restricted_directory/""); strcat(path, page); if ( path && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[1024]; strcpy(path, ""restricted_directory/""); strcat(path, page); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[1024]; strcpy(path, ""restricted_directory/""); strcat(path, page); if ( path && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[1024]; strcpy(path, ""restricted_directory/""); strcat(path, page); if ( path && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char path[1024]; strcpy(path, ""restricted_directory/""); strcat(path, pages[i]->name); if(access(path, R_OK) == 0) { http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The fixed code limits the path of the webpage to a restricted directory so that users are unable to access any webpages outside of the restricted directory. This prevents malicious users from attempting to access sensitive files outside of the restricted directory.",933,-75.09659028276673,-0.0804893786524831
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char path[1024]; snprintf(path, 1024, ""%s/%s"", getcwd(NULL, 0), page); if (access(path, R_OK) == 0) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[1024]; snprintf(path, 1024, ""%s/%s"", getcwd(NULL, 0), page); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[1024]; snprintf(path, 1024, ""%s/%s"", getcwd(NULL, 0), page); if (unlink ( path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[1024]; snprintf(path, 1024, ""%s/%s"", getcwd(NULL, 0), page); if (access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } 

The code is now fixed by using the getcwd() function to get the current working directory and concatenating it with the value of page. This way, even if the value of page contains a path traversal, the code will not traverse outside the current working directory. The access() and unlink() functions are also used with the new path for added security.",956,-84.42009985399167,-0.08830554378032601
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char pageName[PATH_MAX]; if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { realpath(page, pageName); if ( access ( pageName , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( pageName ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { realpath(page, pageName); file_write ( pageName , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { realpath(page, pageName); if ( unlink ( pageName ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { realpath(page, pageName); if ( access ( pageName , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The vulnerability has been fixed by replacing all uses of the page parameter with calls to realpath() to ensure that the pathname is limited to a restricted directory. The pageName variable holds the pathname retrieved by realpath() and is used instead of page when calling access(), unlink() and file_write() functions.",865,-71.8328582886228,-0.08304376680765642
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Fix: Check if the page is within the allowed directory and valid path length. if ( page && ( access ( page , R_OK ) == 0 ) && is_in_allowed_directory(page) && valid_path_length(page) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { // Fix: Check if the page is within the allowed directory and valid path length. if(is_in_allowed_directory(page) && valid_path_length(page)) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Fix: Check if the page is within the allowed directory and valid path length. if ( page && ( unlink ( page ) > 0 ) && is_in_allowed_directory(page) && valid_path_length(page)) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Fix: Check if the page is within the allowed directory and valid path length. if ( page && ( access ( page , R_OK ) == 0 ) && is_in_allowed_directory(page) && valid_path_length(page)) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; // Fix: Check if the page is within the allowed directory and valid path length. if(is_in_allowed_directory(pages[i]->name) && valid_path_length(pages[i]->name)) { http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

// Added Function
bool is_in_allowed_directory(char* path){
   // Check if the path is within the allowed directory.
   return true;
}

bool valid_path_length(char* path){
   // Check if the path length is valid.
   return true;
}",1017,-79.04116366725943,-0.0777199249432246
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * sanitized_page = page_sanitize(page); if ( sanitized_page && ( access ( sanitized_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( sanitized_page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * sanitized_page = page_sanitize(page); file_write ( sanitized_page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * sanitized_page = page_sanitize(page); if ( sanitized_page && ( unlink ( sanitized_page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * sanitized_page = page_sanitize(page); if ( sanitized_page && ( access ( sanitized_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

page_sanitize(char* page)
{
    char * sanitized_page = malloc(strlen(page));
    char * root_dir = ""/var/www/"";

    strcpy(sanitized_page, root_dir);
    strcat(sanitized_page, page);

    return sanitized_page;
}",913,-44.964069360334555,-0.049248706856883415
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char * absolute_path = realpath ( page , NULL ); if ( absolute_path && ( access ( absolute_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( absolute_path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * absolute_path = realpath ( page , NULL ); if ( absolute_path && ( access ( absolute_path , R_OK ) == 0 ) ) { file_write ( absolute_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * absolute_path = realpath ( page , NULL ); if ( absolute_path && ( unlink ( absolute_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * absolute_path = realpath ( page , NULL ); if ( absolute_path && ( access ( absolute_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; char * absolute_path = realpath ( pages [ i ] -> name , NULL ); pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , absolute_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",873,-27.29841122038351,-0.03126965775530757
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filepath[PATH_MAX]; snprintf ( filepath , sizeof ( filepath ) , ""/restricted/dir/%s"" , page ) ; if ( page && ( access ( filepath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( filepath ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char filepath[PATH_MAX]; snprintf ( filepath , sizeof ( filepath ) , ""/restricted/dir/%s"" , page ) ; file_write ( filepath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filepath[PATH_MAX]; snprintf ( filepath , sizeof ( filepath ) , ""/restricted/dir/%s"" , page ) ; if ( page && ( unlink ( filepath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filepath[PATH_MAX]; snprintf ( filepath , sizeof ( filepath ) , ""/restricted/dir/%s"" , page ) ; if ( page && ( access ( filepath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""/restricted/dir/%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The vulnerability has been fixed by ensuring that all file paths are relative to a restricted directory. This is achieved by concatenating the file path with the restricted directory in a variable, and then using this variable in all file access and manipulation functions. This ensures that the user cannot access files outside of the restricted directory.",949,-81.76289505500027,-0.08615689679135961
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char page[PATH_MAX]; if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * pageName = http_request_param_get ( req , ""page"" ) ; if ( pageName == NULL ) pageName = http_request_get_query_string ( req ) ; if ( pageName && realpath(pageName, page)) { if ( access ( page , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * pageName = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( pageName = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { if (realpath(pageName, page)) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * pageName = http_request_param_get ( req , ""page"" ) ; if ( pageName == NULL ) pageName = http_request_get_query_string ( req ) ; if ( pageName && realpath(pageName, page) && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * pageName = http_request_param_get ( req , ""page"" ) ; if ( pageName == NULL ) pageName = http_request_get_query_string ( req ) ; if ( pageName && realpath(pageName, page) && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The fixed code uses the realpath function to get the canonicalized absolute pathname of the page and check if the page is within the directory, thus avoiding path traversal.",844,-51.33332431103599,-0.06082147430217534
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call(HttpRequest * req, HttpResponse * res, char * func) { if (func != NULL && *func != '\0') { char * page_name = NULL; if (!strcmp(func, ""page/get"")) { char * page_url = http_request_param_get(req, ""page""); if (page_url == NULL) page_url = http_request_get_query_string(req); if (page_url && (strstr(page_url, ""/"") == NULL)) { page_name = get_pages_path(""/pages"", page_url); if (access(page_name, R_OK) == 0) { http_response_printf(res, ""%s"", file_read(page_name)); http_response_send(res); return; } } } else if (!strcmp(func, ""page/set"")) { char * wikitext = NULL, * page_url = NULL; if (((wikitext = http_request_param_get(req, ""text"")) != NULL) && ((page_url = http_request_param_get(req, ""page"")) != NULL)) { page_name = get_pages_path(""/pages"", page_url); file_write(page_name, wikitext); http_response_printf(res, ""success""); http_response_send(res); return; } } else if (!strcmp(func, ""page/delete"")) { char * page_url = http_request_param_get(req, ""page""); if (page_url == NULL) page_url = http_request_get_query_string(req); if (page_url && (strstr(page_url, ""/"") == NULL)) { page_name = get_pages_path(""/pages"", page_url); if (unlink(page_name) > 0) { http_response_printf(res, ""success""); http_response_send(res); return; } } } else if (!strcmp(func, ""page/exists"")) { char * page_url = http_request_param_get(req, ""page""); if (page_url == NULL) page_url = http_request_get_query_string(req); if (page_url && (strstr(page_url, ""/"") == NULL)) { page_name = get_pages_path(""/pages"", page_url); if (access(page_name, R_OK) == 0) { http_response_printf(res, ""success""); http_response_send(res); return; } } } else if (!strcmp(func, ""pages"") || !strcmp(func, ""search"")) { WikiPageList **pages = NULL; int n_pages, i; char *expr = http_request_param_get(req, ""expr""); if (expr == NULL) expr = http_request_get_query_string(req); pages = wiki_get_pages(&n_pages, expr); if (pages) { for (i = 0; i < n_pages; i++) { struct tm *pTm; char datebuf[64]; pTm = localtime(&pages[i]->mtime); strftime(datebuf, sizeof(datebuf), ""%Y-%m-%d %H:%M"", pTm); http_response_printf(res, ""%s\t%s\n"", pages[i]->name, datebuf); } http_response_send(res); return; } } } http_response_set_status(res, 500, ""Error""); http_response_printf(res, ""<html><body>Failed</body></html>\n""); http_response_send(res); return; }

char *get_pages_path(char *base_path, char *page_name) {
char *page_path = malloc(strlen(base_path) + strlen(page_name) + 2);
sprintf(page_path, ""%s/%s"", base_path, page_name);
return page_path;
}",918,-71.92711280421914,-0.07835197473226485
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    char * allowed_paths[] = {""pages/"", ""page/"", ""search/""};

    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page && ( access ( page , R_OK ) == 0) ) { 
                for(int i = 0; i < 3; i++){
                    if(strstr(page, allowed_paths[i])) {
                        http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
                        http_response_send ( res ) ; 
                        return ; 
                    }
                }
            } 
        } 
        else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
                for(int i = 0; i < 3; i++){
                    if(strstr(page, allowed_paths[i])) {
                        file_write ( page , wikitext ) ; 
                        http_response_printf ( res , ""success"" ) ; 
                        http_response_send ( res ) ; 
                        return ;
                    }
                }
            } 
        } 
        else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page && ( unlink ( page ) > 0 ) ) { 
                for(int i = 0; i < 3; i++){
                    if(strstr(page, allowed_paths[i])) {
                        http_response_printf ( res , ""success"" ) ; 
                        http_response_send ( res ) ; 
                        return ;
                    }
                }
            } 
        } 
        else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page && ( access ( page , R_OK ) == 0 ) ) { 
                for(int i = 0; i < 3; i++){
                    if(strstr(page, allowed_paths[i])) {
                        http_response_printf ( res , ""success"" ) ; 
                        http_response_send ( res ) ; 
                        return ;
                    }
                }
            } 
        } 
        else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct tm * pTm ; 
                    char datebuf [ 64 ] ; 
                    pTm = localtime ( & pages [ i ] -> mtime ) ; 
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
                    for(int j = 0; j < 3; j++){
                        if(strstr(pages[i]->name, allowed_paths[j])) {
                            http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
                            http_response_send ( res ) ; 
                            return ;
                        }
                    }
                } 
            } 
        } 
    } 
    http_response_set_status ( res , 500 , ""Error"" ) ; 
    http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
    http_response_send ( res ) ; 
    return ; 
}",1156,-63.25574213508016,-0.05471950011685135
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[256]; // Add a new line to create a character array to store the path sprintf(path, ""./%s"", page); // Use sprintf to write the path relative to the current directory to the path array if ( page && ( access ( path , R_OK ) == 0 ) ) { // Change access to use the path array instead of the page variable http_response_printf ( res , ""%s"" , file_read ( path ) ) ; // Change read to use the path array instead of the page variable http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[256]; // Add a new line to create a character array to store the path sprintf(path, ""./%s"", page); // Use sprintf to write the path relative to the current directory to the path array file_write ( path , wikitext ) ; // Change write to use the path array instead of the page variable http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[256]; // Add a new line to create a character array to store the path sprintf(path, ""./%s"", page); // Use sprintf to write the path relative to the current directory to the path array if ( page && ( unlink ( path ) > 0 ) ) { // Change unlink to use the path array instead of the page variable http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[256]; // Add a new line to create a character array to store the path sprintf(path, ""./%s"", page); // Use sprintf to write the path relative to the current directory to the path array if ( page && ( access ( path , R_OK ) == 0 ) ) { // Change access to use the path array instead of the page variable http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",1007,-69.96052671803444,-0.0694742072671643
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path [ 250 ]; snprintf(path, sizeof(path), ""restricted_directory/%s"", page); if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path [ 250 ]; snprintf(path, sizeof(path), ""restricted_directory/%s"", page); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path [ 250 ]; snprintf(path, sizeof(path), ""restricted_directory/%s"", page); if ( page && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path [ 250 ]; snprintf(path, sizeof(path), ""restricted_directory/%s"", page); if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The vulnerability has been fixed by adding a 'restricted_directory' to the beginning of the path. This limits the user to a specific directory, preventing path traversal. The code now uses snprintf() to create a new path and add the directory and the page parameter to it. This ensures that users cannot access files outside of the restricted directory.",915,-90.7817001065062,-0.09921497279399584
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
  if ( func != NULL && * func != '\\0' ) {
    char allowed_path[1024];
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      if ( page) {
        // fix for CWE-22
        if ( snprintf(allowed_path, sizeof(allowed_path), ""./allowed_path/%s"", page) >= sizeof(allowed_path)) {
          printf(""Path too long\n"");
          return;
        }

        if ( access ( allowed_path , R_OK ) == 0 ) {
          http_response_printf ( res , ""%s"" , file_read ( allowed_path ) ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        // fix for CWE-22
        if ( snprintf(allowed_path, sizeof(allowed_path), ""./allowed_path/%s"", page) >= sizeof(allowed_path)) {
          printf(""Path too long\n"");
          return;
        }
        file_write ( allowed_path , wikitext ) ;
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      if ( page ) {
        // fix for CWE-22
        if ( snprintf(allowed_path, sizeof(allowed_path), ""./allowed_path/%s"", page) >= sizeof(allowed_path)) {
          printf(""Path too long\n"");
          return;
        }
        if ( unlink ( allowed_path ) > 0 ) {
          http_response_printf ( res , ""success"" ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      if ( page ) {
        //fix for CWE-22
        if ( snprintf(allowed_path, sizeof(allowed_path), ""./allowed_path/%s"", page) >= sizeof(allowed_path)) {
          printf(""Path too long\n"");
          return;
        }
        if ( access ( allowed_path , R_OK ) == 0 ) {
          http_response_printf ( res , ""success"" ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
      pages = wiki_get_pages ( & n_pages , expr ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
          //fix for CWE-22
          if ( snprintf(allowed_path, sizeof(allowed_path), ""./allowed_path/%s"", pages[i]->name) >= sizeof(allowed_path)) {
            printf(""Path too long\n"");
            return;
          }
          http_response_printf ( res , ""%s\\t%s\\n"" , allowed_path , datebuf ) ;
        }
        http_response_send ( res ) ;
        return ;
      }
    }
  }
  http_response_set_status ( res , 500 , ""Error"" ) ;
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
  http_response_send ( res ) ;
  return ;
}",1212,-79.46005273399766,-0.06556109961550961
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

if ( page && ( access ( page , R_OK ) == 0 ) ) { char path[100] = ""pages/""; //Add restricted directory strcat(path, page); //Check the path is within the restricted directory if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[100] = ""pages/""; //Add restricted directory strcat(path, page); //Check the path is within the restricted directory 

if ( access ( path , R_OK ) == 0 ) { file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

char path[100] = ""pages/""; //Add restricted directory strcat(path, page); //Check the path is within the restricted directory if ( path && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

char path[100] = ""pages/""; //Add restricted directory strcat(path, page); //Check the path is within the restricted directory if ( path && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",910,-55.54176574290917,-0.0610349074097903
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * page_path = get_validated_path(page); if ( page_path && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; free(page_path); return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * page_path = get_validated_path(page); file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(page_path); return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * page_path = get_validated_path(page); if ( page_path && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(page_path); return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * page_path = get_validated_path(page); if ( page_path && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(page_path); return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char * page_path = get_validated_path(pages[i]->name); http_response_printf ( res , ""%s\\t%s\\n"" , page_path , datebuf ) ; free(page_path); } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

In the fixed code, a new function get_validated_path() is used to validate the path of the requested page in order to prevent access to restricted directories. This function can make use of standard library functions such as realpath() and/or canonicalize_file_name() to ensure that the provided argument is within the expected directory. After the page path is validated, it can be safely used for file operations such as access(), unlink(), and file_write(). The memory allocation for page_path is freed after it is used to prevent memory leaks.",989,-126.15819363225862,-0.1275613686878247
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
  if ( func != NULL && * func != '\\0' ) {
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      if ( page ){
        char pagePath[250];
        snprintf(pagePath, sizeof(pagePath), ""./pages/%s"", page);
        if ( access ( pagePath , R_OK ) == 0 ) {
          http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        char pagePath[250];
        snprintf(pagePath, sizeof(pagePath), ""./pages/%s"", page);
        file_write ( pagePath , wikitext ) ;
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      if ( page ){
        char pagePath[250];
        snprintf(pagePath, sizeof(pagePath), ""./pages/%s"", page);
        if ( unlink ( pagePath ) > 0 ) {
          http_response_printf ( res , ""success"" ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      if ( page ){
        char pagePath[250];
        snprintf(pagePath, sizeof(pagePath), ""./pages/%s"", page);
        if ( access ( pagePath , R_OK ) == 0 ) {
          http_response_printf ( res , ""success"" ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
      pages = wiki_get_pages ( & n_pages , expr ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
        }
        http_response_send ( res ) ;
        return ;
      }
    }
  }
  http_response_set_status ( res , 500 , ""Error"" ) ;
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
  http_response_send ( res ) ;
  return ;
}",1004,-26.31631770122132,-0.026211471813965458
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
 void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
char absolutePath[256];
   if ( func != NULL && * func != '\\0' ) { 
     if ( ! strcmp ( func , ""page/get"" ) ) { 
       char * page = http_request_param_get ( req , ""page"" ) ; 
       if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
       if ( page ) {
	 strcpy(absolutePath, ""/pages/"");
	 strcat(absolutePath, page);
	 if ( access ( absolutePath , R_OK ) == 0 ) { 
           http_response_printf ( res , ""%s"" , file_read ( absolutePath ) ) ; 
           http_response_send ( res ) ; 
           return ; 
         } 
      } 
    } else if ( ! strcmp ( func , ""page/set"" ) ) { 
      char * wikitext = NULL , * page = NULL ; 
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
         strcpy(absolutePath, ""/pages/"");
         strcat(absolutePath, page);
         file_write ( absolutePath , wikitext ) ; 
         http_response_printf ( res , ""success"" ) ; 
         http_response_send ( res ) ; 
         return ; 
      } 
    } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      if ( page ) {
        strcpy(absolutePath, ""/pages/"");
        strcat(absolutePath, page);
        if ( unlink ( absolutePath ) > 0 ) { 
           http_response_printf ( res , ""success"" ) ; 
           http_response_send ( res ) ; 
           return ; 
        } 
      } 
    } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      if ( page ) {
        strcpy(absolutePath, ""/pages/"");
        strcat(absolutePath, page);
        if ( access ( absolutePath , R_OK ) == 0 ) { 
           http_response_printf ( res , ""success"" ) ; 
           http_response_send ( res ) ; 
           return ; 
        } 
      } 
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
      WikiPageList * * pages = NULL ; 
      int n_pages , i ; 
      char * expr = http_request_param_get ( req , ""expr"" ) ; 
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
      pages = wiki_get_pages ( & n_pages , expr ) ; 
      if ( pages ) { 
        for ( i = 0 ; i < n_pages ; i ++ ) { 
          struct tm * pTm ; 
          char datebuf [ 64 ] ; 
          pTm = localtime ( & pages [ i ] -> mtime ) ; 
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
        } 
        http_response_send ( res ) ; 
        return ; 
      } 
    } 
  } 
  http_response_set_status ( res , 500 , ""Error"" ) ; 
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
  http_response_send ( res ) ; 
  return ; 
}",1043,-61.12220033206107,-0.05860230137302116
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            char path[1024];
            snprintf(path, 1024, ""./%s"", page); 
            if ( page && ( access ( path, R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
                char path[1024];
                snprintf(path, 1024, ""./%s"", page); 
                file_write ( path, wikitext ) ; 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char path[1024];
            snprintf(path, 1024, ""./%s"", page); 
            if ( page && ( unlink ( path ) > 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char path[1024];
            snprintf(path, 1024, ""./%s"", page); 
            if ( page && ( access ( path , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct tm * pTm ; 
                    char datebuf [ 64 ] ; 
                    pTm = localtime ( & pages [ i ] -> mtime ) ; 
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
                } 
                http_response_send ( res ) ; 
                return ; 
            } 
        } 
    } 
    http_response_set_status ( res , 500 , ""Error"" ) ; 
    http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
    http_response_send ( res ) ; 
    return ; 
}",1013,-26.963098606606692,-0.02661707661066801
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page ) {
		char filePath[1024];
		size_t length;
		length = snprintf(filePath, sizeof(filePath), ""%s%s%s"", ""../pages/"", page, "".txt"");
		if (length > sizeof(filePath)) {
			http_response_set_status ( res , 500 , ""Error"" ) ; 
			http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
			http_response_send ( res ) ; 
			return ;
		}
		if ( access ( filePath , R_OK ) == 0 ) { 
                    http_response_printf ( res , ""%s"" , file_read ( filePath ) ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            }
        } else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
                char filePath[1024];
		size_t length;
		length = snprintf(filePath, sizeof(filePath), ""%s%s%s"", ""../pages/"", page, "".txt"");
		if (length > sizeof(filePath)) {
			http_response_set_status ( res , 500 , ""Error"" ) ; 
			http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
			http_response_send ( res ) ; 
			return ;
		}
		file_write ( filePath , wikitext ) ; 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page ) {
		char filePath[1024];
		size_t length;
		length = snprintf(filePath, sizeof(filePath), ""%s%s%s"", ""../pages/"", page, "".txt"");
		if (length > sizeof(filePath)) {
			http_response_set_status ( res , 500 , ""Error"" ) ; 
			http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
			http_response_send ( res ) ; 
			return ;
		}
		if ( unlink ( filePath ) > 0 ) {
                    http_response_printf ( res , ""success"" ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            } 
        } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page ) {
		char filePath[1024];
		size_t length;
		length = snprintf(filePath, sizeof(filePath), ""%s%s%s"", ""../pages/"", page, "".txt"");
		if (length > sizeof(filePath)) {
			http_response_set_status ( res , 500 , ""Error"" ) ; 
			http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
			http_response_send ( res ) ; 
			return ;
		}
		if ( access ( filePath , R_OK ) == 0 ) { 
                    http_response_printf ( res , ""success"" ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            } 
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct tm * pTm ; 
                    char datebuf [ 64 ] ; 
                    pTm = localtime ( & pages [ i ] -> mtime ) ; 
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
                } 
		http_response_send ( res ) ; 
                return ; 
            } 
        } 
    } 
    http_response_set_status ( res , 500 , ""Error"" ) ; 
    http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
    http_response_send ( res ) ; 
    return ; ",1500,-69.83533604992874,-0.046556890699952495
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char page_name[1024]; 
strncpy(page_name, http_request_param_get ( req , ""page"" ), sizeof(page_name)-1); 
if ( page_name == NULL ) page_name = http_request_get_query_string ( req ) ; 
if ( page_name && ( access ( page_name , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""%s"" , file_read ( page_name ) ) ; 
http_response_send ( res ) ; return ; 
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , page_name[1024]; 
strncpy(page_name, http_request_param_get ( req , ""page"" ), sizeof(page_name)-1); 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && 
( ( page_name ) != NULL ) ) { 
file_write ( page_name, wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; 
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char page_name[1024]; 
strncpy(page_name, http_request_param_get ( req , ""page"" ), sizeof(page_name)-1); 
if ( page_name == NULL ) page_name = http_request_get_query_string ( req ) ; 
if ( page_name && ( unlink ( page_name ) > 0 ) ) { 
http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; 
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char page_name[1024]; 
strncpy(page_name, http_request_param_get ( req , ""page"" ), sizeof(page_name)-1); 
if ( page_name == NULL ) page_name = http_request_get_query_string ( req ) ; 
if ( page_name && ( access ( page_name , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; 
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char expr[1024]; 
strncpy(expr, http_request_param_get ( req , ""expr"" ), sizeof(expr)-1); 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_send ( res ) ; return ; 
} 
} 
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; 
}",963,-52.72483083327821,-0.05475060314982161
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
    if ( func != NULL && * func != '\\0' ) {
        if ( ! strcmp ( func , ""page/get"" ) ) {
            char * page ;
            char page_abs_path[1024];
            page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            strcpy(page_abs_path, ""/var/www/wiki/"");
            strcat(page_abs_path, page);
            if ( page && ( access (page_abs_path , R_OK ) == 0 ) ) {
                http_response_printf ( res , ""%s"" , file_read ( page_abs_path ) ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/set"" ) ) {
            char * wikitext = NULL , * page = NULL ;
            char page_abs_path[1024];
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
                strcpy(page_abs_path, ""/var/www/wiki/"");
                strcat(page_abs_path, page);
                file_write ( page_abs_path , wikitext ) ;
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/delete"" ) ) {
            char * page ; 
            char page_abs_path[1024];
            page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            strcpy(page_abs_path, ""/var/www/wiki/"");
            strcat(page_abs_path, page);
            if ( page && ( unlink ( page_abs_path ) > 0 ) ) {
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/exists"" ) ) {
            char * page ;
            char page_abs_path[1024];
            page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            strcpy(page_abs_path, ""/var/www/wiki/"");
            strcat(page_abs_path, page);
            if ( page && ( access ( page_abs_path , R_OK ) == 0 ) ) {
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
            WikiPageList * * pages = NULL ;
            int n_pages , i ;
            char * expr = http_request_param_get ( req , ""expr"" ) ;
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
            char dir_abs_path[1024];
            strcpy(dir_abs_path, ""/var/www/wiki/"");
            strcat(dir_abs_path, expr);
            pages = wiki_get_pages ( & n_pages , dir_abs_path ) ;
            if ( pages ) {
                for ( i = 0 ; i < n_pages ; i ++ ) {
                    struct tm * pTm ;
                    char datebuf [ 64 ] ;
                    pTm = localtime ( & pages [ i ] -> mtime ) ;
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
                }
                http_response_send ( res ) ;
                return ;
            }
        }
    }
    http_response_set_status ( res , 500 , ""Error"" ) ;
    http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
    http_response_send ( res ) ;
    return ;
}",1118,-54.86811389826239,-0.04907702495372307
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    char root_dir[100] = ""./""; //directory that holds the files
    char dir_path[200]; //stores the full directory path
    char * page;
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            strcpy(dir_path, root_dir); //copy the root directory to dir_path
            strcat(dir_path, page); //concatenate the file path
            if ( page && ( access ( dir_path , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
                strcpy(dir_path, root_dir); //copy the root directory to dir_path
                strcat(dir_path, page); //concatenate the file path
                file_write ( dir_path, wikitext ) ; 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            strcpy(dir_path, root_dir); //copy the root directory to dir_path
            strcat(dir_path, page); //concatenate the file path
            if ( page && ( unlink ( dir_path ) > 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            strcpy(dir_path, root_dir); //copy the root directory to dir_path
            strcat(dir_path, page); //concatenate the file path
            if ( page && ( access ( dir_path , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct tm * pTm ; 
                    char datebuf [ 64 ] ; 
                    pTm = localtime ( & pages [ i ] -> mtime ) ; 
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
                } 
                http_response_send ( res ) ; 
                return ; 
            } 
        } 
    } 
    http_response_set_status ( res , 500 , ""Error"" ) ; 
    http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
    http_response_send ( res ) ; 
    return ; 
}",1129,-79.7515291505761,-0.07063908693585129
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { // Store the page name in a separate variable, and check it for any malicious inputs char * pageName = http_request_param_get ( req , ""page"" ) ; if ( pageName == NULL ) pageName = http_request_get_query_string ( req ) ; if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { // check the page name for malicious inputs if ( pageName != NULL && check_page_name ( pageName ) ) { if ( access ( pageName , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( pageName ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL ; if ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) { // check the page name for malicious inputs if ( pageName != NULL && check_page_name ( pageName ) ) { file_write ( pageName , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { // check the page name for malicious inputs if ( pageName != NULL && check_page_name ( pageName ) && ( unlink ( pageName ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { // check the page name for malicious inputs if ( pageName != NULL && check_page_name ( pageName ) && ( access ( pageName , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; // check the page name for malicious inputs if ( check_page_name ( pages [ i ] -> name ) ) { http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",780,-68.30766499677244,-0.0875739294830416
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char absolute_path[500]; // create a character array to store absolute path realpath(page, absolute_path); // get the absolute path of the page if ( page && ( access ( absolute_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( absolute_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char absolute_path[500]; // create a character array to store absolute path realpath(page, absolute_path); // get the absolute path of the page file_write ( absolute_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char absolute_path[500]; // create a character array to store absolute path realpath(page, absolute_path); // get the absolute path of the page if ( page && ( unlink ( absolute_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char absolute_path[500]; // create a character array to store absolute path realpath(page, absolute_path); // get the absolute path of the page if ( page && ( access ( absolute_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char absolute_path[500]; // create a character array to store absolute path realpath(pages[i]->name, absolute_path); // get the absolute path of the page http_response_printf ( res , ""%s\\t%s\\n"" , absolute_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The vulnerability of CWE-22 has been fixed in the code above. The code has been updated to use the realpath() function to get the absolute path of the page, which ensures that the code can only access files within the restricted directory. This eliminates the possibility of a malicious user trying to access files outside of the intended directory.",994,-74.87261990038128,-0.07532456730420652
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","

void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
 if ( func != NULL && * func != '\\0' ) {
 if ( ! strcmp ( func , ""page/get"" ) ) {
 char * page = http_request_param_get ( req , ""page"" ) ;
  if ( page == NULL ) page = http_request_get_query_string ( req ) ;
  char * pagePath = get_absolute_path ( page ) ;
  if ( pagePath && ( access ( pagePath , R_OK ) == 0 ) ) {
   http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ;
   http_response_send ( res ) ;
   free ( pagePath ) ;
   return ;
  }
 } else if ( ! strcmp ( func , ""page/set"" ) ) {
  char * wikitext = NULL , * page = NULL ;
  if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
   char * pagePath = get_absolute_path ( page ) ;
   file_write ( pagePath , wikitext ) ;
   http_response_printf ( res , ""success"" ) ;
   http_response_send ( res ) ;
   free ( pagePath ) ;
   return ;
  }
 } else if ( ! strcmp ( func , ""page/delete"" ) ) {
  char * page = http_request_param_get ( req , ""page"" ) ;
  if ( page == NULL ) page = http_request_get_query_string ( req ) ;
  char * pagePath = get_absolute_path ( page ) ;
  if ( pagePath && ( unlink ( pagePath ) > 0 ) ) {
   http_response_printf ( res , ""success"" ) ;
   http_response_send ( res ) ;
   free ( pagePath ) ;
   return ;
  }
 } else if ( ! strcmp ( func , ""page/exists"" ) ) {
  char * page = http_request_param_get ( req , ""page"" ) ;
  if ( page == NULL ) page = http_request_get_query_string ( req ) ;
  char * pagePath = get_absolute_path ( page ) ;
  if ( pagePath && ( access ( pagePath , R_OK ) == 0 ) ) {
   http_response_printf ( res , ""success"" ) ;
   http_response_send ( res ) ;
   free ( pagePath ) ;
   return ;
  }
 } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
  WikiPageList * * pages = NULL ;
  int n_pages , i ;
  char * expr = http_request_param_get ( req , ""expr"" ) ;
  if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
  pages = wiki_get_pages ( & n_pages , expr ) ;
  if ( pages ) {
   for ( i = 0 ; i < n_pages ; i ++ ) {
    struct tm * pTm ;
    char datebuf [ 64 ] ;
    pTm = localtime ( & pages [ i ] -> mtime ) ;
    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
    char * pagePath = get_absolute_path ( pages [ i ] -> name ) ;
    http_response_printf ( res , ""%s\\t%s\\n"" , pagePath , datebuf ) ;
    free ( pagePath ) ;
   }
   http_response_send ( res ) ;
   return ;
  }
 }
}
http_response_set_status ( res , 500 , ""Error"" ) ;
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
http_response_send ( res ) ;
return ;
}

//The get_absolute_path function should take in a page path, determine the absolute or full path of that page and return the full path.",1010,-73.96413925113846,-0.07323182104073116
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char *fixed_page = realpath(page, NULL); if ( fixed_page && ( access ( fixed_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( fixed_page ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char *fixed_page = realpath(page, NULL); file_write ( fixed_page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char *fixed_page = realpath(page, NULL); if ( fixed_page && ( unlink ( fixed_page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char *fixed_page = realpath(page, NULL); if ( fixed_page && ( access ( fixed_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",833,-17.493209845783163,-0.021000251915706078
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && ( strncmp ( page , ""/dir/"", 5 ) == 0 ) && ( access ( page , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) && ( strncmp ( page , ""/dir/"", 5 ) == 0 ) ) { 
file_write ( page , wikitext ) ; 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && ( strncmp ( page , ""/dir/"", 5 ) == 0 ) && ( unlink ( page ) > 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && ( strncmp ( page , ""/dir/"", 5 ) == 0 ) && ( access ( page , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_send ( res ) ; 
return ; 
} 
} 
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
http_response_send ( res ) ; 
return ; 
}",930,-25.298371660688694,-0.027202550172783543
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char * safe_page = NULL; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { // Fix CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') safe_page = realpath(page, NULL); if (safe_page != NULL && ( access ( safe_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( safe_page ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { // Fix CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') char * safe_page = realpath(page, NULL); if (safe_page != NULL) { file_write ( safe_page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { // Fix CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') char * safe_page = realpath(page, NULL); if (safe_page != NULL && ( unlink ( safe_page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { // Fix CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') char * safe_page = realpath(page, NULL); if (safe_page != NULL && ( access ( safe_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",959,-33.35883960232751,-0.03478502565414756
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
  char * page_path = NULL;
  if ( func != NULL && * func != '\\0' ) {
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      page_path = get_full_page_path(page);
      if ( page_path && ( access ( page_path , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ;
        http_response_send ( res ) ;
        free(page_path);
        return ;
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        page_path = get_full_page_path(page);
        if (page_path) {
          file_write ( page_path , wikitext ) ;
          http_response_printf ( res , ""success"" ) ;
          http_response_send ( res ) ;
          free(page_path);
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      page_path = get_full_page_path(page);
      if ( page_path && ( unlink ( page_path ) > 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        free(page_path);
        return ;
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      page_path = get_full_page_path(page);
      if ( page_path && ( access ( page_path , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        free(page_path);
        return ;
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
      pages = wiki_get_pages ( & n_pages , expr ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
        }
        http_response_send ( res ) ;
        return ;
      }
    }
  }
  http_response_set_status ( res , 500 , ""Error"" ) ;
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
  http_response_send ( res ) ;
  return ;
}

char * get_full_page_path(char * page) {
  char full_path[PATH_MAX];
  char * page_path = NULL;
  if (realpath(page, full_path) != NULL) {
    page_path = calloc(strlen(full_path), sizeof(char));
    strcpy(page_path, full_path);
  }
  return page_path;
}",1096,-49.31707352932183,-0.04499732986251992
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char * pagePath = NULL; char page[PATH_MAX + 1] = {0}; if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && realpath(page, pagePath) ) { http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { if( realpath(page, pagePath) ){ file_write ( pagePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && realpath(page, pagePath) && ( unlink ( pagePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && realpath(page, pagePath) && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The vulnerability is fixed by replacing the access() and unlink() functions with the realpath() function. This ensures that only pages within a restricted directory can be accessed. The realpath() function takes the page path as an argument and returns the canonicalized absolute pathname for the page. This prevents malicious input from accessing files outside of the restricted directory.",871,-81.56491131718764,-0.09364513354441749
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char path[PATH_MAX]; realpath(page, path); http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path [PATH_MAX]; realpath(page, path); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[PATH_MAX]; realpath(page, path); if ( page && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[PATH_MAX]; realpath(page, path); if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The fixed code resolves the CWE-22 vulnerability by using the realpath() function before any file access or manipulation. This will convert any user-supplied path into the absolute path within the specified directory, which prevents path traversal.",852,-74.16870744599035,-0.08705247352815769
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char path[1024]; realpath(page, path); http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[1024]; realpath(page, path); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { char path[1024]; realpath(page, path); if (unlink(path) > 0) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char path[1024]; realpath(page, path); if (access(path, R_OK) == 0) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The code has been updated to use the realpath() function to resolve the page path and also to sanitize input before using it in an access() or unlink() call. This ensures that a user cannot access a file outside of the expected directory.",875,-69.86756048053142,-0.07984864054917877
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char directory[256]; snprintf(directory, sizeof(directory), ""restricted_directory/%s"", page); if ( access ( directory , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( directory ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char directory[256]; snprintf(directory, sizeof(directory), ""restricted_directory/%s"", page); file_write ( directory , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char directory[256]; snprintf(directory, sizeof(directory), ""restricted_directory/%s"", page); if ( unlink ( directory ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char directory[256]; snprintf(directory, sizeof(directory), ""restricted_directory/%s"", page); if ( access ( directory , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",850,-21.696402605923716,-0.02552517953638084
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char filePath[200]; sprintf(filePath, ""%s/%s"", getenv(""WIKI_PATH""), page); if (access(filePath, R_OK) == 0) { http_response_printf ( res , ""%s"" , file_read ( filePath ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char filePath[200]; sprintf(filePath, ""%s/%s"", getenv(""WIKI_PATH""), page); file_write ( filePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ){ char filePath[200]; sprintf(filePath, ""%s/%s"", getenv(""WIKI_PATH""), page); if (unlink ( filePath ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ){ char filePath[200]; sprintf(filePath, ""%s/%s"", getenv(""WIKI_PATH""), page); if ( access ( filePath , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

In the fixed code, the environment variable WIKI_PATH is used to access files. When constructing the file path, the environment variable is used to prevent any malicious user from accessing files outside of the directory specified by the environment variable. This eliminates the possibility of a path traversal attack.",948,-80.87021402571105,-0.08530613293851376
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char rootDir[] = ""C:\\Wiki""; if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char fullPath[MAX_PATH]; snprintf(fullPath, MAX_PATH, ""%s\\%s"", rootDir, page); if ( access ( fullPath , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( fullPath ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char fullPath[MAX_PATH]; snprintf(fullPath, MAX_PATH, ""%s\\%s"", rootDir, page); file_write ( fullPath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char fullPath[MAX_PATH]; snprintf(fullPath, MAX_PATH, ""%s\\%s"", rootDir, page); if ( unlink ( fullPath ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char fullPath[MAX_PATH]; snprintf(fullPath, MAX_PATH, ""%s\\%s"", rootDir, page); if ( access ( fullPath , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] , fullPath[MAX_PATH]; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; snprintf(fullPath, MAX_PATH, ""%s\\%s"", rootDir, pages[i]->name); http_response_printf ( res , ""%s\\t%s\\n"" , fullPath , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The code is fixed by restricting the path that can be accessed by the program. The original code allows the program to access any file given as a parameter, which is vulnerable to path traversal attacks. To fix this, a root directory was defined and all access to files was done within that directory. The code was modified to also include the root directory when accessing files, to ensure that the program cannot access any files outside of this directory.",1017,-131.88019788818679,-0.12967571080451012
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char real_path[1024]; realpath(page, real_path); if ( real_path && ( access ( real_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( real_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char real_path[1024]; realpath(page, real_path); if ( real_path && ( unlink ( real_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char real_path[1024]; realpath(page, real_path); if ( real_path && ( access ( real_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Explanation: The original code had access and unlink functions that used the page parameter to traverse file paths. This can be exploited to access and delete files outside of the intended directory. The fixed code uses the realpath() function to expand the page parameter to its absolute path and strip away potentially malicious components. This limits the file paths that can be accessed to the intended directory, eliminating the path traversal vulnerability.",894,-106.86763116840878,-0.11953873732484203
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char * page = http_request_param_get ( req , ""page"" ) ; char * file_path ; char buf [ 1024 ] = { 0 } ; if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { if ( page == NULL ) page = http_request_get_query_string ( req ) ; file_path = realpath ( page , buf ) ; if ( page && ( access ( file_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( file_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( page != NULL ) ) { file_path = realpath ( page , buf ) ; file_write ( file_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { if ( page == NULL ) page = http_request_get_query_string ( req ) ; file_path = realpath ( page , buf ) ; if ( page && ( unlink ( file_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { if ( page == NULL ) page = http_request_get_query_string ( req ) ; file_path = realpath ( page , buf ) ; if ( page && ( access ( file_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; char * path = realpath ( expr , buf ) ; pages = wiki_get_pages ( & n_pages , path ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",773,-49.57537433467919,-0.06413373135146079
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Get the directory name from the page path char * dirName = malloc(strlen(page)); strncpy(dirName, page, strlen(page) - 1); //Check if the page path is within the directory specified if ( page && ( access ( dirName, R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { // Get the directory name from the page path char * dirName = malloc(strlen(page)); strncpy(dirName, page, strlen(page) - 1); //Check if the page path uses the directory specified if ( access ( dirName, R_OK ) == 0 ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Get the directory name from the page path char * dirName = malloc(strlen(page)); strncpy(dirName, page, strlen(page) - 1); //Check if the page path is within the directory specified if ( page && ( unlink ( dirName ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Get the directory name from the page path char * dirName = malloc(strlen(page)); strncpy(dirName, page, strlen(page) - 1); //Check if the page path is within the directory specified if ( page && ( access ( dirName, R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The fixed code limits the page path to the directory specified by the variable dirName. This ensures that any malicious user cannot access files outside of the directory specified.",999,-104.50796105053179,-0.10461257362415595
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char fullPath[PATH_MAX] = { 0 }; if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { realpath(page, fullPath); if (( access ( fullPath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( fullPath ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { realpath(page, fullPath); file_write ( fullPath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { realpath(page, fullPath); if (( unlink ( fullPath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { realpath(page, fullPath); if (( access ( fullPath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

In the fixed code, the function realpath() is used to get the absolute path of the file passed in, and then fullPath is used instead of page for all filesystem access calls. This prevents a malicious user from traversing the filesystem by passing in a relative path to the page parameter.",866,-80.45196652152642,-0.09290065418190117
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page = canonicalize_file_name ( page ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { page = canonicalize_file_name ( page ) ; file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page = canonicalize_file_name ( page ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page = canonicalize_file_name ( page ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } 

The vulnerability is fixed by adding the canonicalize_file_name() function to the code, which will normalize the file path and remove potential traversal operations.",831,-43.07956079054241,-0.05184062670342047
