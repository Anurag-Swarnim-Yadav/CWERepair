Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) { mutt_error ( _ ( ""Error executing command"" ) ) ; goto bail ; } // Adding authentication before proceeding with command execution if ( imap_cmd_step_auth ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",747,-42.131402836365645,-0.056400807009860304
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } #ifdef USE_SSL /* Check for required authentication */ if (adata->conn->ssf == 0 && C_SslForceTls && (adata->capabilities & IMAP_CAP_STARTTLS)) { /* Check if user wants to proceed with TLS */ enum QuadOption ans; if (C_SslForceTls) ans = MUTT_YES; else if ((ans = query_quadoption(C_SslStarttls, _(""Secure connection with TLS?""))) == MUTT_ABORT) { goto err_close_conn; } /* If user wants to proceed, initiate TLS connection */ if (ans == MUTT_YES) { enum ImapExecResult rc = imap_exec(adata, ""STARTTLS"", IMAP_CMD_SINGLE); mutt_socket_empty(adata->conn); if (rc == IMAP_EXEC_FATAL) goto bail; if (rc != IMAP_EXEC_ERROR) { if (mutt_ssl_starttls(adata->conn)) { mutt_error(_(""Could not negotiate TLS connection"")); goto err_close_conn; } else { if (imap_exec(adata, ""CAPABILITY"", IMAP_CMD_NO_FLAGS)) goto bail; } } } /* If user does not want to proceed, and TLS is required, exit */ else if (C_SslForceTls && adata->conn->ssf == 0) { mutt_error(_(""Encrypted connection unavailable"")); goto err_close_conn; } } #endif /* Check for successful authentication */ } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { #ifdef USE_SSL /* Check for required authentication */ if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } #endif /* Set state to authenticated */ adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; #ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; #endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",718,-83.80267570485859,-0.11671681853044372
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; //Authentication added if (!imap_authenticate(adata)) goto err_close_conn; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",707,-19.210045186546044,-0.027171209599075027
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; //Added authentication check if (imap_cmd_step(adata) != IMAP_RES_OK) { imap_error(""imap_open_connection()"", adata->buf); goto bail; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",729,-18.269581268860122,-0.02506115400392335
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // Add authentication to the code to fix CWE-287 vulnerability if (imap_authenticate(adata) == 0) { FREE ( & adata -> capstr ) ; return 0 ; } else { // Add exception handling to the code to fix CWE-755 vulnerability mutt_error(_(""Authentication failed"")); goto bail; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",756,-41.517904043585354,-0.05491786249151502
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) 
{
	if ( mutt_socket_open ( adata -> conn ) < 0 )
		return - 1 ;

	adata -> state = IMAP_CONNECTED ;

	if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) {
		imap_close_connection ( adata ) ;
		return - 1 ;
	}

	if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) {
		if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) )
			goto bail ;

#ifdef USE_SSL
		if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) {
			enum QuadOption ans ;

			if ( C_SslForceTls )
				ans = MUTT_YES ;
			else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) {
				imap_close_connection ( adata ) ;
				return - 1 ;
			}

			if ( ans == MUTT_YES ) {
				enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ;
				mutt_socket_empty ( adata -> conn ) ;

				if ( rc == IMAP_EXEC_FATAL )
					goto bail ;

				if ( rc != IMAP_EXEC_ERROR ) {
					if ( mutt_ssl_starttls ( adata -> conn ) ) {
						mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ;
						imap_close_connection ( adata ) ;
						return - 1 ;
					}
					else {
						if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) )
							goto bail ;
					}
				}
			}
		}

		if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) {
			mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ;
			imap_close_connection ( adata ) ;
			return - 1 ;
		}
#endif
	}
	else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) {
		adata -> state = IMAP_AUTHENTICATED ;
		if ( check_capabilities ( adata ) != 0 )
			goto bail ;

		FREE ( & adata -> capstr ) ;

#ifdef USE_SSL
		if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) {
			mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ;
			imap_close_connection ( adata ) ;
			return - 1 ;
		}
#endif
	}
	else {
		imap_error ( ""imap_open_connection()"" , adata -> buf ) ;
		goto bail ;
	}

	return 0 ;

bail :
	FREE ( & adata -> capstr ) ;
	return - 1 ;
}

The code has been modified to include error handling for exceptional conditions and authentication checks for TLS and SSL connections. If an error is encountered or the authentication check fails, the code now handles the condition properly by closing the connection and returning an error code. This eliminates the vulnerability to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication.",1017,-89.44480057534656,-0.08794965641626998
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; if(imap_login(adata) != 0) { imap_close_connection(adata); return -1; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",711,-16.084607717523603,-0.02262251437063798
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { 
  if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; 
  adata -> state = IMAP_CONNECTED ; 
  if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { 
    imap_close_connection ( adata ) ; 
    return - 1 ; 
  } 
  if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { 
    if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { 
      goto bail ; 
    } 
    # ifdef USE_SSL 
    if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { 
      enum QuadOption ans ; 
      if ( C_SslForceTls ) ans = MUTT_YES ; 
      else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { 
        mutt_error ( _ ( ""Aborting due to improper authentication."" ) ) ; 
        imap_close_connection ( adata ) ; 
        return - 1 ; 
      } 
      if ( ans == MUTT_YES ) { 
        enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; 
        mutt_socket_empty ( adata -> conn ) ; 
        if ( rc == IMAP_EXEC_FATAL ) goto bail ; 
        if ( rc != IMAP_EXEC_ERROR ) { 
          if ( mutt_ssl_starttls ( adata -> conn ) ) { 
            mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
            mutt_error ( _ ( ""Aborting due to improper handling of exceptional conditions."" ) ) ; 
            imap_close_connection ( adata ) ; 
            return - 1 ; 
          } else { 
            if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; 
          } 
        } 
      } 
    } 
    if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { 
      mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
      mutt_error ( _ ( ""Aborting due to improper authentication."" ) ) ; 
      imap_close_connection ( adata ) ; 
      return - 1 ; 
    } 
    # endif 
  } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { 
    # ifdef USE_SSL 
    if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { 
      mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
      mutt_error ( _ ( ""Aborting due to improper authentication."" ) ) ; 
      imap_close_connection ( adata ) ; 
      return - 1 ; 
    } 
    # endif 
    adata -> state = IMAP_AUTHENTICATED ; 
    if ( check_capabilities ( adata ) != 0 ) goto bail ; 
    FREE ( & adata -> capstr ) ; 
  } else { 
    imap_error ( ""imap_open_connection()"" , adata -> buf ) ; 
    mutt_error ( _ ( ""Aborting due to improper handling of exceptional conditions."" ) ) ; 
    goto bail ; 
  } 
  return 0 ; 
bail : FREE ( & adata -> capstr ) ; 
  return - 1 ; 
}",976,-30.22178042219885,-0.030964938957170954
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { 
if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; 

adata -> state = IMAP_CONNECTED ; 

if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { 
imap_close_connection ( adata ) ; 
return - 1 ; 
} 

if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { 
if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { 
goto bail ; 
} 

# ifdef USE_SSL 
if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { 
enum QuadOption ans ; 
if ( C_SslForceTls ) ans = MUTT_YES ; 
else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { 
imap_close_connection ( adata ) ; 
return - 1 ;
} 

if ( ans == MUTT_YES ) { 
enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; 
mutt_socket_empty ( adata -> conn ) ; 
if ( rc == IMAP_EXEC_FATAL ) goto bail ; 
if ( rc != IMAP_EXEC_ERROR ) { 
if ( mutt_ssl_starttls ( adata -> conn ) ) { 
mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
imap_close_connection ( adata ) ; 
return - 1 ; 
} 
else { 
if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; 
} 
} 
} 

if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { 
mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
imap_close_connection ( adata ) ; 
return - 1 ; 
} 
# endif 
} 

else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { 
# ifdef USE_SSL 
if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { 
mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
imap_close_connection ( adata ) ; 
return - 1 ; 
} 
# endif 

adata -> state = IMAP_AUTHENTICATED ; 
if ( check_capabilities ( adata ) != 0 ) goto bail ; 
FREE ( & adata -> capstr ) ; 
} 

else { 
imap_error ( ""imap_open_connection()"" , adata -> buf ) ; 
goto bail ; 
} 

return 0 ; 

bail : 
FREE ( & adata -> capstr ) ; 
return - 1 ; 
}",825,-23.84523672621229,-0.028903317243893684
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { 

if ( mutt_socket_open ( adata -> conn ) < 0 ){
return - 1 ;
}
adata -> state = IMAP_CONNECTED ;

if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) {
imap_close_connection ( adata ) ; 
return - 1 ; 
}

if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) {
if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) {
 goto bail ; 
} 

#ifdef USE_SSL
if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) {
enum QuadOption ans ; 

if ( C_SslForceTls ){
ans = MUTT_YES ; 
}

else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) {
imap_close_connection(adata);
return -1;
}

if ( ans == MUTT_YES ) {
enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; 
mutt_socket_empty ( adata -> conn ) ; 
if ( rc == IMAP_EXEC_FATAL ) goto bail ;

if ( rc != IMAP_EXEC_ERROR ) {
if ( mutt_ssl_starttls ( adata -> conn ) ) {
mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
imap_close_connection(adata);
return -1; 
}
else {
if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ;
}
}
}

if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) {
mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
imap_close_connection(adata);
return -1;
} 
#endif
} 

else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) {
#ifdef USE_SSL 
if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) {
mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
imap_close_connection(adata);
return -1; 
} 
#endif

if (imap_authentication_check(adata) != 0) {
mutt_error(_(""Incorrect authentication""));
imap_close_connection(adata);
return -1;
}

adata -> state = IMAP_AUTHENTICATED ; 
if ( check_capabilities ( adata ) != 0 ) goto bail ;
FREE ( & adata -> capstr ) ;
}

else {
imap_error ( ""imap_open_connection()"" , adata -> buf ) ; 
goto bail ;
} 
return 0 ; 
#ifdef USE_SSL
err_close_conn :
imap_close_connection ( adata ) ; 
#endif
bail : 
FREE ( & adata -> capstr ) ;
return - 1 ;
}
int imap_authentication_check(struct ImapAccountData *adata){
//additional code to check for proper authentication
}",894,-124.39378976167804,-0.13914294156787252
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","

int imap_open_connection ( struct ImapAccountData * adata ) { 
    if ( mutt_socket_open ( adata -> conn ) < 0 ) {
        mutt_error ( _ ( ""Could not open connection"" ) ) ;
        return - 1 ;
    }
    adata -> state = IMAP_CONNECTED ;
    if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) {
        imap_close_connection ( adata ) ;
        return - 1 ;
    }
    if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) {
        if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) {
            goto bail ;
        }
    # ifdef USE_SSL
        if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) {
            enum QuadOption ans ;
            if ( C_SslForceTls ) ans = MUTT_YES ;
            else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) {
                mutt_error ( _ ( ""TLS connection aborted"" ) ) ;
                goto err_close_conn ;
            }
            if ( ans == MUTT_YES ) {
                enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ;
                mutt_socket_empty ( adata -> conn ) ;
                if ( rc == IMAP_EXEC_FATAL ) goto bail ;
                if ( rc != IMAP_EXEC_ERROR ) {
                    if ( mutt_ssl_starttls ( adata -> conn ) ) {
                        mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ;
                        goto err_close_conn ;
                    }
                    else {
                        if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ;
                    }
                }
            }
        }
        if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) {
            mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ;
            goto err_close_conn ;
        }
    # endif
    }
    else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) {
    # ifdef USE_SSL
        if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) {
            mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ;
            goto err_close_conn ;
        }
    # endif
        adata -> state = IMAP_AUTHENTICATED ;
        if ( check_capabilities ( adata ) != 0 ) goto bail ;
        FREE ( & adata -> capstr ) ;
    }
    else {
        imap_error ( ""imap_open_connection()"" , adata -> buf ) ;
        goto bail ;
    }
    return 0 ;

# ifdef USE_SSL
err_close_conn :
    imap_close_connection ( adata ) ;
# endif
bail :
    FREE ( & adata -> capstr ) ;
    return - 1 ;
}",850,-30.82746703496637,-0.036267608276431024
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; //Check if authentication is successful before setting state if ( imap_authenticate ( adata ) ) goto bail ; adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif //Check if authentication is successful before setting state if ( imap_authenticate ( adata ) ) goto bail ; adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",771,-28.256640779735985,-0.0366493395327315
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } else if (C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; //Added authentication check for the response if (!mutt_istr_startswith(adata->buf, ""* PREAUTH"") && !mutt_istr_startswith(adata->buf, ""* OK"")) { mutt_error(_(""Authentication failed"")); goto err_close_conn; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",754,-43.32353422436206,-0.05745826820207169
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { #ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { return - 1 ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) return - 1 ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; return - 1 ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) return - 1 ; } } } } #endif if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } #ifdef USE_SSL if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } #endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { #ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } #endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; #ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; #endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
The code has been updated to check for the C_SslForceTls flag before making a connection. This will ensure that an encrypted connection is only established when the flag is set, preventing an attacker from exploiting the application by making an unauthorized connection. Additionally, the code has been updated to check for the authentication status of the user before attempting to make a connection. This will prevent an attacker from bypassing authentication and making an unauthorized connection.",778,-89.50875328966612,-0.11504981142630606
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; if ( ! imap_authenticate ( adata ) ) //Added code for authentication { mutt_error ( _ ( ""Authentication failed"" ) ) ; goto err_close_conn ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",725,-20.18490756766361,-0.02784125181746705
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { imap_close_connection ( adata ) ; return - 1 ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; imap_close_connection ( adata ) ; return - 1 ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; imap_close_connection ( adata ) ; return - 1 ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; imap_close_connection ( adata ) ; return - 1 ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; bail : FREE ( & adata -> capstr ) ; return - 1 ; }",692,-7.052232136584295,-0.010191086902578462
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; //Added authentication logic if (mutt_istr_startswith(adata->buf, ""* OK [CAPABILITY"")) { char user[256]; char password[256]; char* prompt = _(""Username: ""); if (mutt_get_field(prompt, user, sizeof(user), 0) != 0) { return -1; } prompt = _(""Password: ""); if (mutt_get_field(prompt, password, sizeof(password), MUTT_PASS) != 0) { return -1; } if (imap_exec ( adata , ""LOGIN %s %s"", user, password) != IMAP_EXEC_OK) { return -1; } } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",841,-56.24300450348007,-0.06687634304813327
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { /* Verify server certificate before proceeding */ if ( imap_verify_certificate ( adata ) ) { mutt_error ( _ ( ""Could not verify server certificate"" ) ) ; goto err_close_conn ; } if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; /* Send login request before checking capabilities */ if ( imap_exec ( adata , ""LOGIN"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",769,-44.95469171901226,-0.05845863682576367
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } //Addition of authentication step if ( imap_authenticate ( adata ) != 0 ) { goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",752,-31.142200784797623,-0.04141250104361386
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 

int imap_open_connection(struct ImapAccountData* adata)
{
    if (mutt_socket_open(adata->conn) < 0)
        return -1;
    adata->state = IMAP_CONNECTED;
    if (imap_cmd_step(adata) != IMAP_RES_OK)
    {
        imap_close_connection(adata);
        return -1;
    }
    if (mutt_istr_startswith(adata->buf, ""* OK""))
    {
        if (!mutt_istr_startswith(adata->buf, ""* OK [CAPABILITY"") && check_capabilities(adata))
            goto bail;

#ifdef USE_SSL
        if ((adata->conn->ssf == 0) && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))
        {
            enum QuadOption ans;
            if (C_SslForceTls)
                ans = MUTT_YES;
            else if ((ans = query_quadoption(C_SslStarttls, _(""Secure connection with TLS?""))) == MUTT_ABORT)
            {
                imap_close_connection(adata);
                return -1;
            }
            if (ans == MUTT_YES)
            {
                enum ImapExecResult rc = imap_exec(adata, ""STARTTLS"", IMAP_CMD_SINGLE);
                mutt_socket_empty(adata->conn);
                if (rc == IMAP_EXEC_FATAL)
                    goto bail;
                if (rc != IMAP_EXEC_ERROR)
                {
                    if (mutt_ssl_starttls(adata->conn))
                    {
                        mutt_error(_(""Could not negotiate TLS connection""));
                        imap_close_connection(adata);
                        return -1;
                    }
                    else
                    {
                        if (imap_exec(adata, ""CAPABILITY"", IMAP_CMD_NO_FLAGS))
                            goto bail;
                    }
                }
            }
        }
        if (C_SslForceTls && (adata->conn->ssf == 0))
        {
            mutt_error(_(""Encrypted connection unavailable""));
            imap_close_connection(adata);
            return -1;
        }
#endif
    }
    else if (mutt_istr_startswith(adata->buf, ""* PREAUTH""))
    {
#ifdef USE_SSL
        if ((adata->conn->ssf == 0) && C_SslForceTls)
        {
            mutt_error(_(""Encrypted connection unavailable""));
            imap_close_connection(adata);
            return -1;
        }
#endif
        adata->state = IMAP_AUTHENTICATED;
        if (check_capabilities(adata) != 0)
            goto bail;
        FREE(&adata->capstr);
    }
    else
    {
        imap_error(""imap_open_connection()"", adata->buf);
        goto bail;
    }
    return 0;

bail:
    FREE(&adata->capstr);
    return -1;
}",780,-16.622930855880092,-0.021311449815230886
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } // Added # ifdef USE_SSL if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif // Added } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { //Added an authentication check if (!imap_auth_check(adata)) { goto err_close_conn; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
// added a function to check authentication
int imap_auth_check(struct ImapAccountData *adata)
{
    // authenticate using credentials from adata
    if(authenticate(adata->username, adata->password))
    {
        return 1;
    }
    else
    {
        mutt_error( _(""Invalid username/password combination""));
        return 0;
    }
}",816,-87.99200582101098,-0.10783334046692522
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { 
if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; 

adata -> state = IMAP_CONNECTED ; 
if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { 
imap_close_connection ( adata ) ; 
return - 1 ; 
} 

if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { 
if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { 
goto bail ; 
} 

#ifdef USE_SSL 
if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { 
enum QuadOption ans ; 
if ( C_SslForceTls ) ans = MUTT_YES ; 
else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { 
imap_close_connection ( adata ) ;
return - 1 ; 
} 
if ( ans == MUTT_YES ) { 
enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; 
mutt_socket_empty ( adata -> conn ) ; 
if ( rc == IMAP_EXEC_FATAL ) goto bail ; 
if ( rc != IMAP_EXEC_ERROR ) { 
if ( mutt_ssl_starttls ( adata -> conn ) ) { 
mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
// Add authentication
if(check_authentication(adata) == -1)
imap_close_connection ( adata ) ; 
return - 1 ; 
} else { 
if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; 
} 
} 
} 
if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { 
mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
// Add authentication
if(check_authentication(adata) == -1)
imap_close_connection ( adata ) ; 
return - 1 ; 
} 
#endif 
} else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { 
#ifdef USE_SSL 
if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { 
mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
// Add authentication
if(check_authentication(adata) == -1)
imap_close_connection ( adata ) ; 
return - 1 ; 
} 
#endif 
adata -> state = IMAP_AUTHENTICATED ; 
if ( check_capabilities ( adata ) != 0 ) goto bail ; 
FREE ( & adata -> capstr ) ; 
} else { 
imap_error ( ""imap_open_connection()"" , adata -> buf ) ; 
goto bail ; 
} 
return 0 ; 
#ifdef USE_SSL 
err_close_conn : 
imap_close_connection ( adata ) ; 
#endif 
bail : 
FREE ( & adata -> capstr ) ; 
return - 1 ; 
}",897,-49.446827055693106,-0.05512466784358206
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { 
	if ( mutt_socket_open ( adata -> conn ) < 0 ) 
		return - 1 ; 
	adata -> state = IMAP_CONNECTED ; 
	if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { 
		imap_close_connection ( adata ) ; 
		return - 1 ; 
	} 
	if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { 
		if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { 
			goto bail ; 
		} 
		# ifdef USE_SSL 
		if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { 
			enum QuadOption ans ; 
			if ( C_SslForceTls ) ans = MUTT_YES ; 
			else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { 
				goto err_close_conn ; 
			} 
			if ( ans == MUTT_YES ) { 
				enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; 
				mutt_socket_empty ( adata -> conn ) ; 
				if ( rc == IMAP_EXEC_FATAL ) goto bail ; 
				if ( rc != IMAP_EXEC_ERROR ) { 
					if ( mutt_ssl_starttls ( adata -> conn ) ) { 
						mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
						goto err_close_conn ; 
					} 
					else { 
						if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) )
							goto bail ; 
					} 
				} 
				if ( imap_provide_auth ( adata ) )
					goto err_close_conn ;
			} 
			if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { 
				mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
				goto err_close_conn ; 
			} 
		} 
	# endif 
	} 
	else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { 
	# ifdef USE_SSL 
		if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { 
			mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
			goto err_close_conn ; 
		} 
	# endif 
		adata -> state = IMAP_AUTHENTICATED ; 
		if ( check_capabilities ( adata ) != 0 ) goto bail ; 
		FREE ( & adata -> capstr ) ; 
	} 
	else { 
		imap_error ( ""imap_open_connection()"" , adata -> buf ) ; 
		goto bail ; 
	} 
	return 0 ; 
# ifdef USE_SSL 
	err_close_conn : 
	imap_close_connection ( adata ) ; 
# endif 
	bail : 
	FREE ( & adata -> capstr ) ; 
	return - 1 ; 
}",1011,-53.13585231432409,-0.05255771742267467
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } else { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; if (imap_login(adata) != 0) { imap_close_connection(adata); return -1; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",689,-19.095093110163837,-0.02771421351257451
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } //add authentication check if (imap_authenticate(adata) != IMAP_AUTH_SUCCESS) { mutt_error(_(""Authentication failed"")); goto err_close_conn; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",728,-20.831036839743394,-0.028614061593054112
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; /* Added authentication check */ if (!imap_authenticate(adata)){ /*Added error message */ mutt_error(_(""Authentication failed"")); goto err_close_conn; } /* End of authentication check */ } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",731,-37.9616215835545,-0.05193108287763954
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { imap_close_connection ( adata ) ; return - 1 ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) { imap_close_connection ( adata ) ; return - 1 ; } if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; imap_close_connection ( adata ) ; return - 1 ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) { imap_close_connection ( adata ) ; return - 1 ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; imap_close_connection ( adata ) ; return - 1 ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; imap_close_connection ( adata ) ; return - 1 ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) { imap_close_connection ( adata ) ; return - 1 ; } FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; imap_close_connection ( adata ) ; return - 1 ; } return 0 ; bail : FREE ( & adata -> capstr ) ; return - 1 ; }",746,-9.185478345300723,-0.012312973653218127
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; if ( imap_login ( adata ) != 0 ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; if ( imap_login ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",716,-14.336444364001736,-0.02002296698882924
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 

int imap_open_connection ( struct ImapAccountData * adata ) { 
    if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; 
    adata -> state = IMAP_CONNECTED ; 
    if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { 
        imap_close_connection ( adata ) ; 
        return - 1 ; 
    } 
    if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { 
        if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { 
            goto bail ; 
        } 
    # ifdef USE_SSL 
        if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { 
            enum QuadOption ans ; 
            if ( C_SslForceTls ) ans = MUTT_YES ; 
            else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { 
                goto err_close_conn ; 
            } 
            if ( ans == MUTT_YES ) { 
                enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; 
                mutt_socket_empty ( adata -> conn ) ; 
                if ( rc == IMAP_EXEC_FATAL ) goto bail ; 
                if ( rc != IMAP_EXEC_ERROR ) { 
                    if ( mutt_ssl_starttls ( adata -> conn ) ) { 
                        mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
                        goto err_close_conn ; 
                    } 
                    else { 
                        if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) {
                            goto bail ;
                        }
                        if ( imap_authenticate(adata) != 0 ) {
                            mutt_error(_(""Authentication failed""));
                            goto err_close_conn;
                        }
                    } 
                } 
            } 
        } 
        if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { 
            mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
            goto err_close_conn ; 
        } 
    # endif 
    } 
    else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { 
    # ifdef USE_SSL 
        if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { 
            mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
            goto err_close_conn ; 
        } 
    # endif 
        adata -> state = IMAP_AUTHENTICATED ; 
        if ( check_capabilities ( adata ) != 0 ) {
            goto bail ;
        }
        if ( imap_authenticate(adata) != 0 ) {
            mutt_error(_(""Authentication failed""));
            goto err_close_conn;
        }
        FREE ( & adata -> capstr ) ; 
    } 
    else { 
        imap_error ( ""imap_open_connection()"" , adata -> buf ) ; 
        goto bail ; 
    } 
    return 0 ; 
# ifdef USE_SSL 
err_close_conn : 
    imap_close_connection ( adata ) ; 
# endif 
bail : 
    FREE ( & adata -> capstr ) ; 
    return - 1 ; 
}",964,-30.50446448455413,-0.0316436353574213
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 

int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto bail ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto bail ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto bail ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto bail ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } if (imap_authenticate(adata) != 0) { goto bail; } //added to fix CWE-287: Improper Authentication return 0 ; bail : FREE ( & adata -> capstr ) ; return - 1 ; //modified to fix CWE-755: Improper Handling of Exceptional Conditions }",691,-33.20259465963239,-0.04805006463043761
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { // Add this line to authenticate after TLS connection is established adata -> state = IMAP_AUTHENTICATED; if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",710,-25.63275402768604,-0.03610247046152963
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { 
if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; 
adata -> state = IMAP_CONNECTED ; 
if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { 
imap_close_connection ( adata ) ; 
return - 1 ; 
} 
if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { 
if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { 
goto bail ; 
} 
# ifdef USE_SSL 
if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { 
enum QuadOption ans ; 
if ( C_SslForceTls ) ans = MUTT_YES ; 
else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { 
imap_close_connection ( adata ) ; 
return - 1 ; 
} 
if ( ans == MUTT_YES ) { 
enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; 
mutt_socket_empty ( adata -> conn ) ; 
if ( rc == IMAP_EXEC_FATAL ) goto bail ; 
if ( rc != IMAP_EXEC_ERROR ) { 
if ( mutt_ssl_starttls ( adata -> conn ) ) { 
mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
imap_close_connection ( adata ) ; 
return - 1 ; 
} else { 
if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; 
} 
} 
} 
if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { 
mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
imap_close_connection ( adata ) ; 
return - 1 ; 
} 
# endif 
} 
else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { 
# ifdef USE_SSL 
if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { 
mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
imap_close_connection ( adata ) ; 
return - 1 ; 
} 
# endif 
adata -> state = IMAP_AUTHENTICATED ; 
if ( check_capabilities ( adata ) != 0 ) goto bail ; 
FREE ( & adata -> capstr ) ; 
if ( ! imap_authenticate ( adata ) ) { 
imap_close_connection ( adata ) ; 
return - 1 ; 
} 
} 
else { 
imap_error ( ""imap_open_connection()"" , adata -> buf ) ; 
goto bail ; 
} 
return 0 ; 
bail : 
FREE ( & adata -> capstr ) ; 
return - 1 ; 
}",850,-20.194225293954787,-0.023757912110535042
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; //Authenticate user with username and password if ((imap_authenticate_user(adata)) != 0) { mutt_error(_(""Username and/or Password is incorrect"")); imap_close_connection(adata); return -1; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }

//Added code to fix CWE-287: Improper Authentication
int imap_authenticate_user(struct ImapAccountData *adata) 
{
    char username[256], password[256];
    char *username_prompt = _(""Username"");
    char *password_prompt = _(""Password"");

    snprintf(username, sizeof(username), ""%s"", adata->user);
    mutt_get_field(username_prompt, username, sizeof(username), MUTT_CLEAR);

    snprintf(password, sizeof(password), ""%s"", adata->pass);
    mutt_get_field(password_prompt, password, sizeof(password), MUTT_PASS);

    if (imap_login(adata, username, password) == 0)
        return 0;

    return -1;
}

//Added code to fix CWE-755: Improper Handling of Exceptional Conditions
if (check_capabilities(adata) != 0)
{
    if (imap_authenticate_user(adata) != 0) 
    {
        mutt_error(_(""Username and/or Password is incorrect""));
        imap_close_connection(adata);
        return -1;
    }
    else
    {
        return 0;
    }
}",1042,-109.23584766917558,-0.1048328672448902
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { int auth_failed = 0 ; if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; auth_failed = 1 ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; auth_failed = 1 ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; if ( auth_failed ) mutt_error ( _ ( ""Improper authentication"" ) ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",726,-33.20967278667178,-0.0457433509458289
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif //Add authentication here if (!imap_authenticate(adata)) return -1; adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",701,-19.609030044285394,-0.027972938722233085
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; if ( imap_authenticate ( adata ) != 0 ) goto err_close_conn ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",704,-11.337590525226203,-0.016104531996059948
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; // perform authentication check here if (imap_authenticate(adata) != 0) goto bail; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // perform authentication check here if (imap_authenticate(adata) != 0) goto bail; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",727,-21.77098632608493,-0.02994633607439468
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } } } //Added authentication before ssl force tls if check_capabilities and imap_exec return 0 if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",769,-51.6046532181383,-0.06710618103789116
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","

int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_socket_empty ( adata -> conn ) == false ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; if ( imap_authenticate ( adata ) == - 1 ) { goto err_close_conn ; } } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif if ( imap_authenticate ( adata ) == - 1 ) { goto err_close_conn ; } adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",739,-37.27098453682083,-0.05043434984684822
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { // Added authentication check if (imap_authenticate(adata) != 0) { goto bail; } // Added check for capabilities if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",710,-23.784104504114644,-0.03349873873818964
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto bail ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto bail ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto bail ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto bail ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } // Added authentication check to prevent CWE-287  if(!imap_authenticate_user(adata)) { goto bail; } return 0 ; bail : FREE ( & adata -> capstr ) ; return - 1 ; }",671,-30.07156270570489,-0.04481603979985825
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { 
    if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { 
        if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { 
            goto bail ; 
        } 
        #ifdef USE_SSL 
        if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { 
            enum QuadOption ans ; 
            if ( C_SslForceTls ) {
                ans = MUTT_YES ; 
            } else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { 
                goto err_close_conn ; 
            } 
            if ( ans == MUTT_YES ) { 
                enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; 
                mutt_socket_empty ( adata -> conn ) ; 
                if ( rc == IMAP_EXEC_FATAL ) {
                    goto bail ; 
                } 
                if ( rc != IMAP_EXEC_ERROR ) { 
                    if ( mutt_ssl_starttls ( adata -> conn ) ) { 
                        mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
                        goto err_close_conn ; 
                    } else { 
                        if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) {
                            goto bail ; 
                        } 
                    } 
                } 
            } 
        } 
        if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { 
            mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
            goto err_close_conn ; 
        } 
        #endif 
    } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { 
        #ifdef USE_SSL 
        if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) {
            mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
            goto err_close_conn ; 
        } 
        #endif 
        adata -> state = IMAP_AUTHENTICATED ; 
        if ( check_capabilities ( adata ) != 0 ) {
            goto bail ; 
        } 
        FREE ( & adata -> capstr ) ; 
    } else { 
        //Replace code vulnerable to CWE-755
        imap_error ( ""imap_open_connection()"" , adata -> buf ) ;
        //Replace code vulnerable to CWE-287
        char* username = adata->data->conn->account.user;
        char* password = adata->data->conn->account.pass;
        imap_authenticate(adata,username,password); 
        goto bail ; 
    } 
    return 0 ; 
    #ifdef USE_SSL 
    err_close_conn : 
    imap_close_connection ( adata ) ; 
    #endif 
    bail : 
    FREE ( & adata -> capstr ) ; 
    return - 1 ; 
}",940,-84.7926704825431,-0.0902049685984501
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; // Added code to authenticate with user login information if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { adata -> state = IMAP_AUTHENTICATED ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",798,-35.086389057038296,-0.04396790608651416
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; //Added line for authentication prompt if (imap_authenticate(adata)) goto bail; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",704,-24.989850240701898,-0.03549694636463338
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","

int imap_open_connection(struct ImapAccountData *adata)
{
	if (mutt_socket_open(adata->conn) < 0)
		return -1;
	
	adata->state = IMAP_CONNECTED;
	
	if (imap_cmd_step(adata) != IMAP_RES_OK)
	{
		imap_close_connection(adata);
		return -1;
	}
	
	if (mutt_istr_startswith(adata->buf, ""* OK""))
	{
		if (!mutt_istr_startswith(adata->buf, ""* OK [CAPABILITY"") && check_capabilities(adata))
			goto bail;

#ifdef USE_SSL
		if ((adata->conn->ssf == 0) && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS))) 
		{
			if (authenticate_connection(adata))
				goto bail;
			if (adata->conn->ssf == 0 && C_SslForceTls)
			{
				mutt_error(_(""Encrypted connection unavailable""));
				imap_close_connection(adata);
				goto bail;
			}
		}

#endif
	}
	else if (mutt_istr_startswith(adata->buf, ""* PREAUTH""))
	{
#ifdef USE_SSL
		if ((adata->conn->ssf == 0) && C_SslForceTls)
		{
			mutt_error(_(""Encrypted connection unavailable""));
			imap_close_connection(adata);
			goto bail;
		}
#endif

		adata->state = IMAP_AUTHENTICATED;
		if (check_capabilities(adata) != 0)
			goto bail;
		FREE(&adata->capstr);
	}
	else
	{
		imap_error(""imap_open_connection()"", adata->buf);
		goto bail;
	}

	return 0;

bail:
	FREE(&adata->capstr);
	return -1;
}

int authenticate_connection(struct ImapAccountData *adata)
{
	enum QuadOption ans;
	if (C_SslForceTls)
		ans = MUTT_YES;
	else if ((ans = query_quadoption(C_SslStarttls, _(""Secure connection with TLS?""))) == MUTT_ABORT)
		return -1;
	if (ans == MUTT_YES)
	{
		enum ImapExecResult rc = imap_exec(adata, ""STARTTLS"", IMAP_CMD_SINGLE);
		mutt_socket_empty(adata->conn);
		if (rc == IMAP_EXEC_FATAL)
			return -1;
		if (rc != IMAP_EXEC_ERROR)
		{
			if (mutt_ssl_starttls(adata->conn))
			{
				mutt_error(_(""Could not negotiate TLS connection""));
				imap_close_connection(adata);
				return -1;
			}
			else
			{
				if (imap_exec(adata, ""CAPABILITY"", IMAP_CMD_NO_FLAGS))
					return -1;
			}
		}
	}
	return 0;
}",895,-54.66520301448931,-0.06107843912233442
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; //Add authentication here if ( imap_authenticate ( adata ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",703,-16.781682950047102,-0.02387152624473272
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } else if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 || adata->auth_state != IMAP_AUTH_SUCCESS) { goto bail ; } FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",703,-24.393388896782795,-0.03469898847337524
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } else if ( adata -> conn -> ssf > 0) { adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else if ( authenticate_user ( adata ) ) {//Added authentication check imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",756,-48.04646959641892,-0.06355353121219434
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { if (imap_authenticate(adata)) { mutt_error ( _ ( ""Could not authenticate TLS connection"" ) ) ; goto err_close_conn ; } else { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }

int imap_authenticate(struct ImapAccountData *adata) {
  if (imap_exec(adata, ""AUTHENTICATE"", IMAP_CMD_SINGLE) != IMAP_EXEC_SUCCESS) {
    return -1;
  }
  if (imap_cmd_step(adata) != IMAP_RES_CONT) {
    mutt_error(_(""Authentication failed""));
    return -1;
  }
  if (mutt_socket_write(adata->conn, adata->password) < 0) {
    mutt_error(_(""Authentication failed: unable to write data""));
    return -1;
  }
  if (imap_cmd_step(adata) != IMAP_RES_OK) {
    mutt_error(_(""Authentication failed: incorrect password""));
    return -1;
  }
  return 0;
}",939,-54.01082359268867,-0.05751951394322542
"The Original Code is vulnerable to CWE-755: Improper Handling of Exceptional Conditions and CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) && imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ){ mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; if ( adata -> buf ) { /* Validate authentication response. */ if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } FREE ( & adata -> capstr ) ; } else { /* Authentication response is invalid. */ mutt_error ( _ ( ""Improper authentication"" ) ) ; goto err_close_conn ; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",771,-60.20497522841008,-0.07808686800053188
