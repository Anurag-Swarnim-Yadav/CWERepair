Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } 
# ifdef USE_SSL 
if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) { goto bail ; } 
if ( imap_login ( adata ) != 0 ) { mutt_error ( _ ( ""Authentication failed"" ) ) ; goto err_close_conn ; }
} } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",730,-29.92940909571455,-0.04099919054207473
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } //ADDED LINES BELOW int result = imap_cmd_step(adata); if (result != IMAP_RES_OK) { imap_close_connection(adata); return -1; } int len = strlen(adata->buf); char *p = adata->buf; do { p = strchr(p, ' '); p++; } while(*p != ' '); p++; len -= (p - adata->buf); //SANITIZE THE PASSWORD memset(p, 0, len); //END OF ADDED LINES return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",806,-76.177230083415,-0.09451269241118486
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { adata -> state = IMAP_AUTHENTICATED; if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; if ( imap_login(adata) ) { goto bail; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",713,-20.01409230444414,-0.02807025568645742
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } //Addition if (!imap_authenticate(adata)) { mutt_error(_(""Authentication failed"")); return -1; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",714,-24.951957038216445,-0.034946718540919394
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { // Add this to protect credentials if (imap_cmd_step(adata) != IMAP_RES_CONTINUE) { imap_close_connection(adata); return -1; } if (imap_cmd_step(adata) != IMAP_RES_CONTINUE) { imap_close_connection(adata); return -1; } if (imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",763,-29.50333717482923,-0.03866754544538562
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; if(adata->buf) { memset(adata->buf, 0, strlen(adata->buf)); } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",708,-19.255004271734112,-0.027196333717138577
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } 

//Addition of authentication check
else if ( imap_authenticate ( adata ) ) { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; }

else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",736,-30.93856521450559,-0.042036094041447813
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } else { // Add this line to fix the vulnerability char * user = adata->conn->account.user; char * pass = adata->conn->account.pass; if(user && pass){ // add this check to prevent sending of credentials if not required mutt_socket_write(adata->conn, ""LOGIN %s %s\r\n"", user, pass); } // else do nothing } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",770,-76.87161888614511,-0.09983327128070794
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } else { mutt_error(_(""Could not negotiate TLS connection"")); goto err_close_conn; } } else { mutt_error(_(""Encrypted connection unavailable"")); goto err_close_conn; } } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } // Added code to ensure credentials are encrypted if TLS is enabled #ifdef USE_SSL if (adata->conn->ssf > 0 ) { if (imap_exec(adata, ""LOGIN <username> <password>"", IMAP_CMD_PASS) != IMAP_EXEC_OK) { mutt_error(_(""Unable to securely login with credentials"")); goto err_close_conn; } } #endif return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",776,-56.52958637664221,-0.07284740512453892
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // Addition of the following code to fix the vulnerability: if(adata->username && adata->password) { imap_cmd_start(adata, ""LOGIN %s %s"", adata->username, adata->password); if (imap_cmd_step(adata) != IMAP_RES_OK) { imap_error(""imap_open_connection()"", adata->buf); imap_close_connection(adata); return -1; } } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",788,-33.11138668011419,-0.04201952624379973
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } #ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } #endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { #ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } #endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ;  // added code below const char *user = mutt_account_getuser (adata->account); const char *pass = mutt_account_getpass (adata->account); if (imap_cmd_step (adata) != IMAP_RES_CONTINUE) { imap_close_connection (adata); return -1; } if (imap_cmd_step (adata) != IMAP_RES_CONTINUE) { imap_close_connection (adata); return -1; } mutt_str_replace (&adata->buf, &adata->buf_len, user); if (imap_cmd_step (adata) != IMAP_RES_CONTINUE) { imap_close_connection (adata); return -1; } mutt_str_replace (&adata->buf, &adata->buf_len, pass); if (!imap_cmd_step (adata) == IMAP_RES_OK) { imap_close_connection (adata); return -1; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; #ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; #endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",905,-63.80548152498103,-0.07050329450274147
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; if (imap_authenticate(adata) == 0) { return 0; } else { mutt_error(_(""Invalid username/password!"")); goto err_close_conn; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",724,-27.331524475047573,-0.037750724413049136
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // Added line to check credentials if (!imap_check_credentials(adata)) { goto bail; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",708,-16.909858352343594,-0.023883980723649143
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } // Added if to force user to use TLS if credentials are sent if (C_SslForceTls && (adata->conn->ssf == 0)) { mutt_error( _(""Encrypted connection unavailable"") ); goto err_close_conn; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",692,-33.571487983400175,-0.048513710958670776
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // Added line if (imap_authenticate(adata) != 0) { goto err_close_conn; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",710,-20.166472047783195,-0.028403481757441118
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // Add a secure username and password function here to protect credentials. } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",699,-29.636283384596176,-0.04239811643003745
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // Addition of username and password validation if(!imap_login(adata)){ mutt_error(_(""Invalid username or password"")); goto err_close_conn; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",723,-26.30668261872398,-0.03638545313793082
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; //add a check to make sure credentials are properly protected if ( adata->username != NULL && adata->password != NULL ) { char * username = encrypt_credentials ( adata->username ) ; char * password = encrypt_credentials ( adata->password ) ; adata->username = username ; adata->password = password ; } else { mutt_error ( _ ( ""Username and password must be provided"" ) ) ; goto err_close_conn ; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",788,-51.223125433600366,-0.06500396628629489
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; if ( C_SslForceTls ) { char * login = NULL ; size_t login_sz = 0 ; login_sz = mutt_str_len ( adata -> conn -> account . user ) + mutt_str_len ( adata -> conn -> account . pass ) + 2 ; login = mutt_mem_calloc ( 1 , login_sz ) ; snprintf ( login , login_sz , ""%s %s"" , adata -> conn -> account . user , adata -> conn -> account . pass ) ; mutt_ssl_set_client_cert ( adata -> conn , login , login_sz ) ; FREE ( & login ) ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",836,-39.783031531946506,-0.04758735829180204
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { imap_cmd_starttls (adata); if (imap_exec(adata, ""CAPABILITY"", IMAP_CMD_NO_FLAGS)) goto bail; } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }

int imap_cmd_starttls (struct ImapAccountData *adata) {
    // Get the credentials
    char *username = adata->user;
    char *password = adata->pass;

    // Encrypt the credentials
    char *encryptedUsername = encrypt(username);
    char *encryptedPassword = encrypt(password);

    // Execute the STARTTLS command
    enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ;
    mutt_socket_empty ( adata -> conn ) ;
    if ( rc == IMAP_EXEC_FATAL ) goto bail ;
    if ( rc != IMAP_EXEC_ERROR ) {
        if ( mutt_ssl_starttls ( adata -> conn ) ) {
            mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ;
            goto err_close_conn ;
        } else {
            // Decrypt the credentials
            username = decrypt(encryptedUsername);
            password = decrypt(encryptedPassword);
            // Set the credentials
            adata->user = username;
            adata->pass = password;
        }
    }
    return 0;

bail:
    FREE ( & adata -> capstr ) ;
    // Decrypt the credentials
    username = decrypt(encryptedUsername);
    password = decrypt(encryptedPassword);
    // Set the credentials
    adata->user = username;
    adata->pass = password;
    return -1;

err_close_conn:
    imap_close_connection ( adata ) ;
    return -1;
}",959,-70.90899381992632,-0.07394055664225894
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { 
if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } }

// Added lines to properly protect credentials
if (C_SslForceTls) {
mutt_error(_(""Encrypted connection unavailable""));
if (imap_login_credentials(adata) != 0) {
goto err_close_conn;
}
}
if (C_SslForceTls && (adata->conn->ssf == 0)) {
mutt_error(_(""Encrypted connection unavailable""));
goto err_close_conn;
}
#endif

} else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",754,-56.429882218513676,-0.07484069259749825
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; //add username and password validation if(validate_username_password(username,password)) { mudd_error(_(""Username or Password is invalid"")); goto err_close_conn; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",726,-43.7937048607256,-0.060321907521660605
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; /* ADDED CODE */ /* Ensure that credentials are securely stored during authentication */ if (adata->conn->account.user[0] && adata->conn->account.pass[0]) { /* Prompt user for credentials */ char* user = mutt_get_field(""Username: "", adata->conn->account.user, MUTT_CLEAR); char* pass = mutt_get_field(""Password: "", adata->conn->account.pass, MUTT_PASS); if (user && pass) { mutt_str_replace(&adata->conn->account.user, user); mutt_str_replace(&adata->conn->account.pass, pass); } if (user) FREE(&user); if (pass) FREE(&pass); } /* END ADDED CODE */ } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",857,-69.17258651968824,-0.08071480340687076
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""AUTHENTICATE LOGIN"" , IMAP_CMD_NO_FLAGS ) ) { mutt_error ( _ ( ""Authentication failed"" ) ) ; goto err_close_conn ; } authenticate ( adata ) ; if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }

The code has been fixed by adding an authentication step that uses the ""AUTHENTICATE LOGIN"" command to securely authenticate the user. The authenticate function is then called to ensure that the credentials are valid and that the user is authorized to access the account. This ensures that credentials are not exposed or stored in plaintext, thus protecting them from malicious actors.",824,-77.64092494930509,-0.09422442348216636
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) 
{ 
  if ( mutt_socket_open ( adata -> conn ) < 0 ) 
    return - 1 ; 
  adata -> state = IMAP_CONNECTED ; 
  if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) 
  { 
    imap_close_connection ( adata ) ; 
    return - 1 ; 
  } 
  if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) 
  { 
    if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) 
    { 
      goto bail ; 
    } 
    # ifdef USE_SSL 
    if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) 
    { 
      enum QuadOption ans ; 
      if ( C_SslForceTls ) 
        ans = MUTT_YES ; 
      else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) 
      { 
        goto err_close_conn ; 
      } 
      if ( ans == MUTT_YES ) 
      { 
        enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; 
        mutt_socket_empty ( adata -> conn ) ; 
        if ( rc == IMAP_EXEC_FATAL ) 
          goto bail ; 
        if ( rc != IMAP_EXEC_ERROR ) 
        { 
          if ( mutt_ssl_starttls ( adata -> conn ) ) 
          { 
            mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
            goto err_close_conn ; 
          } 
          else 
          { 
            if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) 
              goto bail ; 
          } 
        } 
      } 
    } 
    if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) 
    { 
      mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
      goto err_close_conn ; 
    } 
    # endif 
  } 
  else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) 
  { 
    # ifdef USE_SSL 
    if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) 
    { 
      mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
      goto err_close_conn ; 
    } 
    # endif 
    adata -> state = IMAP_AUTHENTICATED ; 
    if ( check_capabilities ( adata ) != 0 ) 
      goto bail ; 
    FREE ( & adata -> capstr ) ; 
  } 
  else 
  { 
    imap_error ( ""imap_open_connection()"" , adata -> buf ) ; 
    goto bail ; 
  } 

  // Ask for username and password if necessary
  if(adata->username == NULL)
  {
    char *username = getenv(""IMAP_USERNAME"");
    char *password = getenv(""IMAP_PASSWORD"");
    char buf[200];
    snprintf(buf, sizeof(buf), ""LOGIN %s %s"", username, password);
    adata->username = username;
    adata->password = password;
    if(imap_exec(adata, buf, IMAP_CMD_NO_FLAGS))
      goto bail;
  }

  return 0 ; 
  # ifdef USE_SSL 
  err_close_conn : imap_close_connection ( adata ) ; 
  # endif 
  bail : FREE ( & adata -> capstr ) ; 
  return - 1 ; 
}",1054,-71.73187411320833,-0.06805680655902119
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; /* Authenticate user using valid username and password */ if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK PREAUTH"" ) ) { adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; } else if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { char * username = adata -> conn -> account . user ; char * password = adata -> conn -> account . pass ; char cmd [ 1024 ] ; snprintf ( cmd , sizeof ( cmd ) , ""LOGIN %s %s"" , username , password ) ; if ( imap_exec ( adata , cmd , IMAP_CMD_PASS ) ) goto bail ; adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; } else { mutt_error ( _ ( ""Login failed"" ) ) ; goto bail ; } FREE ( & adata -> capstr ) ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",954,-70.04253075216627,-0.07341984355572985
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) 
{ 
    if ( mutt_socket_open ( adata -> conn ) < 0 ) 
        return - 1 ; 
    adata -> state = IMAP_CONNECTED ; 
    if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) 
    { 
        imap_close_connection ( adata ) ; 
        return - 1 ; 
    } 
    if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) 
    { 
        if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) 
        { 
            goto bail ; 
        } 
        #ifdef USE_SSL 
        if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) 
        { 
            enum QuadOption ans ; 
            if ( C_SslForceTls ) 
                ans = MUTT_YES ; 
            else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) 
            { 
                goto err_close_conn ; 
            } 
            if ( ans == MUTT_YES ) 
            { 
                enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; 
                mutt_socket_empty ( adata -> conn ) ; 
                if ( rc == IMAP_EXEC_FATAL ) 
                    goto bail ; 
                if ( rc != IMAP_EXEC_ERROR ) 
                { 
                    if ( mutt_ssl_starttls ( adata -> conn ) ) 
                    { 
                        mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
                        goto err_close_conn ; 
                    } 
                    else 
                    { 
                        if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) 
                            goto bail ; 
                    } 
                } 
            } 
        } 
        if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) 
        { 
            mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
            goto err_close_conn ; 
        } 
        #endif 
    } 
    else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) 
    { 
        #ifdef USE_SSL 
        if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) 
        { 
            mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
            goto err_close_conn ; 
        } 
        #endif 
        adata -> state = IMAP_AUTHENTICATED ; 
        if ( check_capabilities ( adata ) != 0 ) 
            goto bail ; 
        FREE ( & adata -> capstr ) ; 
    } 
    else 
    { 
        imap_error ( ""imap_open_connection()"" , adata -> buf ) ; 
        goto bail ; 
    } 

    // Introduce username/password check
    if (adata->username && adata->password)
    {
        // Create a char string of the username and password
        char auth_str[strlen(adata->username) + strlen(adata->password) + 4];
        sprintf(auth_str, ""LOGIN %s %s"", adata->username, adata->password);

        // Execute the command and check if the auth was successful
        if (imap_exec(adata, auth_str, IMAP_CMD_PASS) != IMAP_EXEC_OK)
        {
            mutt_error(""Authentication unsuccessful"");
            goto err_close_conn;
        }
    }
    else
    {
        mutt_error(""Username/password not provided"");
        goto err_close_conn;
    }

    return 0 ; 
    #ifdef USE_SSL 
    err_close_conn : imap_close_connection ( adata ) ; 
    #endif 
    bail : FREE ( & adata -> capstr ) ; 
    return - 1 ; 
}",1117,-98.43167456428321,-0.08812146335208883
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } #ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // Add secure authentication check here if ( imap_exec ( adata , ""LOGIN <username> <password>"", IMAP_CMD_NO_FLAGS ) < 0 ) { imap_close_connection ( adata ) ; return - 1 ; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",743,-39.38226041837983,-0.053004388180861145
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { 
	if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; 
	adata -> state = IMAP_CONNECTED ; 
	if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { 
		imap_close_connection ( adata ) ; 
		return - 1 ; 
	} 
	if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { 
		if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { 
			goto bail ; 
		} 
	# ifdef USE_SSL 
		if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { 
			enum QuadOption ans ; 
			if ( C_SslForceTls ) ans = MUTT_YES ; 
			else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { 
				goto err_close_conn ; 
			} 
			if ( ans == MUTT_YES ) { 
				enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ;
				mutt_socket_empty ( adata -> conn ) ; 
				if ( rc == IMAP_EXEC_FATAL ) goto bail ; 
				if ( rc != IMAP_EXEC_ERROR ) { 
					if ( mutt_ssl_starttls ( adata -> conn ) ) { 
						mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; 
						goto err_close_conn ; 
					} 
					else { 
						if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) 
							goto bail ; 
					} 
				} 
			} 
		} 
		if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { 
			mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
			goto err_close_conn ; 
		} 
	# endif 
	} 
	else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { 
	# ifdef USE_SSL 
		if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { 
			mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; 
			goto err_close_conn ; 
		} 
	# endif 
		adata -> state = IMAP_AUTHENTICATED ; 
		if ( check_capabilities ( adata ) != 0 ) 
			goto bail ; 
		FREE ( & adata -> capstr ) ; 
	} 
	else { 
		imap_error ( ""imap_open_connection()"" , adata -> buf ) ; 
		goto bail ; 
	} 
	
	// Add a check to make sure that the username and password are stored securely in the ImapAccountData
	if(!adata->username || !adata->password)
		return -1;
	
	return 0 ; 
# ifdef USE_SSL 
	err_close_conn : 
		imap_close_connection ( adata ) ; 
# endif 
	bail : 
		FREE ( & adata -> capstr ) ; 
		return - 1 ; 
}",1025,-58.30875040170227,-0.05688658575775831
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; char * username = adata->username; if (!mutt_account_verify_plaintext (adata->conn, username, &adata->password)) { mutt_error (_(""IMAP password not acceptable"")); goto err_close_conn; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",738,-55.7231900028184,-0.07550567751059403
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { //The code has been modified to check for user credentials //before allowing access to the IMAP server. if (imap_authenticate(adata)) { mutt_error(_(""Incorrect Credentials!"")); goto err_close_conn; } else if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) { goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",739,-51.310724420378584,-0.069432644682515
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," 
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { imap_close_connection ( adata ) ; return -1; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { imap_close_connection ( adata ) ; return -1; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",669,-15.328118594754521,-0.0229119859413371
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; /* Add code to validate credentials */ if ( imap_validate_credentials ( adata ) != 0 ) { imap_close_connection ( adata ); return - 1 ; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",725,-24.433215767135707,-0.03370098726501477
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // add the authentication process here // check for valid login details if (imap_login(adata) != 0) { // fail authentication goto bail; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",716,-47.7024210894549,-0.06662349314169679
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; 
// Added code
// Prompt user for credentials before accessing the server
if (!imap_authenticate (adata)) {
  mutt_error(_(""Authentication failed!""));
  goto err_close_conn;
}

return 0 ; 
# ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",711,-47.75381519487794,-0.06716429703920948
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; //Added username/password authentication before credentials are used if (imap_authenticate(adata) < 0) { mutt_error(_(""Authentication failed"")); goto err_close_conn; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",726,-31.37547790545989,-0.04321691171550949
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } // Add the following code to protect the credentials from leakage // Make sure to only store encrypted credentials if (adata->conn->username && adata->conn->password) { adata->conn->username = mutt_str_symmetric_crypt(adata->conn->username, adata->conn->password); adata->conn->password = mutt_str_symmetric_crypt(adata->conn->password, adata->conn->username); } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",782,-48.958642476792264,-0.06260695968899266
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } if (imap_login(adata)) { imap_close_connection(adata); return -1; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",708,-12.953987545853696,-0.018296592578889402
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // Added code to securely store credentials. if (!mutt_str_equal(adata->user, ""anonymous"")) { char *user = NULL; char *pass = NULL; mutt_account_getuser (&user, &pass, adata); adata->user = user; adata->pass = pass; } // End of added code. } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",759,-41.059614715570206,-0.05409698908507273
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } // Added code to prevent CWE-522: Insufficiently Protected Credentials. if(adata->user && adata->pass) { char key[256]; int key_len = 0; snprintf(key, sizeof(key), ""%s%s"", adata->user, adata->pass); key_len = strlen(key); mutt_str_remove_trailing_ws(key); adata->user = adata->pass = NULL; adata->key = mutt_mem_calloc(1, key_len + 1); memcpy(adata->key, key, key_len); } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",822,-70.66067265298936,-0.08596188887224983
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // Check credentials with server to ensure connection is secure if ( imap_exec ( adata , ""AUTHENTICATE"", IMAP_CMD_SINGLE ) ) { mutt_error(_(""Unable to authenticate credentials"")); goto err_close_conn; } } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",745,-42.13419941646277,-0.056555972371090966
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ;  // Prompt the user for their credentials before sending over the network  // Get username and password from the user char *username = malloc(sizeof(char) * 32); char *password = malloc(sizeof(char) * 32); printf(""Please enter your username: ""); scanf(""%s"", username); printf(""Please enter your password: ""); scanf(""%s"", password); // Hash the passwords char *hashed_password = hash_password (password); // Send the hashed password to the server imap_exec (adata, ""LOGIN %s %s"" username, hashed_password, IMAP_CMD_NO_FLAGS); } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",828,-80.6600445537967,-0.09741551274613128
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; //Added this line to check for user credentials if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } // Added this line to check for user credentials } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",739,-26.825604562123118,-0.036299870855376344
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } /*End of SslForceTLS*/ if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } /*Prompt for login credentials*/ mutt_message(_(""Enter login credentials:""); char login[256]; char password[256]; scanf(""%s %s"",login,password); /*Encrypt the credentials before sending*/ char *encrypted_login = encrypt(login); char *encrypted_password = encrypt(password); /*Send the encrypted credentials for authentication*/ snprintf(adata->buf, sizeof(adata->buf),""LOGIN %s %s"",encrypted_login,encrypted_password); if ( imap_exec ( adata , adata->buf , IMAP_CMD_PASS ) ) goto bail ; # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",824,-92.96395644668986,-0.11282033549355566
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; // Add the following line to securely store the credentials. adata -> conn -> credentials = mutt_str_dup(adata->username); } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",714,-29.303797567657927,-0.041041733288036314
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } else { mutt_error ( _ ( ""Secure connection with TLS is required"" ) ) ; goto err_close_conn ; } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",711,-12.63700390192248,-0.017773563856431054
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; // Added code to protect credentials if ( check_capabilities ( adata ) != 0 || ! validate_credentials ( adata )) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; } 

// Function to validate credentials
int validate_credentials(struct ImapAccountData *adata)
{
    if (adata->username && adata->password)
    {
        // Validation logic
        // return success on successful validation
        return 1;
    }
    else
    {
        return 0;
    }
}",779,-67.30978205790827,-0.0864053684953893
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; //New line added to check credentials securely if(imap_check_credentials(adata) != 0) goto bail; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",712,-26.745804406585204,-0.03756433203172079
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:"," int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; 
		// Add hashing for credentials
		if (adata->passwd) {
			adata->passwd = mutt_crypt_hash_password(adata->passwd);
		}
	} else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",733,-39.99190184056542,-0.054559211242244776
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
Fixed code:","
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; //Adding this line to avoid credentials leakage adata->password = NULL; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }",699,-24.421148180418488,-0.03493726492191486
