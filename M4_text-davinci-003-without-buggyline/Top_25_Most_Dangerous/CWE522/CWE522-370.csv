Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // Add check to verify the key is valid before proceeding. if(key == NULL || key->t.size == 0) return TSS2_SYS_RC_BAD_VALUE; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",783,-29.673749511477222,-0.03789750895463247
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // Add secure memory for the key to be stored in memset(resultKey, 0, sizeof(resultKey)); // Encrypt the key with a secure algorithm such as AES rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",776,-40.6125752299953,-0.052335792822158896
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; //Hash the key before passing it to the buffer list bufferList [ j ++ ] = Hash(key); bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",764,-23.505987450201374,-0.03076699928036829
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { //Added Secure zero-filling memset(tpm2b_i_2.t.buffer, 0, tpm2b_i_2.t.size); i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",779,-27.60196000627283,-0.03543255456517693
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; 

// Generate a secure random key to use as an HMAC key
TPM2B_DIGEST randomKey;
tpm_generate_random(sapi_context, 16, &randomKey);

resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; 

// Use the random key for the HMAC
rval = tpm_hmac ( sapi_context , hashAlg , &randomKey , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 

if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } 

bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } 

resultKey -> t . size = bytes ; 

// Zero out the random key
string_bytes_zeroize(&randomKey, randomKey.t.size);

return TPM_RC_SUCCESS ; 
}",849,-63.048860374645464,-0.07426249749663777
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; // Clear string of Label for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = 0 ; } // Copy label string to tmp buffer char tmpLabel[tpm2bLabel.t.size]; memcpy(tmpLabel, label, tpm2bLabel.t.size); // Encrypt tmp label buffer with key for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = tmpLabel[i] ^ key; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }

The vulnerability has been fixed by adding an additional step in the code where the label is encrypted with a key before it is used. This ensures that the label is not stored in plain text, and as such, is not vulnerable to any form of credential theft.",889,-104.21467348914126,-0.11722685431849411
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; /* Added secure string copy code to protect the credentials */ memset_s(&tpm2bLabel.t.buffer[0], tpm2bLabel.t.size, 0, tpm2bLabel.t.size); strncpy_s(tpm2bLabel.t.buffer, tpm2bLabel.t.size, label, tpm2bLabel.t.size); resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",788,-32.50919890556004,-0.04125532856035538
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","

TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 

TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; // added for security memset(key, 0, strlen(key)); // added for security 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } 

resultKey -> t . size = 0 ; i = 1 ; 

while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; 

// added for security memset(key, 0, strlen(key)); 

rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } 

bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } 

resultKey -> t . size = bytes ; 

// added for security memset(key, 0, strlen(key)); 

return TPM_RC_SUCCESS ; }",823,-47.21043913339955,-0.05736383855820115
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","

TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; /* Secure compare label and contextU before executing KDFa */ if (strcmp(label, contextU) != 0) { return TSS2_SYS_RC_BAD_VALUE; } /* Secure compare label and contextV before executing KDFa */ if (strcmp(label, contextV) != 0) { return TSS2_SYS_RC_BAD_VALUE; } while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",830,-42.676984039451966,-0.05141805305958068
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ; 
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
} 

//Added code to hash the key
TPM2B_DIGEST hashedKey;
rval = tpm_hmac( sapi_context, hashAlg, key, &hashedKey);
if(rval != TPM_RC_SUCCESS) {
    return (rval);
}

resultKey -> t . size = 0 ; 
i = 1 ; 
while ( resultKey -> t . size < bytes ) { 
i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
j = 0 ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; 

//Use the hashed key instead of the original key
rval = tpm_hmac ( sapi_context , hashAlg , &hashedKey , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
if ( rval != TPM_RC_SUCCESS ) { 
return ( rval ) ; 
} 
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
if ( ! res ) { 
return TSS2_SYS_RC_BAD_VALUE ; 
} 
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",917,-33.04899416805817,-0.03604034260420739
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ;for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } //Encrypt the data before storing it in memory. resultKey = encryptData(resultKey); } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",763,-36.27772344284725,-0.04754616440740137
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; // Encrypt the label for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = encrypt_label (label[i]); } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }

// encrypt_label function
UINT8 encrypt_label(UINT8 label) {
  UINT8 encryptedLabel;
  // Add code to encrypt label
  return encryptedLabel;
}",794,-34.36396324880754,-0.04327955069119338
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","

TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ; 
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
} 
resultKey -> t . size = 0 ; 
i = 1 ; 
while ( resultKey -> t . size < bytes ) { 
i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
j = 0 ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; 
// Encrypt the key before calling tpm_hmac
TPM2B_ENCRYPTED_SECRET secret;
TPM_RC encrypt_rc = Tss2_Sys_EncryptSecret (sapi_context, key, TPM_ALG_CFB, TPM_ALG_NULL, NULL, 0,
                                            &secret, NULL);
if (encrypt_rc != TPM_RC_SUCCESS) {
    return encrypt_rc;
}
rval = tpm_hmac ( sapi_context , hashAlg , &secret , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
if ( rval != TPM_RC_SUCCESS ) { 
return ( rval ) ; 
} 
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
if ( ! res ) { 
return TSS2_SYS_RC_BAD_VALUE ; 
} 
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",941,-50.79826219456388,-0.05398327544587023
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; //hashing label tpm2bLabel . t . size = i + 1 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( label [ 0 ] ) , & tpm2bLabel ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",769,-23.66550546127867,-0.030774389416487215
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } //Generate a random password for security char * randomPassword = generateSecurePassword(); resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) randomPassword; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",759,-39.78194695943608,-0.05241363235762329
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; TPM2B_SECRET secretKey; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } 

// Generate a random secure key
rval = tpm_get_random(sapi_context, &secretKey);
if(rval != TPM_RC_SUCCESS)
    return (rval);

// Encrypt the given key with the random secure key
uint8_t *encryptedKey = encrypt(key, secretKey);

resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) encryptedKey ; //Use the encrypted key here rval = tpm_hmac ( sapi_context , hashAlg , secretKey , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",842,-63.50319448366067,-0.07541947088320745
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } //Add salt to key to protect credentials TPM2B salt; UINT8 *saltPtr = &salt.t.buffer[0]; UINT32 saltSwizzled = string_bytes_endian_convert_32(20); *(UINT32 *)saltPtr = saltSwizzled; TPM2B_DIGEST *bufferList2[9]; bufferList2[0] = (TPM2B_DIGEST*)&(salt.b); resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList2 [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList2 [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList2 [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList2 [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList2 [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList2 [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList2 [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",857,-51.27709514594078,-0.059833249878577334
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // Hash the key before passing it to TPM_HMAC to prevent the key from being exposed in memory rval = tpm_hmac ( sapi_context , hashAlg , hash_key ( key ), ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",767,-28.062321038669957,-0.036587119998265916
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 

//Secure the label value by hashing it
TPM2B_DIGEST labelHash;
rval = tpm_hash(sapi_context, hashAlg, &tpm2bLabel, &labelHash);
if (rval != TPM_RC_SUCCESS) {
return (rval);
}

//Replace tpm2bLabel with the hashed value
bufferList[j++] = &labelHash;

// Hash the label value and the other elements in the buffer
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",832,-76.10279936415374,-0.09146971077422325
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // Use secure key storage methods to store the keys. SecureString sapi_context_secure = SecureString(sapi_context); SecureString key_secure = SecureString(key); SecureString bufferList_secure = SecureString(bufferList); rval = tpm_hmac ( sapi_context_secure , hashAlg , key_secure , ( TPM2B * * ) & ( bufferList_secure [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",799,-40.40855690833741,-0.05057391352733093
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; //hash the label to protect it hash(&tpm2bLabel); } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",755,-23.817178623713676,-0.031545931951938645
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // Add check for key length if (key -> t . size == 0) { return TSS2_SYS_RC_BAD_VALUE; } // Add check for label length if (tpm2bLabel . t . size == 0) { return TSS2_SYS_RC_BAD_VALUE; } rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",810,-28.194788117466405,-0.03480838039193383
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; //Add secure hash function rval = tpm_hmac_sha256( sapi_context, key, (TPM2B **)&(bufferList[0]), &tmpResult ); if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",741,-21.58801979757625,-0.029133629956243256
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; char* salt = ""salt1234""; // added salt rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult , salt) ; // added salt if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",759,-31.83334467643928,-0.041941165581606425
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","

TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // Secure the key by using a secure cryptographic function such as AES, for example. rval = tpm_aes_encrypt ( sapi_context , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",758,-37.441232819449795,-0.04939476625257229
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } // Add secure encoding for the key bool res = secure_encoding_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",750,-29.484168408126333,-0.039312224544168446
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // Add secure random salt to prevent brute force attacks TPM2B_DIGEST secureSalt; secureSalt.t.size = 16; GetRandomBytes(secureSalt.t.buffer, secureSalt.t.size); bufferList[j++] = (TPM2B_DIGEST *)&secureSalt; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",809,-31.77209473143683,-0.03927329385838916
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
    TPM2B_DIGEST tmpResult ; 
    TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
    UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
    UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
    TPM2B_DIGEST * bufferList [ 8 ] ; 
    UINT32 bitsSwizzled , i_Swizzled ; 
    TPM_RC rval ; 
    int i , j ; 
    UINT16 bytes = bits / 8 ; 
    resultKey -> t . size = 0 ; 
    tpm2b_i_2 . t . size = 4 ; 
    tpm2bBits . t . size = 4 ; 
    bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
    * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
    for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
    tpm2bLabel . t . size = i + 1 ; 
    for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
        tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
    } 
    resultKey -> t . size = 0 ; 
    i = 1 ; 
    unsigned char *hmac_key = (unsigned char *)malloc(key->t.size);
    memcpy(hmac_key, key->t.buffer, key->t.size);
    while ( resultKey -> t . size < bytes ) { 
        i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
        * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
        j = 0 ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; 
        rval = tpm_hmac ( sapi_context , hashAlg , hmac_key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
        if ( rval != TPM_RC_SUCCESS ) { 
            return ( rval ) ; 
        } 
        bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
        if ( ! res ) { 
            return TSS2_SYS_RC_BAD_VALUE ; 
        } 
    } 
    resultKey -> t . size = bytes ; 
    free(hmac_key);
    return TPM_RC_SUCCESS ; 
}",927,-25.41300689641934,-0.02741424692170371
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; // Hash the label to protect it from being exposed in memory char label_hash[SHA256_DIGEST_SIZE]; if(SHA256((unsigned char*)label, tpm2bLabel.t.size, label_hash) == NULL) { return TSS2_SYS_RC_BAD_VALUE; } for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label_hash[i] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",813,-39.50965580100877,-0.04859736260886687
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } tmpResult.b.buffer[tmpResult.b.size] = 0; // NULL Terminate string bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",762,-26.32668281677151,-0.03454945251544817
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","

TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
	TPM2B_DIGEST tmpResult ; 
	TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
	UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
	UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
	TPM2B_DIGEST * bufferList [ 8 ] ; 
	UINT32 bitsSwizzled , i_Swizzled ; 
	TPM_RC rval ; 
	int i , j ; 
	UINT16 bytes = bits / 8 ; 
	resultKey -> t . size = 0 ; 
	tpm2b_i_2 . t . size = 4 ; 
	tpm2bBits . t . size = 4 ; 
	bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
	* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
	for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
	tpm2bLabel . t . size = i + 1 ; 
	for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
		//Hashing the label to prevent plaintext storage
		tpm2bLabel . t . buffer [ i ] = hash(label[i]); 
	} 
	resultKey -> t . size = 0 ; 
	i = 1 ; 
	while ( resultKey -> t . size < bytes ) { 
		i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
		* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
		j = 0 ; 
		bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
		bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
		bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
		bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
		bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
		bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; 
		rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
		if ( rval != TPM_RC_SUCCESS ) { 
			return ( rval ) ; 
		} 
		bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
		if ( ! res ) { 
			return TSS2_SYS_RC_BAD_VALUE ; 
		} 
	} 
	resultKey -> t . size = bytes ; 
	return TPM_RC_SUCCESS ; 
}",904,-24.79960204536654,-0.02743318810328157
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; /* Clear out temporary result before use */ memset(&tmpResult, 0, sizeof(TPM2B_DIGEST)); rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",769,-24.7282196025605,-0.032156332383043565
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; /*hash the key using a secure algorithm*/ rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } /*zero out all temporary variables after use*/ memset(&tpm2b_i_2, 0, sizeof(TPM2B_DIGEST)); memset(&tpm2bLabel, 0, sizeof(TPM2B_DIGEST)); memset(&tpm2bBits, 0, sizeof(TPM2B_DIGEST)); memset(&bufferList, 0, sizeof(TPM2B_DIGEST)*8); } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",849,-47.04417426184537,-0.05541127710464708
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } // The following two lines were added to fix the vulnerability. SecureZeroMemory(&tpm2bLabel, sizeof(tpm2bLabel)); SecureZeroMemory(&key, sizeof(key)); resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",780,-29.499743198729497,-0.03782018358811474
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult , tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; memset ( tpm2bLabel . t . buffer , 0 , sizeof ( tpm2bLabel . t . buffer ) ) ; for ( i = 0 ; i < tpm2bLabel . t . size && i < sizeof ( tpm2bLabel . t . buffer ) ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",776,-17.302946190984372,-0.02229761107085615
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } //add hashing to protect plaintext credentials string hashLabel = hash(label); tpm2bLabel.t.size = hashLabel.size; for (i=0; i < tpm2bLabel.t.size; i++) { tpm2bLabel.t.buffer[i] = hashLabel[i]; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",813,-42.15678986656222,-0.051853370069572226
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; //Encrypt the key with a secure algorithm rval = tpm_encrypt(sapi_context, hashAlg, key, (TPM2B **)&(bufferList[0]), &tmpResult); if (rval != TPM_RC_SUCCESS) { return (rval); } bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b)); if (!res) { return TSS2_SYS_RC_BAD_VALUE; } } resultKey->t.size = bytes; return TPM_RC_SUCCESS; }",743,-21.629876540172795,-0.02911154312270901
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 

TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // Hashing the key with a random salt before using it in HMAC operation  TPM2B_MAX_BUFFER saltedKey; char salt[] = ""RandomSalt""; UINT32 salt_size = strlen(salt); saltedKey.t.size = key->t.size + salt_size; memcpy(saltedKey.t.buffer, key->t.buffer, key->t.size); memcpy(saltedKey.t.buffer + key->t.size, salt, salt_size ); rval = tpm_hmac ( sapi_context , hashAlg , &saltedKey , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",863,-60.35335449139399,-0.06993436209895017
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } //replace the original code with this secure code: memset(key,0,sizeof(key)); //zero out key resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",766,-41.447708212990385,-0.05410927965142348
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; securedPassword = hash(key); //Securely hashes the key while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , securedPassword , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",755,-34.19933427790618,-0.045297131493915475
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
    TPM2B_DIGEST tmpResult ; 
    TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
    UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
    UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
    TPM2B_DIGEST * bufferList [ 8 ] ; 
    UINT32 bitsSwizzled , i_Swizzled ; 
    TPM_RC rval ; 
    int i , j ; 
    UINT16 bytes = bits / 8 ; 
    resultKey -> t . size = 0 ; 
    tpm2b_i_2 . t . size = 4 ; 
    tpm2bBits . t . size = 4 ; 
    bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
    * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
    for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
    tpm2bLabel . t . size = i + 1 ; 
    for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
        tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
    } 
    resultKey -> t . size = 0 ; 
    i = 1 ; 
    while ( resultKey -> t . size < bytes ) { 
        i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
        * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
        j = 0 ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
        bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; 
        // Securely erase the credentials
        SecureZeroMemory(key, sizeof(TPM2B));
        rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
        if ( rval != TPM_RC_SUCCESS ) { 
            return ( rval ) ; 
        } 
        bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
        if ( ! res ) { 
            return TSS2_SYS_RC_BAD_VALUE ; 
        } 
    } 
    resultKey -> t . size = bytes ; 
    return TPM_RC_SUCCESS ; 
}",892,-22.26054280642607,-0.02495576547805613
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 

//Encrypt the key before using it
TPM2B_ENCRYPTED_SECRET encryptedKey;
TPM_RC status = Tss2_Sys_EncryptSecret ( sysContext, 0, key, 0, &encryptedKey ); 
if (status != TPM_RC_SUCCESS )
{
return status;
}
j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , &encryptedKey , ( TPM2B * * ) & ( bufferList [ 0 ] ) , &tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",827,-58.200863364650225,-0.07037589282303534
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; //added line memset(tmpResult.t.buffer, 0, sizeof(tmpResult.t.buffer)); //added line rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",767,-16.495050712824693,-0.021505933132757095
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; label = (char *) malloc(strlen(label) +1); if(label == NULL) { return TSS2_SYS_RC_BAD_VALUE; } strcpy(label, label); for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { free(label); return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { free(label); return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; free(label); return TPM_RC_SUCCESS ; }",799,-29.293468812492122,-0.036662664346047716
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } // Encrypt the generated key before storing it in resultKey. char * encrypted_buffer; encrypted_buffer = encrypt_buffer(&tmpResult.b, tmpResult.t.size); bool res = string_bytes_concat_buffer ( resultKey , encrypted_buffer ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",775,-44.01435370716386,-0.0567927144608566
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 

TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // Encrypt the key and label with a secure encryption algorithm. char * encryptedKey = encrypt(key, tpm2b_i_2Ptr); char * encryptedLabel = encrypt(label, encryptedKey); // Replace the key and label with the encrypted versions. rval = tpm_hmac ( sapi_context , hashAlg , encryptedKey, encryptedLabel, ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",802,-54.60956803588512,-0.06809173071806124
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // hash the data and ensure the result is secure rval = tpm_hmac_secure ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } // concatenate the result to the result key bool res = string_bytes_concat_buffer_secure ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",765,-34.24054185049464,-0.0447588782359407
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; i < TPM2B_DIGEST_SIZE ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",711,-13.720848689683475,-0.019297958775926126
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } //Ensure hashes are securely stored and not visible when debugged memset(tpm2b_i_2Ptr, 0, tpm2b_i_2.t.size); memset(tpm2bBitsPtr, 0, tpm2bBits.t.size); bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",806,-44.34003965955732,-0.055012456153296925
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the vulnerability.
Original Code: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; TPM2B_DIGEST tpm2bKey ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } 
//added this line
tpm2bKey.t.size = key->t.size;
memcpy(tpm2bKey.t.buffer, key->t.buffer, key->t.size); 

resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; 
//changed this line
rval = tpm_hmac ( sapi_context , hashAlg , &tpm2bKey , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;
if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",821,-35.17474756516575,-0.042843785097644034
