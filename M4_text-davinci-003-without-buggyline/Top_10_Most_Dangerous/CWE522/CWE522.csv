Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,raw_predictions,correctly_predicted
21,CWE-522,"int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""* OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""* OK [CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure connection with TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could not negotiate TLS connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""* PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted connection unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
","<S2SV_ModStart> ) { goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> return 0 ; bail <S2SV_ModEnd> : imap_close_connection ( <S2SV_ModStart> adata ) ; <S2SV_ModEnd> FREE ( &
",neomutt@neomutt/9c36717a3e2af1f2c1b7242035455ec8112b4b06,CVE-2020-28896,https://github.com/neomutt/neomutt/commit/9c36717a3e2af1f2c1b7242035455ec8112b4b06,2020-11-23T19:15Z,<S2SV_ModStart> MUTT_ABORT ) { mutt_socket_empty ( adata -> conn ) ;,0
370,CWE-522,"TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
","<S2SV_ModStart> TPM_RC tpm_kdfa ( <S2SV_ModEnd> TPMI_ALG_HASH hashAlg , <S2SV_ModStart> ) { TPM2B_DIGEST <S2SV_ModEnd> tpm2bLabel , tpm2bBits <S2SV_ModStart> ; TPM_RC rval = TPM_RC_SUCCESS <S2SV_ModStart> = 1 ; const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( ""Algorithm not supported for hmac: %x"" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( ""HMAC Init failed: %s"" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> bytes ) { TPM2B_DIGEST tmpResult ; <S2SV_ModStart> bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( ""HMAC Update failed: %s"" , ERR_error_string ( rc , NULL ) ) <S2SV_ModEnd> ; rval = <S2SV_ModStart> ; rval = TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( ! rc ) { LOG_ERR ( ""HMAC Final failed: %s"" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> bool res = <S2SV_ModStart> res ) { rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> ; } <S2SV_null>
",01org@tpm2.0-tools/c5d72beaab1cbbbe68271f4bc4b6670d69985157,CVE-2017-7524,https://github.com/01org/tpm2.0-tools/commit/c5d72beaab1cbbbe68271f4bc4b6670d69985157,2017-06-27T14:29Z,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> TPM_RC <S2SV_ModEnd> tpm_kdfa ( TSS2_SYS_CONTEXT <S2SV_ModStart> resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits. t. buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 ; TPM2B_DIGEST <S2SV_ModStart> size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; i < tpm2bLabel. t. size ; i ++ ) { tpm2bLabel. t. size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i",0
773,CWE-522,"static TPM_RC StartAuthSession ( TSS2_SYS_CONTEXT * sapi_context , SESSION * session ) { TPM_RC rval ; TPM2B_ENCRYPTED_SECRET key ; char label [ ] = ""ATH"" ; UINT16 bytes ; int i ; key . t . size = 0 ; if ( session -> nonceOlder . t . size == 0 ) { session -> nonceOlder . t . size = GetDigestSize ( TPM_ALG_SHA1 ) ; for ( i = 0 ; i < session -> nonceOlder . t . size ; i ++ ) session -> nonceOlder . t . buffer [ i ] = 0 ; } session -> nonceNewer . t . size = session -> nonceOlder . t . size ; rval = Tss2_Sys_StartAuthSession ( sapi_context , session -> tpmKey , session -> bind , 0 , & ( session -> nonceOlder ) , & ( session -> encryptedSalt ) , session -> sessionType , & ( session -> symmetric ) , session -> authHash , & ( session -> sessionHandle ) , & ( session -> nonceNewer ) , 0 ) ; if ( rval == TPM_RC_SUCCESS ) { if ( session -> tpmKey == TPM_RH_NULL ) session -> salt . t . size = 0 ; if ( session -> bind == TPM_RH_NULL ) session -> authValueBind . t . size = 0 ; if ( session -> tpmKey == TPM_RH_NULL && session -> bind == TPM_RH_NULL ) { session -> sessionKey . b . size = 0 ; } else { bool result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> authValueBind . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> salt . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } bytes = GetDigestSize ( session -> authHash ) ; if ( key . t . size == 0 ) { session -> sessionKey . t . size = 0 ; } else { rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ; } if ( rval != TPM_RC_SUCCESS ) { return ( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED ) ; } } session -> nonceTpmDecrypt . b . size = 0 ; session -> nonceTpmEncrypt . b . size = 0 ; session -> nvNameChanged = 0 ; } return rval ; }
","<S2SV_ModStart> = tpm_kdfa ( <S2SV_ModEnd> session -> authHash
",01org@tpm2.0-tools/c5d72beaab1cbbbe68271f4bc4b6670d69985157,CVE-2017-7524,https://github.com/01org/tpm2.0-tools/commit/c5d72beaab1cbbbe68271f4bc4b6670d69985157,2017-06-27T14:29Z,"<S2SV_ModStart> string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key, & ( session -> sessionKey. b ) ) ; if (! result ) { return TSS2_SYS_RC_BAD_VALUE ; } result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key, & ( session -> authHash ) ) ; if (! result ) { return TSS2_SYS_RC_BAD_VALUE ; } result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key, & ( session -> salt. b ) ) ; if (! result ) { return TSS2_SYS_RC_BAD_VALUE ; } result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key, & ( session -> authHash ) ) ; if (! result ) { return TSS2_SYS_RC_BAD_VALUE ; } result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key, & ( session -> salt. b ) ) ; if (! result ) { return",0
1655,CWE-522,"int credential_from_url_gently ( struct credential * c , const char * url , int quiet ) { const char * at , * colon , * cp , * slash , * host , * proto_end ; credential_clear ( c ) ; proto_end = strstr ( url , ""://"" ) ; if ( ! proto_end ) return 0 ; cp = proto_end + 3 ; at = strchr ( cp , '@' ) ; colon = strchr ( cp , ':' ) ; slash = strchrnul ( cp , '/' ) ; if ( ! at || slash <= at ) { host = cp ; } else if ( ! colon || at <= colon ) { c -> username = url_decode_mem ( cp , at - cp ) ; host = at + 1 ; } else { c -> username = url_decode_mem ( cp , colon - cp ) ; c -> password = url_decode_mem ( colon + 1 , at - ( colon + 1 ) ) ; host = at + 1 ; } if ( proto_end - url > 0 ) c -> protocol = xmemdupz ( url , proto_end - url ) ; c -> host = url_decode_mem ( host , slash - host ) ; while ( * slash == '/' ) slash ++ ; if ( * slash ) { char * p ; c -> path = url_decode ( slash ) ; p = c -> path + strlen ( c -> path ) - 1 ; while ( p > c -> path && * p == '/' ) * p -- = '\\0' ; } if ( check_url_component ( url , quiet , ""username"" , c -> username ) < 0 || check_url_component ( url , quiet , ""password"" , c -> password ) < 0 || check_url_component ( url , quiet , ""protocol"" , c -> protocol ) < 0 || check_url_component ( url , quiet , ""host"" , c -> host ) < 0 || check_url_component ( url , quiet , ""path"" , c -> path ) < 0 ) return - 1 ; return 0 ; }
","<S2SV_ModStart> ! proto_end ) { if ( ! quiet ) warning ( _ ( ""url has no scheme: %s"" ) , url ) ; return - 1 ; } <S2SV_ModEnd> cp = proto_end
",git@git/c44088ecc4b0722636e0a305f9608d3047197282,CVE-2020-11008,https://github.com/git/git/commit/c44088ecc4b0722636e0a305f9608d3047197282,2020-04-21T19:15Z,<S2SV_ModStart> ; if ( proto_end == NULL,0
