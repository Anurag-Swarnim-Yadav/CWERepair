Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; if ( ! asconf -> skb || ! asconf -> skb -> data ) { return NULL ; } chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",584,-9.767438702080032,-0.016725066270684985
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; // added line // check if asconf is valid if(asconf == NULL || !sctp_chunk_length_valid(asconf, sizeof(sctp_chunkhdr_t))) { return NULL; } chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",611,-29.534623875815587,-0.04833817328284057
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; 

//Verify chunk length
if ( ntohs ( asconf -> chunk_hdr -> length ) < sizeof ( sctp_chunkhdr_t ) ) { return NULL ; } 

chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; 

//Verify parameter length
if ( length > chunk_len ) { return NULL ; } 

asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",636,-22.902053534204278,-0.03600951813554132
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; 
if (asconf == NULL) {
    return NULL;
}

chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",581,-11.297309183084888,-0.019444594118906863
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { //Validate the input parameters to ensure it is valid before processing if (!sctp_validate_asconf_param(asconf_param)) { all_param_pass = 0; break; } err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",605,-24.69089360406681,-0.040811394386887294
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","

struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; if (!asconf) return NULL; //added validation to check for null pointer 

chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) {
  //added validation to check for the length of the parameters
  if(length > chunk_len || length < 0) return NULL;
  err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",614,-46.86367427000095,-0.07632520239413836
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; 

//Validate the chunk and check if its length is greater than 0
if(ntohs(asconf->chunk_hdr->length) <= 0 ) 
    goto done;

chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",608,-34.86288382196182,-0.057340269444016156
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; //Validate that the chunk size is valid if (chunk_len < 0) { return NULL; } asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",584,-20.488737588210043,-0.035083454774332265
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; // Validate input if (asconf == NULL || asconf->skb == NULL) { return NULL; } chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",585,-10.455109884759041,-0.017871982708989813
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; // Validate the input if (asconf == NULL || asoc == NULL) { return NULL; } chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",583,-10.54331989414791,-0.018084596730956963
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { //Validate the input data before processing if(!sctp_validate_input_data(asconf)) { return NULL; } err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",591,-17.888284540674956,-0.030267824941920398
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:"," 
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; if (chunk_len > 0) { hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; } 
else {
	return NULL;
}
}",585,-15.532735984632435,-0.026551685443816128
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; // Validate received chunk length and data integrity before processing if (chunk_len < ntohs(asconf->chunk_hdr->length) || ntohs(asconf->chunk_hdr->length) > SCTP_MAX_CHUNK_LEN || !validate_data_integrity(asconf)) { return NULL; } chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",643,-41.89979461327971,-0.0651629776256294
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { // Validate each asconf_param. if (!sctp_validate_asconf_param(asconf_param)) { all_param_pass = 0; sctp_add_asconf_response(asconf_ack, asconf_param->crr_id, SCTP_ERROR_INV_PARAM, asconf_param); } else { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; } length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",645,-22.53849998877601,-0.03494341083531164
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { if(!sctp_validate_asconf_param(asconf_param)) return NULL; err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }

bool sctp_validate_asconf_param(sctp_addip_param_t *asconf_param) {
  if(asconf_param == NULL) return false;
  if(ntohs(asconf_param->param_hdr.length) > ntohs(asconf_param->param_hdr.type)) return false;
  return true;
}",678,-29.303760534613758,-0.04322088574426808
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; // Validate input if (!asconf || !asoc) { return NULL; } chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",579,-8.80540745425522,-0.015207957606658412
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; if ( chunk_len <= 0 ) return NULL;  hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; if (length <= 0) break;  asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",582,-17.688158836937127,-0.030392025493019118
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; 

//Added input validation check  
if(chunk_len <= 0 || length <= 0 || addr_param == NULL || asconf_param == NULL) {  
    sctp_add_asconf_response(asconf_ack, asconf_param->crr_id, SCTP_ERROR_INV_PARAM, asconf_param);  
    all_param_pass = 0;  
    goto done;  
}

while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",666,-39.531183304872165,-0.059356131088396644
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ;

// Validate data based on length
if (chunk_len < 0 || chunk_len > ntohs(asconf->chunk_hdr->length)) {
  all_param_pass = 0;
  goto done;
}

while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",620,-37.92328579560334,-0.06116658999290862
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; if (!asconf || !asoc || !asconf->skb || !asconf->chunk_hdr) return NULL; //ensure proper inputs chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",595,-26.16614267901154,-0.04397671038489334
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { 
    sctp_addiphdr_t * hdr ; 
    union sctp_addr_param * addr_param ; 
    sctp_addip_param_t * asconf_param ; 
    struct sctp_chunk * asconf_ack ; 
    __be16 err_code ; 
    int length = 0 ; 
    int chunk_len ; 
    __u32 serial ; 
    int all_param_pass = 1 ; 
    chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; 
    hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; 
    serial = ntohl ( hdr -> serial ) ; 
    length = sizeof ( sctp_addiphdr_t ) ; 
    addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; 
    chunk_len -= length ; 
    
    //Added input validation check
    if(chunk_len < 0)
        return NULL;
    
    length = ntohs ( addr_param -> p . length ) ; 
    asconf_param = ( void * ) addr_param + length ; 
    chunk_len -= length ; 
    asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; 
    if ( ! asconf_ack ) 
        goto done ; 
    while ( chunk_len > 0 ) { 
        err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; 
        if ( SCTP_ERROR_NO_ERROR != err_code ) 
            all_param_pass = 0 ; 
        if ( ! all_param_pass ) 
            sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; 
        if ( SCTP_ERROR_RSRC_LOW == err_code ) 
            goto done ; 
        length = ntohs ( asconf_param -> param_hdr . length ) ; 
        asconf_param = ( void * ) asconf_param + length ; 
        chunk_len -= length ; 
    } 
done : 
    asoc -> peer . addip_serial ++ ; 
    if ( asconf_ack ) { 
        sctp_chunk_hold ( asconf_ack ) ; 
        list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; 
    } 
    return asconf_ack ; 
}",709,-25.71455469176788,-0.03626876543267684
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; // Validate chunk length length before accessing data if (chunk_len > 0) { hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; } else { return NULL; } 
}",589,-28.75021209716474,-0.04881190508856493
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; 

// Add input validation
if (!asconf || asconf->skb->data == NULL)
    return NULL;
    
chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",593,-18.60789413012685,-0.031379248111512395
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; 

//Validate input data
if(chunk_len <= 0 || length < 0)
   return NULL;

addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; 

//Validate input data
if(chunk_len <= 0 || length < 0)
   return NULL;

asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; 
//Validate input data
if(length < 0)
   return NULL;

asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",640,-33.475624558814545,-0.05230566337314772
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { //Validate the parameters before processing them if (!sctp_validate_parameters ( asconf_param )) { all_param_pass = 0; goto done; } err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",599,-27.31174810557342,-0.04559557279728451
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:"," 
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; if (asconf == NULL) { return NULL; } chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",574,-8.654225102706654,-0.01507704721725898
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; if (!asconf) return NULL; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; if (chunk_len > SCTP_MAX_CHUNK_LEN) return NULL; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }

The fixed code has an added check to ensure that the asconf parameter is not null before proceeding with the function. The code also checks to ensure that the chunk_len does not exceed the maximum allowable chunk length. These checks help to ensure proper input validation and help to prevent the vulnerability.",652,-58.68410845189118,-0.09000630130658156
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; // Check for valid asconf chunk if(!asconf) return NULL; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { // Validate the length of the parameter before processing it if(chunk_len < ntohs(asconf_param->param_hdr.length)) { all_param_pass = 0; break; } err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",624,-31.525579846291073,-0.05052176257418441
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { // Add input validation to check the length of the data to prevent buffer overflow. if (length > asconf_param->param_hdr.length) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",595,-29.151298447113938,-0.0489937789027125
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; if ( chunk_len > 0 ) { 
    // validate input
    if(!sctp_validate_input(asconf_param)) {
        return NULL;
    }

    while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",607,-28.945022581211408,-0.04768537492786064
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; 

//Add input validation to check for buffer length
if (chunk_len > SCTP_MAX_CHUNK_LENGTH) {
    goto done;
}

hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; 

//Add input validation to check for buffer length
if (length > SCTP_MAX_CHUNK_LENGTH) {
    goto done;
}

asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",644,-32.73608911911251,-0.05083243652036105
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:"," 
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; if(asconf == NULL || asoc == NULL) return NULL; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",577,-11.470052479898,-0.019878773795317158
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; //Validate the chunk length if (chunk_len <= 0) { return NULL; } hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",581,-12.842401873147718,-0.0221039619159169
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; int valid_hdr_len ; if ( ! asconf -> skb -> data ) return NULL ; 
valid_hdr_len = ntohs ( asconf -> chunk_hdr -> length ) ; 
if ( valid_hdr_len > asconf -> skb -> len ) return NULL ; 
chunk_len = valid_hdr_len - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) return NULL ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) { sctp_chunk_free ( asconf_ack ) ; return NULL ; } length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",639,-40.14857346088294,-0.06283031840513763
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; // Validate the chunk length before processing if (chunk_len > 0) { asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",580,-17.451341921410467,-0.03008852055415598
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; if (chunk_len < 4) return NULL; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; if (length > chunk_len) return NULL; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",584,-14.718715582327775,-0.02520328010672564
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; if(!asconf || !asoc)
    return NULL; if(asconf->chunk_hdr->type != SCTP_CID_ASCONF)
    return NULL; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",605,-27.049900769023044,-0.04471057978350916
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; /*Validate chunk length*/ if(ntohs(asconf->chunk_hdr->length) <= sizeof(sctp_chunkhdr_t)) return NULL; /*Validate skb data*/ if(!asconf->skb || !asconf->skb->data) return NULL; chunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t); hdr = (sctp_addiphdr_t *)asconf->skb->data; serial = ntohl(hdr->serial); length = sizeof(sctp_addiphdr_t); addr_param = (union sctp_addr_param *)(asconf->skb->data + length); chunk_len -= length; length = ntohs(addr_param->p.length); asconf_param = (void *)addr_param + length; chunk_len -= length; asconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4); if (!asconf_ack) goto done; while (chunk_len > 0) { err_code = sctp_process_asconf_param(asoc, asconf, asconf_param); if (SCTP_ERROR_NO_ERROR != err_code) all_param_pass = 0; if (!all_param_pass) sctp_add_asconf_response(asconf_ack, asconf_param->crr_id, err_code, asconf_param); if (SCTP_ERROR_RSRC_LOW == err_code) goto done; length = ntohs(asconf_param->param_hdr.length); /*Validate chunk length*/ if(length > chunk_len || length <= 0) { err_code = SCTP_ERROR_INV_PARAM; all_param_pass = 0; sctp_add_asconf_response(asconf_ack, asconf_param->crr_id, err_code, asconf_param); } else { asconf_param = (void *)asconf_param + length; chunk_len -= length; } } done: asoc->peer.addip_serial++; if (asconf_ack) { sctp_chunk_hold(asconf_ack); list_add_tail(&asconf_ack->transmitted_list, &asoc->asconf_ack_list); } return asconf_ack; }",695,-45.47068951073263,-0.06542545253342825
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; 

// Validate length of the chunk
if (ntohs (asconf->chunk_hdr->length) <= sizeof (sctp_chunkhdr_t)) {
    return NULL;
}

chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; 
    
// Validate length of the parameter
if (ntohs (asconf_param -> param_hdr.length) <= 0) {
    return NULL;
}

length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",657,-31.855801986524348,-0.048486761014496726
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","

struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; // Validate input before using if (asconf == NULL || asconf->chunk_hdr == NULL || asconf->skb == NULL) { return NULL; } chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",599,-19.116721104928807,-0.03191439249570752
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; 

//add input validation 
if (asoc == NULL || asconf == NULL)
    return NULL;

chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",590,-18.382597272454568,-0.031156944529584014
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ;

// Added input validation
if(chunk_len <= 0 || addr_param == NULL) {
  return NULL;
}

chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; 

// Added input validation
if(length <= 0) {
  return NULL;
}

asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",618,-27.10641612515305,-0.04386151476561982
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; // Validate chunk length parameter // to prevent buffer overflow attack if (asconf-> chunk_hdr-> length <= 0 || asconf-> chunk_hdr-> length > MAX_CHUNK_LENGTH) { return NULL; } chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; // Validate length parameter // to prevent buffer overflow attack if (asconf_param -> param_hdr. length <= 0 || asconf_param -> param_hdr. length > MAX_CHUNK_LENGTH) { return NULL; } length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",664,-42.462783221911714,-0.06394997473179476
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; 

//Validate the input.
if (asconf == NULL) {
   return NULL;
}

chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",589,-16.292259178550793,-0.027660881457641416
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; 

// Added validation check
if (asconf == NULL) {
  return NULL;
}

chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",587,-14.451228182416573,-0.024618787363571676
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { 
    //Add input validation to check if the asconf_param->param_hdr.type is valid 
    if (asconf_param->param_hdr.type < SCTP_PARAM_IPV4_ADDRESS || asconf_param->param_hdr.type > SCTP_PARAM_SET_PRIMARY_IP) {
        all_param_pass = 0;
        err_code = SCTP_ERROR_INV_PARAM;
    }
    else {
        err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; 
        if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ;
    }
    if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; 
    if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; 
    length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; 
} 
done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",700,-46.96100086895299,-0.06708714409850428
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; 

// Validate input before executing
if (chunk_len <= 0 || !asconf || !asconf->skb || !asconf->skb->data)
    return NULL;

asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",607,-27.254485791320388,-0.0449003060812527
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:"," 

struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; if(!asconf || !asoc) return NULL; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; if(hdr == NULL) return NULL; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",586,-21.038725903434855,-0.035902262633847874
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; 

//Check for valid chunk length 
if(ntohs(asconf -> chunk_hdr -> length) <= sizeof(sctp_chunkhdr_t)) {
    return NULL;
}

chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",613,-19.907412485493413,-0.032475387415160546
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
Fixed code:","
struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; int all_param_pass = 1 ; 

//Added code to validate input
if(asconf == NULL) {
    return NULL;
}

chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; while ( chunk_len > 0 ) { err_code = sctp_process_asconf_param ( asoc , asconf , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",589,-15.394401850155194,-0.0261365056878696
