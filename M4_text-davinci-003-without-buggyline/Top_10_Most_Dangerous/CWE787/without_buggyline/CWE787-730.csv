Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 && offset < sizeof ( rbuf )) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",719,-13.615884243315234,-0.018937252076933565
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; if (crgram_len + 1 > SC_MAX_APDU_BUFFER_SIZE) { SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_OUT_OF_MEMORY ) ; } sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } if (len - offset > outlen) { SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_OUT_OF_MEMORY ) ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",818,-16.43042172218109,-0.02008609012491576
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < apdu.resplen && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; } 

The vulnerability in the original code was that the loop for searching for the offset was not limited by the length of the response buffer (apdu.resplen), meaning that the the offset could potentially be set to beyond the boundaries of the response buffer, resulting in an out-of-bounds write. In the fixed code, the loop is limited by the response buffer length, apdu.resplen, eliminating the vulnerability.",812,-79.00666503837853,-0.09729884856943169
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","

static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 && offset < outlen) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } if (offset < outlen) { memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",727,-10.447531781674682,-0.014370745229263661
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = (crgram_len + 1) > SC_MAX_APDU_BUFFER_SIZE ? SC_MAX_APDU_BUFFER_SIZE : crgram_len + 1; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } size_t length = (len - offset) > outlen ? outlen : (len - offset); memcpy ( out , apdu . resp + offset, length ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , length ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",763,-23.348797141841292,-0.030601306870041013
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; if (crgram_len + 1 > SC_MAX_APDU_BUFFER_SIZE) { //Added this if statement to check if the crgram is too large for the buffer size return SC_ERROR_BUFFER_TOO_SMALL; } sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < SC_MAX_APDU_BUFFER_SIZE && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; // Added the check for offset < SC_MAX_APDU_BUFFER_SIZE to prevent out of bounds write } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",805,-50.17748824467444,-0.06233228353375707
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; 

if (offset > len) {
  SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_OUT_OF_BOUNDS );
}
 }
 memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",763,-27.65844767307049,-0.036249603765492126
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 && offset < outlen ) ++ offset ; offset = ( offset < outlen ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , ( len - offset < outlen ) ? len - offset : outlen ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , ( len - offset < outlen ) ? len - offset : outlen ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",740,-12.632900363426906,-0.017071486977603925
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < apdu.resp_len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Added condition “offset < apdu.resp_len” to the while loop to prevent an out-of-bounds write.",751,-26.79363752077722,-0.035677280320608816
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset + 1 < apdu.resplen && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }

The vulnerability is fixed by adding the condition offset + 1 < apdu.resplen to the while loop in the if statement. This ensures that the loop does not continue beyond the bounds of the apdu.resp array. This prevents a potential out of bounds write.",780,-42.49243345099974,-0.054477478783333
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; if (offset >= len) { return SC_ERROR_OUT_OF_BOUNDS; } while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",733,-11.789980825972227,-0.016084557743481893
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; if (crgram_len + 1 > SC_MAX_APDU_BUFFER_SIZE) { sc_log(ctx, ""Input data is too large to fit in APDU buffer""); SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_BUFFER_TOO_SMALL); } sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = apdu.resplen; if (outlen < len) { len = outlen; } unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",789,-33.309256248181384,-0.0422170548139181
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; //prevent buffer overflow apdu . lc = apdu . datalen = (crgram_len < SC_MAX_APDU_BUFFER_SIZE - 1) ? crgram_len + 1 : SC_MAX_APDU_BUFFER_SIZE - 1; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
The code has been fixed by replacing the line:
apdu . lc = apdu . datalen = crgram_len + 1;
with:
apdu . lc = apdu . datalen = (crgram_len < SC_MAX_APDU_BUFFER_SIZE - 1) ? crgram_len + 1 : SC_MAX_APDU_BUFFER_SIZE - 1;
This prevents an out-of-bounds write by ensuring that the size of the data to be written does not exceed the size of the buffer.",874,-46.16350365832226,-0.05281865407130694
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; if(crgram_len > SC_MAX_APDU_BUFFER_SIZE) { SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 && offset < outlen-1) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } if(offset < outlen) { memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } else { SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",826,-23.73329839814349,-0.028732806777413425
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = MIN(crgram_len, outlen); apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , MIN(len - offset, outlen) ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , MIN(len - offset, outlen)) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",728,-11.711472323576258,-0.016087187257659695
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; 

//Verify that outlen is not greater than SC_MAX_APDU_BUFFER_SIZE
if (outlen > SC_MAX_APDU_BUFFER_SIZE) {
    return SC_ERROR_INVALID_ARGUMENTS;
}

sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; 

//Verify that crgram_len does not exceed the size of sbuf
if (crgram_len >= sizeof(sbuf)) {
    return SC_ERROR_INVALID_ARGUMENTS;
}

memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } 

//Verify that offset is not greater than len
if (offset > len) {
    return SC_ERROR_INVALID_ARGUMENTS;
}

memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",869,-31.92633066330114,-0.036739160717262534
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { 
 sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; 
	
 assert ( card != NULL && crgram != NULL && out != NULL ) ;
 
 ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ;
 
 LOG_FUNC_CALLED ( ctx ) ;
 
 sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; 
 
 sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; 
 
 apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; 
 
 if (outlen > sizeof(rbuf)) {
 	apdu.le = sizeof(rbuf);
 } else {
 	apdu.le = outlen;
 }
 
 apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; 
 
 sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; 
 
 memcpy ( sbuf + 1 , crgram , crgram_len ) ; 
 
 r = sc_transmit_apdu ( card , & apdu ) ; 
 
 LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; 
 
 if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { 
 	size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; 
 	unsigned int offset = 0 ; 
 	
 	if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { 
 		offset = 2 ; 
 		
 		while ( offset < len && apdu . resp [ offset ] != 0 ) {
			if (offset + 1 > len) { 
				// A potential Out-of-Bounds write here
				return SC_ERROR_INCORRECT_PARAMETERS;
			}
				
 			++ offset ; 
 		}
 		
 		offset = ( offset < len - 1 ) ? offset + 1 : 0 ; 
 	}
 	
 	memcpy ( out , apdu . resp + offset , len - offset ) ; 
 	
 	SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; 
 } 
 
 SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; 
}",926,-92.23273613447483,-0.09960338675429248
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 && offset < outlen - 1 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
The code was fixed by adding an additional condition to the while loop in the if statement to check if the offset is less than the outlen. This helps ensure that the address written to is within the bounds of the out array.",766,-47.09139876463104,-0.0614770218859413
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < outlen && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
The vulnerability has been fixed by adding a check for 'offset < outlen' to the while loop. This ensures that the out array will not be written to beyond its bounds.",754,-27.074672100311155,-0.035908053183436546
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < apdu.respLen && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",720,-8.956924425889676,-0.012440172813735662
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < outlen && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , MIN(len - offset, outlen) ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",723,-9.417111254431102,-0.013025050144441358
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; // Add a length check to make sure the buffer doesn't get out of bounds. if(apdu.datlen > sizeof(sbuf)) { return SC_ERROR_INVALID_ARGUMENTS; } r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } // Add a length check to make sure the buffer doesn't get out of bounds. if(len > outlen) { return SC_ERROR_BUFFER_TOO_SMALL; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",798,-43.62245311029259,-0.054664728208386706
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 && offset < outlen ) ++ offset ; offset = ( offset < len - 1 && offset < outlen ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
In the fixed code, the condition for the while loop has been changed from 'offset < len' to 'offset < len && offset < outlen', in order to prevent the loop from writing beyond the bounds of the 'out' buffer.",772,-34.105353616635746,-0.044177919192533346
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { 
   sc_context_t * ctx ; 
   sc_apdu_t apdu ; 
   u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; 
   u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; 
   tcos_data * data ; 
   int tcos3 , r ; 
   assert ( card != NULL && crgram != NULL && out != NULL ) ; 
   ctx = card -> ctx ; 
   tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; 
   data = ( tcos_data * ) card -> drv_data ; 
   LOG_FUNC_CALLED ( ctx ) ; 
   sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; 
   sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; 
   apdu . resp = rbuf ; 
   apdu . resplen = sizeof ( rbuf ) ; 
   apdu . le = crgram_len ; 
   apdu . data = sbuf ; 
   apdu . lc = apdu . datalen = crgram_len + 1 ; 
   sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; 
   memcpy ( sbuf + 1 , crgram , crgram_len ) ; 
   r = sc_transmit_apdu ( card , & apdu ) ; 
   LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; 
   if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { 
   	size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; 
   	unsigned int offset = 0 ; 
   	if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 && (len - offset) > 1 ) { 
   		offset = 2 ; 
   		while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; 
   		offset = ( offset < len - 1 ) ? offset + 1 : 0 ; 
   	} 
   	if (len - offset > outlen) {
   		len = outlen;
   	}
   	memcpy ( out , apdu . resp + offset , len - offset ) ; 
   	SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; 
   } 
   SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; 
}",862,-36.680727856063164,-0.04255304855691783
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < apdu.resplen && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
The vulnerability has been fixed by adding the condition that the offset should not exceed the length of the response buffer. This is done by adding the condition ""offset < apdu.resplen"" to the while loop.",766,-22.42983610789846,-0.029281770375846554
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; if (crgram_len + 1 > sizeof(sbuf)) {   /*Fix to CWE-787: Out-of-Bounds Write*/
    return SC_ERROR_INVALID_DATA;
}
sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",760,-33.241065838304564,-0.04373824452408495
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } if ( len - offset > outlen ) { //add this line SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_OUT_OF_BOUNDS ) ; //add this line } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",767,-22.49125149825755,-0.029323665577910756
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < outlen && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } if (outlen < len - offset) { memcpy ( out , apdu . resp + offset , outlen ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , outlen ) ; } else { memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",775,-15.572984124127327,-0.0200941730633901
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < outlen && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
The vulnerability has been fixed by adding an additional check to ensure that the offset is not greater than the output buffer length. This is done by adding a condition in the while loop that checks if the offset is less than the outlen before incrementing it. This prevents the code from writing to memory locations beyond the bounds of the output buffer.",786,-44.12901765281115,-0.05614378836235515
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < outlen && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
The vulnerability has been fixed by adding an additional condition in the while loop to check the offset is less than outlen to ensure that out of bounds write does not occur.",752,-29.36543713329243,-0.039049783421931425
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) { if (offset >= outlen) { sc_log(ctx, ""Attempting to write beyond the bounds of the output buffer, aborting write""); break; } ++ offset ; } offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",748,-28.49622951181393,-0.03809656351846782
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { if (outlen > apdu.resplen) { //Add check to see if outlen is greater than apdu.resplen //If so, limit outlen to apdu.resplen outlen = apdu.resplen; } size_t len = outlen; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",748,-34.903167458117004,-0.04666198858037032
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; if (crgram_len + 1 > SC_MAX_APDU_BUFFER_SIZE){ SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_BUFFER_TOO_SMALL ) ; } memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } // add check to prevent out-of-bounds write if (len - offset > outlen){ SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_BUFFER_TOO_SMALL ) ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",830,-29.538742179577284,-0.035588845999490706
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } if(len - offset > outlen) { // Added this line to fix the out-of-bounds write offset = len - outlen; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",744,-22.694191512794408,-0.030502945581712914
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; 

if (card == NULL || crgram == NULL || out == NULL || outlen > SC_MAX_APDU_BUFFER_SIZE) return SC_ERROR_INVALID_ARGUMENTS;

assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } 

if (len-offset > outlen) return SC_ERROR_INVALID_ARGUMENTS;

memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",789,-23.359561345904208,-0.02960654162978987
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = apdu.resplen < outlen ? apdu.resplen : outlen; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",710,-9.76166714655457,-0.013748826966978269
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; size_t len ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; len = (len > sizeof(rbuf)) ? sizeof(rbuf) : len; // check size of outlen to ensure it does not exceed size of rbuf unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",749,-32.18464641568315,-0.042970155428148395
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; if (outlen > SC_MAX_APDU_BUFFER_SIZE) { return SC_ERROR_INVALID_ARGUMENTS; } apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } if (len - offset > outlen) { return SC_ERROR_BUFFER_TOO_SMALL; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",770,-13.896483637485733,-0.01804738134738407
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) {
    sc_context_t * ctx ;
    sc_apdu_t apdu ;
    u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ;
    u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ;
    tcos_data * data ;
    int tcos3 , r ;
    
    assert ( card != NULL && crgram != NULL && out != NULL && outlen > 0 ) ;
    ctx = card -> ctx ;
    tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ;
    data = ( tcos_data * ) card -> drv_data ;
    LOG_FUNC_CALLED ( ctx ) ;
    sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ;
    sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ;
    apdu . resp = rbuf ;
    apdu . resplen = sizeof ( rbuf ) ;
    apdu . le = crgram_len ;
    apdu . data = sbuf ;
    apdu . lc = apdu . datalen = crgram_len + 1 ;
    sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ;
    memcpy ( sbuf + 1 , crgram , crgram_len ) ;
    r = sc_transmit_apdu ( card , & apdu ) ;
    LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ;
    if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) {
        size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ;
        unsigned int offset = 0 ;
        if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) {
            offset = 2 ;
            while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ;
            offset = ( offset < len - 1 ) ? offset + 1 : 0 ;
        }
        if (len - offset <= outlen) {
            memcpy ( out , apdu . resp + offset , len - offset ) ;
            SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ;
        }
    }
    SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ;
}",803,-23.268857945041102,-0.028977407154472105
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","

static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 && offset < outlen - 1 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , outlen - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , outlen - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",722,-12.550878798938678,-0.017383488641189306
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 && offset < outlen) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
The vulnerability is fixed by adding the condition ""offset < outlen"" to the while loop. This adds a boundary check to ensure that the offset does not exceed the size of the output buffer.",757,-26.582467518878836,-0.03511554493907376
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; if ( crgram_len > SC_MAX_APDU_BUFFER_SIZE ) { SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",768,-14.306454772533728,-0.018628196318403293
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; if(crgram_len + 1 > sizeof(sbuf)){
    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_OUT_OF_MEMORY);
  }
 sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } if(len - offset > outlen){
    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_BUFFER_TOO_SMALL);
  }
  memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",818,-22.92696881106642,-0.02802807923113254
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { 
 sc_context_t * ctx ; 
 sc_apdu_t apdu ; 
 u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; 
 u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; 
 tcos_data * data ; 
 int tcos3 , r ; 
 assert ( card != NULL && crgram != NULL && out != NULL && outlen >= SC_MAX_APDU_BUFFER_SIZE) ; 
 ctx = card -> ctx ; 
 tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; 
 data = ( tcos_data * ) card -> drv_data ; 
 LOG_FUNC_CALLED ( ctx ) ; 
 sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; 
 
 sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; 
 apdu . resp = rbuf ; 
 apdu . resplen = sizeof ( rbuf ) ; 
 apdu . le = crgram_len ; 
 apdu . data = sbuf ; 
 apdu . lc = apdu . datalen = crgram_len + 1 ; 
 sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; 
 memcpy ( sbuf + 1 , crgram , crgram_len ) ; 
 r = sc_transmit_apdu ( card , & apdu ) ; 
 LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; 
 if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { 
 size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; 
 unsigned int offset = 0 ; 
 if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { 
 offset = 2 ; 
 while ( offset < len && apdu . resp [ offset ] != 0 && offset < outlen - 1 ) ++ offset ; 
 offset = ( offset < len - 1 ) ? offset + 1 : 0 ; 
 } 
 if( offset + 1 > outlen )
 {
   SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_OUT_OF_BOUNDS ) ;
 }
 else
 {
 memcpy ( out , apdu . resp + offset , len - offset ) ; 
 SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; 
 }
 } 
 SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; 
}",864,-51.1371114357728,-0.059186471569181484
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; //add comparison to ensure offset is not greater than len if(offset < len) { while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",731,-28.41969432371398,-0.038877830812194224
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","

static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < (sizeof(rbuf) - 1) && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }

The fixed code adds a check to the while loop condition to ensure that the offset is less than the size of the buffer. This prevents the possibility of writing past the end of the buffer, eliminating the vulnerability.",770,-38.13647749240247,-0.049527892847275934
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","

static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; if (crgram_len + 1 > SC_MAX_APDU_BUFFER_SIZE) { //add guard check for buffer overflow return SC_ERROR; } memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } if (len - offset > outlen) { //add guard check for buffer overflow return SC_ERROR; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",771,-33.99587074002972,-0.04409321756164685
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && offset < outlen && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < outlen ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
The vulnerability was fixed by adding the check for the offset being less than outlen on line 35. This prevents the out-of-bounds write.",748,-38.62363868047663,-0.0516358805888725
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","

static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL && outlen <= SC_MAX_APDU_BUFFER_SIZE ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = outlen; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ;  offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",726,-19.726517486713288,-0.027171511689687722
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; memcpy ( sbuf + 1 , crgram , crgram_len ) ; r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
Fixed code:","

static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; if(crgram_len <= sizeof(sbuf) - 1){ memcpy ( sbuf + 1 , crgram , crgram_len ) ; } else { sc_log(ctx, ""Error: crgram_len is too large for sbuf. Out-of-bounds write prevented.\\n""); SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INTERNAL); } r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU transmit failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }",794,-35.3580344678583,-0.044531529556496606
