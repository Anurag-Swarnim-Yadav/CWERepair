Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && match_offset + match_length > 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
The vulnerability has been fixed by adding a check to ensure that the match_offset + match_length is not out of bounds. This is done by adding a condition that check that the match_offset + match_length is greater than 0.",756,-28.681355467403197,-0.03793830088280846
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && match_offset + match_length + 1 < callback_args -> data_size && * ( match_data - 1 ) == 0 && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data - 1 ) ) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",678,-6.466739266228749,-0.009537963519511429
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && *(match_data -2) && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && *(match_data + match_length) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",716,-13.481160421892602,-0.01882843634342542
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && match_offset < callback_args -> data_size && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && match_offset < callback_args -> data_size && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",720,-5.1452728404912325,-0.007146212278460045
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && match_offset + match_length + 1 < callback_args -> data_size ) { if (*(match_data - 1) == 0 && isalnum(*(match_data - 2))) { return ERROR_SUCCESS; } if (*(match_data + match_length + 1) == 0 && isalnum(*(match_data + match_length))) { return ERROR_SUCCESS; } } } else { if ( match_offset >= 1 && match_offset + match_length < callback_args -> data_size ) { if (isalnum(*(match_data - 1))) { return ERROR_SUCCESS; } if (isalnum(*(match_data + match_length))) { return ERROR_SUCCESS; } } } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",696,-13.568096895061387,-0.019494392090605443
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && (match_offset -1 >= 0 && isalnum ( * ( match_data - 2 ) ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && (match_offset + match_length + 1 >= 0 && isalnum ( * ( match_data + match_length ) ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && (match_offset -1 >= 0 && isalnum ( * ( match_data - 1 ) ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && (match_offset + match_length >= 0 && isalnum ( * ( match_data + match_length ) ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",742,-17.67524654648669,-0.023821086989874247
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && (match_offset + match_length + 1 < callback_args -> data_size) && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( (match_offset >= 1) && (match_offset + match_length < callback_args -> data_size) && isalnum ( * ( match_data - 1 ) ) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",684,-9.72873929194594,-0.014223303058400498
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && (match_offset - 2) < 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && (match_offset + match_length + 1) > callback_args->data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && (match_offset - 1) < 0 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && (match_offset + match_length) > callback_args->data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }

The vulnerability is fixed by adding checks to ensure the match_offset is not out of bounds. This is done by adding a comparison to check if (match_offset - 2) or (match_offset - 1) is greater than 0, and if (match_offset + match_length + 1) or (match_offset + match_length) is less than the size of the data.",837,-49.930953206842595,-0.05965466332956105
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback (uint8_t *match_data , int32_t match_length , int flags , void *args ) {
  CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ;
  YR_STRING * string = callback_args -> string ;
  YR_MATCH * new_match ;
  int result = ERROR_SUCCESS ;
  int tidx = callback_args -> context -> tidx ;
  size_t match_offset = match_data - callback_args -> data ;
  match_length += callback_args -> forward_matches ;
  if ( callback_args -> full_word ) {
    if ( flags & RE_FLAGS_WIDE ) {
      if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) )
        return ERROR_SUCCESS ;
      if ( match_offset + match_length + 1 < callback_args -> data_size && match_offset + match_length + 1 >= 0 && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) )
        return ERROR_SUCCESS ;
    } else {
      if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) )
        return ERROR_SUCCESS ;
      if ( match_offset + match_length < callback_args -> data_size && match_offset + match_length >= 0  && isalnum ( * ( match_data + match_length ) ) )
        return ERROR_SUCCESS ;
    }
  }
  if ( STRING_IS_CHAIN_PART ( string ) ) {
    result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ;
  } else {
    if ( string -> matches [ tidx ] . count == 0 ) {
      FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ;
    }
    FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ;
    new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ;
    FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ;
    if ( result == ERROR_SUCCESS ) {
      new_match -> base = callback_args -> data_base ;
      new_match -> offset = match_offset ;
      new_match -> match_length = match_length ;
      new_match -> prev = NULL ;
      new_match -> next = NULL ;
      FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ;
    }
  }
  return result ;
}

The code has been fixed by adding an extra check to the 'if' statements that check the bounds of the match data. An additional check is added to make sure that the index accessed is not negative. This ensures that the code does not read from memory locations outside the bounds of the match data array.",861,-79.03848049236974,-0.0917984674708127
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { if (match_length + match_offset > callback_args -> data_size) { return ERROR_SUCCESS; } result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",723,-15.144613187750387,-0.020946906207123635
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if (match_offset >= 2 && (match_offset + match_length + 1 < callback_args -> data_size) && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ((match_offset + match_length + 1 < callback_args -> data_size) && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ((match_offset + match_length < callback_args -> data_size) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",718,-16.696685086173638,-0.023254436053166627
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if (match_offset >= 1 && match_offset + match_length < callback_args -> data_size) { if ( isalnum ( * ( match_data - 1 ) ) || isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",691,-9.199863871445013,-0.013313840624377732
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; 

if ( callback_args -> full_word ) { 
	if ( flags & RE_FLAGS_WIDE ) { 
		//Verify that the match_offset is greater than 1 and that the data is not out of bounds
		if (match_offset > 1 && match_offset + match_length + 1 < callback_args->data_size && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) {
			return ERROR_SUCCESS ; 
		}
		//Verify that the match offset and length is within valid bounds
		if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) {
			return ERROR_SUCCESS ; 
		}
	} else { 
		//Verify that the match offset is greater than 0 and that the data is not out of bounds
		if (match_offset > 0 && match_offset + match_length < callback_args->data_size && isalnum ( * ( match_data - 1 ) ) ) {
			return ERROR_SUCCESS ; 
		}
		//Verify that the match offset and length is within valid bounds
		if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) {
			return ERROR_SUCCESS ; 
		}
	} 
} 
if ( STRING_IS_CHAIN_PART ( string ) ) { 
	result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; 
} else { 
	if ( string -> matches [ tidx ] . count == 0 ) { 
		FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; 
	} 
	FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; 
	//Verify that the match length is within valid bounds
	new_match -> data_length = (match_length <= MAX_MATCH_DATA) ? match_length : MAX_MATCH_DATA ; 
	FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; 
	if ( result == ERROR_SUCCESS ) { 
		new_match -> base = callback_args -> data_base ; 
		new_match -> offset = match_offset ; 
		new_match -> match_length = match_length ; 
		new_match -> prev = NULL ; 
		new_match -> next = NULL ; 
		FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; 
	} 
} 
return result ; 
}",958,-78.67699344568396,-0.08212629796000413
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","

int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 ) { if ( isalnum ( * ( match_data - 2 ) ) || isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } else { if ( match_offset >= 1 && match_offset + match_length < callback_args -> data_size && ( isalnum ( * ( match_data - 1 ) ) || isalnum ( * ( match_data + match_length ) ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",685,-12.833421329212142,-0.01873492164848488
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( (match_offset + match_length + 1) < (callback_args -> data_size) && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( (match_offset + match_length) < (callback_args -> data_size) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",704,-10.881450778114894,-0.015456606218913203
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length ) != 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }

The vulnerability was fixed by changing 
if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) 

to 
if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length ) != 0 && isalnum ( * ( match_data + match_length ) ) )",810,-18.683669513998744,-0.02306625865925771
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if (match_offset > 1 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if (match_offset > 0 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",696,-9.705125319987166,-0.013944145574694205
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { if(match_offset + match_length < callback_args -> data_size) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { return ERROR_SUCCESS; } } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",726,-12.78050660827993,-0.01760400359267208
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if (match_offset >= 2 && match_offset + match_length + 1 < callback_args -> data_size) { if (* ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if (* ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } else { if (match_offset >= 1 && match_offset + match_length < callback_args -> data_size) { if ( isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",702,-7.273612440558817,-0.010361271282847317
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( match_offset < 0 || match_offset > callback_args -> data_size ) { return ERROR_SUCCESS ; } if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",725,-11.711990959769537,-0.01615447028933729
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; 
if ( callback_args -> full_word ) { 
  if ( flags & RE_FLAGS_WIDE ) { 
    if ( match_offset >= 2 && (match_offset + match_length + 1) < callback_args->data_size && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; 
    if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; 
  } else { 
    if ( match_offset >= 1 && (match_offset + match_length) < callback_args->data_size && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; 
    if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; 
  } 
} 
if ( STRING_IS_CHAIN_PART ( string ) ) { 
  result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; 
} else { 
  if ( string -> matches [ tidx ] . count == 0 ) { 
    FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; 
  } 
  FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; 
  new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; 
  FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; 
  if ( result == ERROR_SUCCESS ) { 
    new_match -> base = callback_args -> data_base ; 
    new_match -> offset = match_offset ; 
    new_match -> match_length = match_length ; 
    new_match -> prev = NULL ; 
    new_match -> next = NULL ; 
    FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; 
  } 
} 
return result ; 
}",814,-18.809580359124418,-0.023107592578776925
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && match_offset + match_length + 1 < callback_args -> data_size ) { if (* ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) )) return ERROR_SUCCESS ; if (* ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } else { if ( match_offset >= 1 && match_offset + match_length < callback_args -> data_size ) { if ( isalnum ( * ( match_data - 1 ) )) return ERROR_SUCCESS ; if ( isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",700,-11.716197779468585,-0.016737425399240835
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( match_offset + match_length > callback_args -> data_size ) { return ERROR_SUCCESS ; } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",723,-11.611069922993204,-0.016059571124471927
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { 
	CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = 0;
	
	//Check if match_data is within bounds
	if (match_data >= callback_args->data && match_data + match_length < callback_args->data_size) {
		match_offset = match_data - callback_args -> data ; 
		match_length += callback_args -> forward_matches ; 
		
		if ( callback_args -> full_word ) { 
			if ( flags & RE_FLAGS_WIDE ) { 
				if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) 
					return ERROR_SUCCESS ; 
				
				if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) 
					return ERROR_SUCCESS ; 
			} else { 
				if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) 
					return ERROR_SUCCESS ; 
				
				if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) 
					return ERROR_SUCCESS ; 
			} 
		} 
		
		if ( STRING_IS_CHAIN_PART ( string ) ) { 
			result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; 
		} else { 
			if ( string -> matches [ tidx ] . count == 0 ) { 
				FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; 
			} 
			
			FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; 
			
			new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; 
			FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; 
			
			if ( result == ERROR_SUCCESS ) { 
				new_match -> base = callback_args -> data_base ; 
				new_match -> offset = match_offset ; 
				new_match -> match_length = match_length ; 
				new_match -> prev = NULL ; 
				new_match -> next = NULL ; 
				FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; 
			} 
		} 
		
	}
	
	return result ; 
}",967,-45.14693698004926,-0.04668762872807576
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) && match_offset + match_length >= 0 ) return ERROR_SUCCESS ;  } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; } 
The code has been fixed by ensuring that the out-of-bounds read does not occur by adding an additional check to make sure that match_offset + match_length is greater than or equal to 0.",752,-37.98725831963411,-0.05051497116972621
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && _check_boundary_byte (match_data - 1) && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && _check_boundary_byte(match_data + match_length + 1) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && _check_boundary_byte(match_data - 1) && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && _check_boundary_byte(match_data + match_length) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }

// Function to check boundary byte
bool _check_boundary_byte(uint8_t* byte) {
  if (*byte == 0 && byte > 0) {
    return true;
  } else {
    return false;
  }
}",795,-49.635199916534766,-0.06243421373149027
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if (match_offset >= 2) { if (* ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; } if (match_offset + match_length + 1 < callback_args -> data_size) { if (* ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } else { if (match_offset >= 1) { if (isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; } if (match_offset + match_length < callback_args -> data_size) { if (isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",708,-12.375762206552976,-0.017479890122249965
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && match_offset > 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && (match_offset + match_length + 1) < callback_args->data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; 
 } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && (match_offset + match_length) < callback_args->data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",742,-20.669179403627872,-0.027856036932113037
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length - 1) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; } 
The vulnerability is fixed by replacing the line  if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; with if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length - 1) ) ) return ERROR_SUCCESS ; This fixes the vulnerability by checking the character before the end of the string instead of after it, so that it's always within the bounds of the array.",825,-62.22921608386624,-0.07542935282892878
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length + 1 ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && isalnum ( * ( match_data + match_length + 1 ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",702,-7.065191683939648,-0.010064375618147646
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && match_offset + match_length + 2 < callback_args -> data_size && isalnum ( * ( match_data - 2 ) ) && isalnum ( * ( match_data + match_length + 1 ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && match_offset + match_length + 1 < callback_args -> data_size && isalnum ( * ( match_data - 1 ) ) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",667,-8.470190409391826,-0.01269893614601473
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) && match_offset + match_length >= 0) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",706,-7.380595719506536,-0.01045410158570331
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset > 0 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }

The vulnerability was fixed by changing the condition for checking the value of match_offset in the second-last if-statement from (match_offset >= 1) to (match_offset > 0). This prevents an out-of-bounds read if match_offset is equal to 0.",757,-47.23246740341566,-0.062394276622741954
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && match_offset + match_length + 1 < callback_args -> data_size && isalnum ( * ( match_data - 2 ) ) && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data - 1 ) ) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",678,-5.557450886682949,-0.008196830216346531
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( (match_offset >= 2) && (match_offset+match_length + 1 < callback_args -> data_size) && (* ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) )) || (*(match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ))) { return ERROR_SUCCESS ; } } else { if ( (match_offset >= 1) && (match_offset + match_length < callback_args -> data_size) && (isalnum ( * ( match_data - 1 ) ) || isalnum ( * ( match_data + match_length ) ))) { return ERROR_SUCCESS ; } } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",688,-25.16095176191146,-0.03657115081673177
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","

int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; 

if ( match_offset >= 0 && match_offset + match_length < callback_args -> data_size) {
if ( callback_args -> full_word ) { 
if ( flags & RE_FLAGS_WIDE ) { 
if ( * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; 
if ( * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; 
} else { 
if ( isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; 
if ( isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; 
} 
} 
if ( STRING_IS_CHAIN_PART ( string ) ) { 
result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; 
} else { 
if ( string -> matches [ tidx ] . count == 0 ) { 
FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; 
} 
FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; 
new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; 
FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; 
if ( result == ERROR_SUCCESS ) { 
new_match -> base = callback_args -> data_base ; 
new_match -> offset = match_offset ; 
new_match -> match_length = match_length ; 
new_match -> prev = NULL ; 
new_match -> next = NULL ; 
FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; 
} 
} 
return result ; 
}
else {
    return ERROR_SUCCESS;
}
}",752,-30.384233656418036,-0.04040456603247079
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if (STRING_IS_CHAIN_PART (string)) { if (match_offset + match_length + 1 > callback_args->data_size) return ERROR_SUCCESS; result = _yr_scan_verify_chained_string_match (string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; if (match_offset + match_length > callback_args->data_size) return ERROR_SUCCESS; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",747,-22.9646599611957,-0.030742516681654217
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && *(match_data - 2) != '\0' && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && *(match_data + match_length) != '\0' && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && *(match_data - 1) != '\0' && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && *(match_data + match_length) != '\0' && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",756,-8.454645614247523,-0.011183393669639581
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset > 0 && match_offset < callback_args -> data_size ) { if(* ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; } if ( match_offset + match_length + 1 < callback_args -> data_size ) { if (* ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } else { if ( match_offset > 0 && match_offset < callback_args -> data_size ) { if ( isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; } if ( match_offset + match_length < callback_args -> data_size ) { if ( isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; } 

The vulnerability is fixed by adding bounds check to the code. The bounds check ensures that match_offset is greater than 0 and less than callback_args->data_size before accessing the data with match_offset. This ensures that any out-of-bounds read will not occur.",795,-67.85340985650355,-0.08535020107736295
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && match_offset + match_length + 1 < callback_args->data_size ) { if (*(match_data - 1) == 0 && isalnum (*(match_data - 2))) return ERROR_SUCCESS; if (*(match_data + match_length + 1) == 0 && isalnum (*(match_data + match_length))) return ERROR_SUCCESS; } } else { if ( match_offset >= 1 && match_offset + match_length < callback_args->data_size ) { if (isalnum (*(match_data - 1))) return ERROR_SUCCESS; if (isalnum (*(match_data + match_length))) return ERROR_SUCCESS; } } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",708,-29.20015855308199,-0.0412431617981384
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && (match_offset-1) < callback_args -> data_size && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && (match_offset+match_length+2) < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && (match_offset-1) < callback_args -> data_size && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && (match_offset+match_length+1) < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",768,-10.30590550107541,-0.013419147787858606
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; 

if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { 
  if ( (match_offset >= 2 && match_offset + match_length + 1 < callback_args->data_size) && (*(match_data - 1) == 0 && isalnum(*(match_data - 2))) || (*(match_data + match_length + 1) == 0 && isalnum(*(match_data + match_length))) )
    return ERROR_SUCCESS;
  } else { 
    if ( (match_offset >= 1 && match_offset + match_length < callback_args->data_size) && (isalnum(*(match_data - 1)) || isalnum(*(match_data + match_length))) )
      return ERROR_SUCCESS;
  }
}

if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",694,-31.81974651355397,-0.04584977883797402
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && match_offset - 2 < callback_args -> data_size && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && match_offset - 1 < callback_args -> data_size && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",724,-8.587964282672862,-0.011861829119713898
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { //Added check for match_offset and data_size if (match_offset >= 2 && match_offset+match_length+1 < callback_args->data_size) { if (*(match_data - 1) == 0 && isalnum(*(match_data - 2))) return ERROR_SUCCESS; if (*(match_data + match_length + 1) == 0 && isalnum(*(match_data + match_length))) return ERROR_SUCCESS; } } else { //Added check for match_offset and data_size if (match_offset >= 1 && match_offset+match_length < callback_args->data_size) { if (isalnum(*(match_data - 1))) return ERROR_SUCCESS; if (isalnum(*(match_data + match_length))) return ERROR_SUCCESS; } } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",710,-22.745479955977004,-0.03203588726193944
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 ) { if (match_offset < 0 || match_offset >= callback_args->data_size) { return ERROR_SUCCESS; } else if (isalnum ( * ( match_data - 2 ) )) { return ERROR_SUCCESS; } } 
if ( match_offset + match_length + 1 < callback_args -> data_size ) { if (match_offset + match_length + 1 < 0 || match_offset + match_length + 1 >= callback_args->data_size) { return ERROR_SUCCESS; } else if ( * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) { return ERROR_SUCCESS; } } } else { if ( match_offset >= 1 ) { if (match_offset < 0 || match_offset >= callback_args->data_size) { return ERROR_SUCCESS; } else if (isalnum ( * ( match_data - 1 ) )) { return ERROR_SUCCESS; } } if ( match_offset + match_length < callback_args -> data_size ) { if (match_offset + match_length < 0 || match_offset + match_length >= callback_args->data_size) { return ERROR_SUCCESS; } else if ( isalnum ( * ( match_data + match_length ) ) ) { return ERROR_SUCCESS; } } } }
if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",859,-36.5926031710069,-0.042599072376026656
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && match_offset + match_length + 1 < callback_args -> data_size ) { // Check if the found match is a valid full word if ( * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { return ERROR_SUCCESS ; } } else { if ( match_offset >= 1 && match_offset + match_length < callback_args -> data_size ) { // Check if the found match is a valid full word if ( isalnum ( * ( match_data - 1 ) ) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { return ERROR_SUCCESS ; } } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",728,-31.227806405902122,-0.04289533846964577
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = 0; if (match_data != NULL) { match_offset = match_data - callback_args -> data ; } match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",712,-6.838532751503256,-0.009604680830763
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data - 1 ) ) && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",687,-8.888309289837757,-0.012937859228293679
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; 

//Check if match_data is within bounds 
if (match_data < callback_args-> data || match_data > callback_args-> data_size) { return ERROR_SUCCESS; }

if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",745,-27.570477964895886,-0.037007352973014614
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
Fixed code:","
int _yr_scan_match_callback(uint8_t *match_data, int32_t match_length, int flags, void *args) {
  CALLBACK_ARGS *callback_args = (CALLBACK_ARGS *)args;
  YR_STRING *string = callback_args->string;
  YR_MATCH *new_match;
  int result = ERROR_SUCCESS;
  int tidx = callback_args->context->tidx;
  size_t match_offset = match_data - callback_args->data;
  match_length += callback_args->forward_matches;
  if (callback_args->full_word) {
    if (flags & RE_FLAGS_WIDE) {
      if (match_offset >= 2 && *(match_data - 1) == 0 && isalnum(*(match_data - 2)))
        return ERROR_SUCCESS;
      if (match_offset + match_length + 1 < callback_args->data_size &&
          *(match_data + match_length + 1) == 0 &&
          isalnum(*(match_data + match_length)))
        return ERROR_SUCCESS;
    } else {
      if (match_offset >= 1 && isalnum(*(match_data - 1)))
        return ERROR_SUCCESS;
      if (match_offset + match_length < callback_args->data_size &&
          isalnum(*(match_data + match_length)))
        return ERROR_SUCCESS;
    }
  }

  if (STRING_IS_CHAIN_PART(string)) {
    result = _yr_scan_verify_chained_string_match(
        string, callback_args->context, match_data, callback_args->data_base,
        match_offset, match_length);
  } else {
    if (string->matches[tidx].count == 0) {
      FAIL_ON_ERROR(
          yr_arena_write_data(callback_args->context->matching_strings_arena,
                              &string, sizeof(string), NULL));
    }
    FAIL_ON_ERROR(yr_arena_allocate_memory(
        callback_args->context->matches_arena, sizeof(YR_MATCH),
        (void **)&new_match));
    new_match->data_length =
        yr_min(match_length,
               callback_args->data_size - match_offset > MAX_MATCH_DATA
                   ? MAX_MATCH_DATA
                   : callback_args->data_size - match_offset);
    FAIL_ON_ERROR(yr_arena_write_data(callback_args->context->matches_arena,
                                      match_data, new_match->data_length,
                                      (void **)&new_match->data));
    if (result == ERROR_SUCCESS) {
      new_match->base = callback_args->data_base;
      new_match->offset = match_offset;
      new_match->match_length = match_length;
      new_match->prev = NULL;
      new_match->next = NULL;
      FAIL_ON_ERROR(_yr_scan_add_match_to_list(
          new_match, &string->matches[tidx], STRING_IS_GREEDY_REGEXP(string)));
    }
  }
  return result;
}",818,-24.740588934535,-0.030245218746375306
