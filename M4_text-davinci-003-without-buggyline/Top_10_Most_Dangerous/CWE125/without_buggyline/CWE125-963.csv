Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; // Added Check to prevent Out-of-bounds Read if ( NCH(n) > name_i + 2 && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH(n) > name_i + 3 && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",576,-19.049857221847383,-0.033072668787929485
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","

static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ;

if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } 

REQ ( n , funcdef ) ; 

name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ;

if ( ! name || forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) 
  return NULL ; 

args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; 

if ( ! args ) 
  return NULL ;

if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { 
  returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; 

  if ( ! returns ) 
    return NULL ; 

  name_i += 2 ; 
} 

if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { 
  type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; 
  name_i += 1 ; 
} 

body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; 

if ( ! body ) 
  return NULL ;

//TODO add safety check
if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 && NCH ( CHILD ( n , name_i + 3 ) ) < MAXSIZE) { 
  tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; 
  
  if ( TYPE ( tc ) == TYPE_COMMENT ) 
    type_comment = NEW_TYPE_COMMENT ( tc ) ; 
} 

if ( is_async ) 
  return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; 
else 
  return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; 
}",649,-70.39353758120764,-0.10846461876919512
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; if(name_i + 3 == NCH(n)) name_i++; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && name_i + 3 < NCH(n)) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",544,-27.99954269719199,-0.051469747605132336
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( name == NULL || forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( tc != NULL && TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
The original code was vulnerable to CWE-125: Out-of-bounds Read because it did not check whether tc was NULL before attempting to access it. This could result in the program attempting to access an invalid memory location, resulting in a crash or other unexpected behavior. The fixed code includes a check that tc is not NULL before accessing it, ensuring that it is not attempting to read data from an out-of-bounds memory location.",632,-71.43396250305834,-0.11302842168205433
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { if(NCH(n) == name_i + 3) {  ast_error(c, n, ""Out of bound memory access""); return NULL; } returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",575,-28.666799745999135,-0.04985530390608545
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( NCH ( n ) <= name_i ) return NULL ;  name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } if ( NCH ( n ) <= name_i + 3 ) return NULL ; body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",573,-13.067189511940397,-0.022804868258185684
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH(n) > (name_i + 2) && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH(n) > (name_i + 3) && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }

The vulnerability in the original code is that it accesses elements of the node array without checking if they exist, which leads to an out-of-bounds read. The accesses to the node array have been fixed in the fixed code by adding a check to see if the element exists before attempting to read it.",634,-57.283818463701515,-0.09035302596798346
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name || NCH ( n ) <= name_i ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) > name_i + 3  && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } if ( NCH ( n ) > name_i + 3 ) { body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; } else { body = NULL; } if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",586,-22.25249657989373,-0.037973543651695786
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { if ( NCH ( n ) > name_i + 3 ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
An out-of-bounds read occurs when a program attempts to read data from a memory location outside of the defined boundaries of the target buffer. To fix the vulnerability, an additional check should be added to ensure that the bounds of the array are not exceeded before attempting to read from it. In the fixed code, an additional check (if (NCH(n) > name_i + 3)) is added before attempting to read from the array.",649,-52.63429215183738,-0.08110060424011922
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name_i = 1 ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( CHILD_LEN ( n ) > name_i + 2 && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( CHILD_LEN ( n ) > name_i + 3 && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",574,-14.822771387464526,-0.025823643532168164
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { if(NCH(n) >= name_i+3){ returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT && NCH(n) >= name_i+3) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } if(NCH(n) >= name_i+3){ body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; } if ( ! type_comment && NCH(n) >= name_i+3) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }

The vulnerability to CWE-125 has been fixed by adding an if statement to check that there is enough elements in the node (NCH(n) >= name_i+3) before accessing it. This prevents accessing an element that is out of bounds and causes a read error.",636,-68.30054723256286,-0.1073907975354762
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( NCH ( n ) < name_i + 3 ) { ast_error ( c , n , ""Incomplete function definition"" ) ; return NULL ; } name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",575,-10.799404533771341,-0.018781573102211027
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; // Check to make sure that name_i + 2 does not exceed the n length if ( NCH(n) > (name_i + 2) && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH(n) > (name_i + 2) && TYPE ( CHILD ( n , name_i + 2 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",585,-34.562679691258396,-0.059081503745740845
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { if(name_i + 3 > NCH(n)) { ast_error ( c , n , ""Out-of-bounds read"" ) ; return NULL ; } returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",577,-13.938753823338478,-0.02415728565569927
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { 
  identifier name ; 
  arguments_ty args ; 
  asdl_seq * body ; 
  expr_ty returns = NULL ; 
  int name_i = 1 ; 
  node * tc ; 
  string type_comment = NULL ; 
  int n_children = NCH(n); //added line
  if ( is_async && c -> c_feature_version < 5 ) { 
    ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; 
    return NULL ; 
  } 
  REQ ( n , funcdef ) ; 
  name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; 
  if ( ! name ) return NULL ; 
  if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; 
  args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; 
  if ( ! args ) return NULL ; 
  if ( n_children > 3 && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { //modified line
    returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; 
    if ( ! returns ) return NULL ; 
    name_i += 2 ; 
  } 
  if ( n_children > 4 && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { //modified line
    type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; 
    name_i += 1 ; 
  } 
  body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; 
  if ( ! body ) return NULL ; 
  if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { 
    tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; 
    if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; 
  } 
  if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; 
  else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; 
}",675,-25.64298077873273,-0.037989601153678124
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","

static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) > name_i + 2 ) { if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) > name_i + 3 && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }

In the fixed code, additional checks have been added to make sure that the code is not trying to access data that is out of the bounds. For example, in the original code, the code tries to access the node at index name_i + 3, but there is no check to make sure that the node exists. In the fixed code, an additional check has been added to make sure that the node exists before attempting to access it. Similarly, additional checks have been added to make sure that the code is not accessing data out of the bounds.",682,-77.83387019438186,-0.11412590937592648
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 , name_i_max = 3 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( name_i < name_i_max && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( name_i < name_i_max && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }

The code has been fixed by introducing an upper bound limit for the name_i variable by setting it to name_i_max. This ensures that the code does not attempt to access an element beyond the array boundary which could cause the out-of-bounds read vulnerability.",626,-61.374902790201354,-0.09804297570319705
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW && NCH ( CHILD ( n , name_i + 2 ) ) > 0) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",558,-9.654593618843919,-0.017302139101870822
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( NCH ( n ) > 2 ) { name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; } else { ast_error ( c , n , ""Function expects at least two arguments"" ) ; return NULL ; } if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; 
}",578,-28.0163752358784,-0.04847123743231557
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { if ( NCH(n) > name_i + 3) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } else { ast_error ( c , n , ""Not enough arguments for function definition"" ) ; return NULL ; } } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",580,-19.414972729615894,-0.033474090913130854
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","

static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( NCH ( n ) <= name_i ) { ast_error ( c , n , ""Expected an identifier"" ) ; return NULL ; } name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",574,-17.566514840024343,-0.030603684390286313
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) > ( name_i + 2 ) && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) > ( name_i + 3 ) && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
The vulnerability is fixed by checking the boundary of the array before accessing the elements of the array.",588,-24.54807623221243,-0.04174842896634767
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) > name_i + 2 ) { if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } } if ( NCH ( n ) > name_i + 3 && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } 
The code has been modified to add checks to ensure that the original code does not attempt to access an element outside of the bounds of the array. This was done by adding an if statement to check the number of available children before attempting to access the additional elements.",622,-61.29114895711961,-0.09853882468990291
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH(n) > name_i + 2 && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH(n) > name_i + 3 && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }

The code has been fixed by adding boundary checks to the code before accessing elements of the array. This ensures that an out-of-bounds read cannot occur.",599,-29.752083470798517,-0.049669588432050944
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { if (NCH(CHILD(n, name_i+2)) > 3) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } else { return NULL; } } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",567,-15.802873265119239,-0.027871028686277315
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) > (name_i + 2) && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) > (name_i + 3) && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }

The vulnerability has been fixed by adding checks to ensure that the offsets used are within the bounds of the node.",592,-26.15514635275423,-0.044180990460733496
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( n -> n_nchildren < name_i ) { ast_error ( c , n , ""Function has no name!"" ) ; return NULL ; } name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",574,-19.77879525875395,-0.034457831461243815
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) > name_i + 2 && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) > name_i + 3 && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",564,-3.85295478828793,-0.00683148012107789
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( NCH ( n ) < name_i + 1 ) return NULL ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",557,-8.13249316764635,-0.014600526333296858
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; 

if (is_async && c->c_feature_version < 5) {
    ast_error(c, n, ""Async functions are only supported in Python 3.5 and greater"");
    return NULL;
}

if (NCH(n) < name_i + 3) {
    ast_error(c, n, ""not enough children for funcdef"");
    return NULL;
}

REQ(n, funcdef);
name = NEW_IDENTIFIER(CHILD(n, name_i));

if (!name) return NULL;
if (forbidden_name(c, name, CHILD(n, name_i), 0)) return NULL;

args = ast_for_arguments(c, CHILD(n, name_i + 1));

if (!args) return NULL;

if (TYPE(CHILD(n, name_i + 2)) == RARROW) {
    returns = ast_for_expr(c, CHILD(n, name_i + 3));
    if (!returns) return NULL;
    name_i += 2;
}

if (TYPE(CHILD(n, name_i + 3)) == TYPE_COMMENT) {
    type_comment = NEW_TYPE_COMMENT(CHILD(n, name_i + 3));
    name_i += 1;
}

if (NCH(n) < name_i + 3) {
    ast_error(c, n, ""not enough children for funcdef"");
    return NULL;
}

body = ast_for_suite(c, CHILD(n, name_i + 3));

if (!body) return NULL;

if (!type_comment && NCH(CHILD(n, name_i + 3)) > 1) {
    tc = CHILD(CHILD(n, name_i + 3), 1);
    if (TYPE(tc) == TYPE_COMMENT) type_comment = NEW_TYPE_COMMENT(tc);
}

if (is_async) {
    return AsyncFunctionDef(name, args, body, decorator_seq, returns, type_comment, LINENO(n), n->n_col_offset, c->c_arena);
} else {
    return FunctionDef(name, args, body, decorator_seq, returns, type_comment, LINENO(n), n->n_col_offset, c->c_arena);
}
}",654,-33.62762219984524,-0.0514183825685707
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( NCH ( n ) <= name_i ) return NULL; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",555,-7.056154904326051,-0.012713792620407298
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","

static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { 
    identifier name ; 
    arguments_ty args ; 
    asdl_seq * body ; 
    expr_ty returns = NULL ; 
    int name_i = 1 ; 
    node * tc ; 
    string type_comment = NULL ; 
    
    if ( is_async && c -> c_feature_version < 5 ) { 
        ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; 
        return NULL ; 
    }
    
    REQ ( n , funcdef ) ; 
    name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; 
    if ( ! name ) 
        return NULL ; 
    if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) 
        return NULL ; 
    
    args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; 
    if ( ! args ) 
        return NULL ; 
    
    if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW && (name_i + 3) < NCH(n) ) { 
        returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; 
        if ( ! returns ) 
            return NULL ; 
        name_i += 2 ; 
    } 
    
    if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT && (name_i + 3) < NCH(n) ) { 
        type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; 
        name_i += 1 ; 
    } 
    
    body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; 
    if ( ! body ) 
        return NULL ; 
    
    if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { 
        if ((name_i + 4) < NCH(n) ) {
            tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; 
            if ( TYPE ( tc ) == TYPE_COMMENT ) 
                type_comment = NEW_TYPE_COMMENT ( tc ) ;
        }
    } 
    
    if ( is_async ) 
        return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; 
    else 
        return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; 
}",732,-37.35968040417544,-0.05103781475980252
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } 

REQ ( n , funcdef ) ; 
if(NCH(n)<name_i + 3){
  ast_error(c, n, ""Out-of-bounds read detected"");
  return NULL;
}
name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; 
if ( ! name ) return NULL ; 
if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; 
args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; 
if ( ! args ) return NULL ; 
if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { 
  returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; 
  if ( ! returns ) return NULL ; 
  name_i += 2 ; 
} 
if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { 
  type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; 
  name_i += 1 ; 
} 
body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; 
if ( ! body ) return NULL ; 
if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { 
  tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; 
  if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; 
} 
if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; 
else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; 
}",638,-28.10888129979472,-0.04405780767992903
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name || forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",535,-4.725099669076488,-0.008831961998273808
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( NCH ( n ) < name_i + 1 ) { ast_error ( c , n , ""Function definition requires at least one argument"" ) ; return NULL ; } name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) > ( name_i + 2 ) && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) > ( name_i + 3 ) && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",606,-16.83213539658393,-0.02777580098446193
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( NCH ( n ) < 4 ) { ast_error ( c , n , ""Function definition too short"" ) ; return NULL ; } name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",571,-11.647841419058066,-0.020399021749663862
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","

static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) >= (name_i + 2) && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) >= (name_i + 3) && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",569,-9.052901728758245,-0.01591019635985632
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { if (NCH(n) > name_i + 2){ returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
The out-of-bounds read vulnerability is fixed by introducing an extra check to make sure that the number of children (NCH) is greater than name_i +2 before attempting to access the data at CHILD (n, name_i +3). This will ensure that no out-of-bounds read is performed.",625,-57.88977509976938,-0.09262364015963101
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) > (name_i + 2) && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) > (name_i + 3) && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
 
The fixed code checks the number of children and avoids accessing elements beyond the array bounds.",588,-34.56901603348071,-0.05879084359435494
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { if ( NCH(n) > (name_i + 3) ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } else { ast_error ( c , n , ""Missing expression after arrow token"" ) ; return NULL ; } } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",581,-16.897612806518325,-0.029083670923439456
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) >= ( name_i + 2 ) && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) >= ( name_i + 3 ) && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }

The vulnerability has been fixed by adding bounds checking to the original code. This is accomplished by adding an NCH (n) check to the if statements that check for a RARROW or TYPE_COMMENT. This ensures that the code will not try to access elements of the node outside of its array bounds.",633,-59.84448903073114,-0.09454105692058631
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( NCH ( n ) < ( name_i + 3 ) ) { ast_error ( c , n , ""Function definition requires 3 arguments"" ) ; return NULL ; } name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) > ( name_i + 3 ) && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",592,-17.85785988102927,-0.030165303853089985
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( name_i > (NCH(n)-1) ) return NULL; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { if (name_i+3 > (NCH(n)-1)) return NULL; tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",577,-23.423970906866373,-0.04059613675366789
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) >= name_i + 2 && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) >= name_i + 3 && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }

The code was fixed by checking that the number of children of the node was greater than or equal to the index of the child node before accessing it. This prevents the code from accessing nodes that are outside of the bounds of the node's array and therefore preventing a potential out-of-bounds read.",627,-58.910625584490035,-0.09395634064511968
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW && NCH(n) > (name_i + 3) ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }

The original code is vulnerable as it reads data outside of the array bounds if the node object has fewer than 3 elements. The fixed code checks to make sure that the array has at least 3 elements before attempting to read data from it.",603,-59.69962790786471,-0.09900435805616038
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if (NCH(n) < name_i + 1) { ast_error (c, n, ""Out-of-bounds read""); return NULL; } name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",576,-14.153337505697287,-0.02457176650294668
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( NCH ( n ) > ( name_i + 2 ) && TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( NCH ( n ) > ( name_i + 3 ) && TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
The code has been fixed by adding checks for the number of child nodes before accessing them. This prevents an out-of-bounds read which could lead to a security vulnerability.",605,-30.466577098083032,-0.05035797867451741
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; // Add check to make sure n->n_nchildren is within bounds if (n->n_nchildren > 4) name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; else return NULL; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",570,-27.217144186790723,-0.047749375766299514
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; if ( NCH ( n ) < 3 ){ ast_error ( c , n , ""The function must have a name and parentheses"" ) ; return NULL ; } name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",575,-28.354437941103598,-0.049312065984527996
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
Fixed code:","
static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n , asdl_seq * decorator_seq , int is_async ) { identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async functions are only supported in Python 3.5 and greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; if (NCH ( n ) > name_i + 3 ) { name_i += 2 ; } } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",556,-15.456580213335002,-0.02779960470024281
