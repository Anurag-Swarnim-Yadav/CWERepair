Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,raw_predictions,correctly_predicted
231,CWE-287,"ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
","<S2SV_ModStart> -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )
",cherokee@webserver/fbda667221c51f0aa476a02366e0cf66cb012f88,CVE-2014-4668,https://github.com/cherokee/webserver/commit/fbda667221c51f0aa476a02366e0cf66cb012f88,2014-07-02T04:14Z,"<S2SV_ModStart> validator -> user ) || ( cherokee_buffer_cnt_cspn ( & conn -> validator -> user, 0, ""*()"" )",0
287,CWE-287,"static void oidc_scrub_headers ( request_rec * r ) { oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ; if ( cfg -> scrub_request_headers != 0 ) { oidc_scrub_request_headers ( r , OIDC_DEFAULT_HEADER_PREFIX , oidc_cfg_dir_authn_header ( r ) ) ; if ( ( strstr ( cfg -> claim_prefix , OIDC_DEFAULT_HEADER_PREFIX ) != cfg -> claim_prefix ) ) { oidc_scrub_request_headers ( r , cfg -> claim_prefix , NULL ) ; } } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void oidc_scrub_headers (
",pingidentity@mod_auth_openidc/21e3728a825c41ab41efa75e664108051bb9665e,CVE-2017-6413,https://github.com/pingidentity/mod_auth_openidc/commit/21e3728a825c41ab41efa75e664108051bb9665e,2017-03-02T06:59Z,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void oidc_scrub_headers (,1
413,CWE-287,"static void _sx_sasl_client_process ( sx_t s , sx_plugin_t p , Gsasl_session * sd , const char * mech , const char * in , int inlen ) { _sx_sasl_t ctx = ( _sx_sasl_t ) p -> private ; _sx_sasl_sess_t sctx = NULL ; char * buf = NULL , * out = NULL , * realm = NULL , * * ext_id ; char hostname [ 256 ] ; int ret ; # ifdef HAVE_SSL int i ; # endif size_t buflen , outlen ; assert ( ctx ) ; assert ( ctx -> cb ) ; if ( mech != NULL ) { _sx_debug ( ZONE , ""auth request from client (mechanism=%s)"" , mech ) ; if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) { _sx_debug ( ZONE , ""client requested mechanism (%s) that we didn\'t offer"" , mech ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INVALID_MECHANISM , NULL ) , 0 ) ; return ; } ret = gsasl_server_start ( ctx -> gsasl_ctx , mech , & sd ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_server_start failed, no sasl for this conn; (%d): %s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_TEMPORARY_FAILURE , gsasl_strerror ( ret ) ) , 0 ) ; return ; } ( ctx -> cb ) ( sx_sasl_cb_GET_REALM , NULL , ( void * * ) & realm , s , ctx -> cbarg ) ; sctx = gsasl_session_hook_get ( sd ) ; if ( sctx != NULL ) free ( sctx ) ; sctx = ( _sx_sasl_sess_t ) calloc ( 1 , sizeof ( struct _sx_sasl_sess_st ) ) ; sctx -> s = s ; sctx -> ctx = ctx ; gsasl_session_hook_set ( sd , ( void * ) sctx ) ; gsasl_property_set ( sd , GSASL_SERVICE , ctx -> appname ) ; gsasl_property_set ( sd , GSASL_REALM , realm ) ; hostname [ 0 ] = '\\0' ; gethostname ( hostname , 256 ) ; hostname [ 255 ] = '\\0' ; gsasl_property_set ( sd , GSASL_HOSTNAME , hostname ) ; ext_id = NULL ; # ifdef HAVE_SSL for ( i = 0 ; i < s -> env -> nplugins ; i ++ ) if ( s -> env -> plugins [ i ] -> magic == SX_SSL_MAGIC && s -> plugin_data [ s -> env -> plugins [ i ] -> index ] != NULL ) ext_id = ( ( _sx_ssl_conn_t ) s -> plugin_data [ s -> env -> plugins [ i ] -> index ] ) -> external_id ; if ( ext_id != NULL ) { for ( i = 0 ; i < SX_CONN_EXTERNAL_ID_MAX_COUNT ; i ++ ) if ( ext_id [ i ] != NULL ) { ctx -> ext_id [ i ] = strdup ( ext_id [ i ] ) ; } else { ctx -> ext_id [ i ] = NULL ; break ; } } # endif _sx_debug ( ZONE , ""sasl context initialised for %d"" , s -> tag ) ; s -> plugin_data [ p -> index ] = ( void * ) sd ; if ( strcmp ( mech , ""ANONYMOUS"" ) == 0 ) { ( ctx -> cb ) ( sx_sasl_cb_GEN_AUTHZID , NULL , ( void * * ) & out , s , ctx -> cbarg ) ; buf = strdup ( out ) ; buflen = strlen ( buf ) ; } else if ( strstr ( in , ""<"" ) != NULL && strncmp ( in , ""="" , strstr ( in , ""<"" ) - in ) == 0 ) { _sx_debug ( ZONE , ""gsasl auth string is empty"" ) ; buf = strdup ( """" ) ; buflen = strlen ( buf ) ; } else { ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_base64_from failed, no sasl for this conn; (%d): %s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; return ; } } ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; } else { ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_base64_from failed, no sasl for this conn; (%d): %s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; return ; } if ( ! sd ) { _sx_debug ( ZONE , ""response send before auth request enabling mechanism (decoded: %.*s)"" , buflen , buf ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_MECH_TOO_WEAK , ""response send before auth request enabling mechanism"" ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; return ; } _sx_debug ( ZONE , ""response from client (decoded: %.*s)"" , buflen , buf ) ; ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; } if ( buf != NULL ) free ( buf ) ; if ( ret == GSASL_OK ) { _sx_debug ( ZONE , ""sasl handshake completed"" ) ; ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; if ( ret == GSASL_OK ) { _sx_nad_write ( s , _sx_sasl_success ( s , buf , buflen ) , 0 ) ; free ( buf ) ; ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify = _sx_sasl_notify_success ; ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify_arg = ( void * ) p ; } else { _sx_debug ( ZONE , ""gsasl_base64_to failed, no sasl for this conn; (%d): %s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; } if ( out != NULL ) free ( out ) ; return ; } if ( ret == GSASL_NEEDS_MORE ) { _sx_debug ( ZONE , ""sasl handshake in progress (challenge: %.*s)"" , outlen , out ) ; ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; if ( ret == GSASL_OK ) { _sx_nad_write ( s , _sx_sasl_challenge ( s , buf , buflen ) , 0 ) ; free ( buf ) ; } else { _sx_debug ( ZONE , ""gsasl_base64_to failed, no sasl for this conn; (%d): %s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; } if ( out != NULL ) free ( out ) ; return ; } if ( out != NULL ) free ( out ) ; _sx_debug ( ZONE , ""sasl handshake failed; (%d): %s"" , ret , gsasl_strerror ( ret ) ) ; switch ( ret ) { case GSASL_AUTHENTICATION_ERROR : case GSASL_NO_ANONYMOUS_TOKEN : case GSASL_NO_AUTHID : case GSASL_NO_AUTHZID : case GSASL_NO_PASSWORD : case GSASL_NO_PASSCODE : case GSASL_NO_PIN : case GSASL_NO_SERVICE : case GSASL_NO_HOSTNAME : out = _sasl_err_NOT_AUTHORIZED ; break ; case GSASL_UNKNOWN_MECHANISM : case GSASL_MECHANISM_PARSE_ERROR : out = _sasl_err_INVALID_MECHANISM ; break ; case GSASL_BASE64_ERROR : out = _sasl_err_INCORRECT_ENCODING ; break ; default : out = _sasl_err_MALFORMED_REQUEST ; } _sx_nad_write ( s , _sx_sasl_failure ( s , out , gsasl_strerror ( ret ) ) , 0 ) ; }
","<S2SV_ModStart> , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK
",jabberd2@jabberd2/8416ae54ecefa670534f27a31db71d048b9c7f16,CVE-2017-10807,https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16,2017-07-04T15:29Z,"<S2SV_ModStart> ; if ( <S2SV_ModEnd>! gsasl_server_support_p ( <S2SV_ModStart>, mech ) ) { _sx_debug ( ZONE, ""client requested mechanism (%s) that we didn\'t offer"", mech ) ; _sx_nad_write ( s, _sx_sasl_failure ( s, _sasl_err_INVALID_MECHANISM, NULL ), 0 ) ; return ; } ret = gsasl_server_start ( ctx -> gsasl_ctx, mech, & sd ) ; if ( ret!= GSASL_OK ) { _sx_debug ( ZONE, ""gsasl_server_start failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror ( ret ) ) ; _sx_nad_write ( s, _sx_sasl_failure ( s, _sasl_err_TEMPORARY_FAILURE, gsasl_strerror ( ret ) ) ) ; _sx_nad_write ( s, _sx_sasl_failure (",0
561,CWE-287,"ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
","<S2SV_ModStart> -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )
",cherokee@webserver/fbda667221c51f0aa476a02366e0cf66cb012f88,CVE-2014-4668,https://github.com/cherokee/webserver/commit/fbda667221c51f0aa476a02366e0cf66cb012f88,2014-07-02T04:14Z,"<S2SV_ModStart> validator -> user ) || ( cherokee_buffer_cnt_cspn ( & conn -> validator -> user, 0, ""*()"" )",0
975,CWE-287,"static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
","<S2SV_ModStart> siocb -> scm , false
",torvalds@linux/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,CVE-2012-3520,https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,2012-10-03T11:02Z,"<S2SV_ModStart> siocb -> scm, false",1
1635,CWE-287,"int m_authenticate ( struct Client * cptr , struct Client * sptr , int parc , char * parv [ ] ) { struct Client * acptr ; int first = 0 ; char realhost [ HOSTLEN + 3 ] ; char * hoststr = ( cli_sockhost ( cptr ) ? cli_sockhost ( cptr ) : cli_sock_ip ( cptr ) ) ; if ( ! CapActive ( cptr , CAP_SASL ) ) return 0 ; if ( parc < 2 ) return need_more_params ( cptr , ""AUTHENTICATE"" ) ; if ( strlen ( parv [ 1 ] ) > 400 ) return send_reply ( cptr , ERR_SASLTOOLONG ) ; if ( IsSASLComplete ( cptr ) ) return send_reply ( cptr , ERR_SASLALREADY ) ; if ( ! ( acptr = cli_saslagent ( cptr ) ) ) { if ( strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) acptr = find_match_server ( ( char * ) feature_str ( FEAT_SASL_SERVER ) ) ; else acptr = NULL ; } if ( ! acptr && strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) return send_reply ( cptr , ERR_SASLFAIL , "": service unavailable"" ) ; if ( acptr && IsMe ( acptr ) ) return 0 ; if ( ! cli_saslcookie ( cptr ) ) { do { cli_saslcookie ( cptr ) = ircrandom ( ) & 0x7fffffff ; } while ( ! cli_saslcookie ( cptr ) ) ; first = 1 ; } if ( strchr ( hoststr , ':' ) != NULL ) ircd_snprintf ( 0 , realhost , sizeof ( realhost ) , ""[%s]"" , hoststr ) ; else ircd_strncpy ( realhost , hoststr , sizeof ( realhost ) ) ; if ( acptr ) { if ( first ) { if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C %C!%u.%u S %s :%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_one ( & me , CMD_SASL , acptr , ""%C %C!%u.%u S :%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C %C!%u.%u H :%s@%s:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_one ( & me , CMD_SASL , acptr , ""%C %C!%u.%u C :%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } else { if ( first ) { if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""* %C!%u.%u S %s :%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""* %C!%u.%u S :%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""* %C!%u.%u H :%s@%s:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""* %C!%u.%u C :%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } if ( ! t_active ( & cli_sasltimeout ( cptr ) ) ) timer_add ( timer_init ( & cli_sasltimeout ( cptr ) ) , sasl_timeout_callback , ( void * ) cptr , TT_RELATIVE , feature_int ( FEAT_SASL_TIMEOUT ) ) ; return 0 ; }
","<S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , ' ' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed AUTHENTICATE"" ) ; if ( <S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , ' ' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed AUTHENTICATE"" ) ; if (
",evilnet@nefarious2/f50a84bad996d438e7b31b9e74c32a41e43f8be5,CVE-2016-7145,https://github.com/evilnet/nefarious2/commit/f50a84bad996d438e7b31b9e74c32a41e43f8be5,2017-03-07T15:59Z,"<S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ],' ') ) return exit_client ( cptr, sptr, sptr, ""Malformed AUTHENTICATE"" ) ; if ( <S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ],' ') ) return exit_client ( cptr, sptr, sptr, ""Malformed AUTHENTICATE"" ) ; if (",1
