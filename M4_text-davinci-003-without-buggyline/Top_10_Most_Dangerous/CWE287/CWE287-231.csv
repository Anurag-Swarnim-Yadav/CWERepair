Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 

ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) // added condition to check for empty password { return ret_error ; } size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",654,-19.966118549632363,-0.030529233256318598
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; if ( cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

The vulnerability in the original code was that there was no check for the password - the code just checked that the username was valid and then it allowed access. The fixed code adds an additional check to make sure that a password is not empty before it allows access.",703,-59.45077339401839,-0.0845672452261997
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; // Added authentication check here if (conn->validator->passwd.len == 0) { ldap_unbind_s(ldap->conn); return ret_error; } re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",662,-19.10360903045603,-0.028857415453861075
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; char * user ; char * pass ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; user = conn -> validator ? conn -> validator -> user . buf : NULL ; pass = conn -> validator ? conn -> validator -> passwd . buf : NULL ; if ( ( user == NULL ) || ( pass == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , pass ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , user ) ; return ret_ok ; }",654,-20.869220675968243,-0.031910123357749606
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 

ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; 

//Addition for authentication
if(conn->validator->passwd.buf == NULL)
	return ret_error;

ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",656,-25.164587832996737,-0.038360652184446245
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; }

//Added authentication check
if (conn->validator->passwd.len == 0) {
  ldap_msgfree ( message ) ;
  return ret_error;
}

ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",666,-23.919428055506447,-0.035915057140400074
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
The CWE-287 vulnerability is fixed by adding a check for the buffer password to the if statement that checks for a validator and user. The code now checks to make sure that the validator and user are not empty AND that the password is not empty.",695,-52.05838320314551,-0.07490414849373454
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

The vulnerability in the original code was that the password was never checked. The code was fixed by adding an if statement to check if the password was empty and returning an error if it is. The code was also changed to check the password with the new if statement.",696,-51.28998345112065,-0.07369250495850668
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

The vulnerability was fixed by adding a condition to the beginning of the code: cherokee_buffer_is_empty(&conn->validator->passwd). This ensures that the user must enter their password before being granted access.",691,-30.121621265241643,-0.04359134770657257
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
The vulnerability has been fixed by adding an additional check for the presence of a password to the original code. This ensures that the user is authenticated with a valid username and password before granting access.",681,-30.262187607190192,-0.04443786726459646
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; // verify supplied user credentials before performing the search re = ldap_simple_bind_s(ldap->conn, conn->validator->user.buf, conn->validator->passwd.buf); if (re != LDAP_SUCCESS) return ret_error; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",682,-29.31643081904634,-0.042985968942883195
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; 
if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; 
//Add salt to password for security
char * salted_pass = malloc(strlen(conn -> validator -> passwd . buf) + strlen(SALT) + 1);
strcpy(salted_pass, conn -> validator -> passwd . buf);
strcat(salted_pass, SALT);

re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; 
//Use salted password for authentication
ret = validate_dn ( props , dn , salted_pass ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; 
//Free salted password
free(salted_pass);

TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",724,-50.065405143740534,-0.0691511120769897
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ;
//authentication is added 
if (ldap_simple_bind_s(ldap->conn, props->user.buf, conn->validator->passwd.buf) != LDAP_SUCCESS) { ldap_unbind_s(ldap->conn); LOG_ERROR(CHEROKEE_ERROR_VALIDATOR_LDAP_BIND, props->user.buf); return ret_error; }

re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",721,-39.515921743423554,-0.05480710366632948
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","

ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn_with_password ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",647,-9.418569359369535,-0.014557294218500053
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
The original code was vulnerable to CWE-287: Improper Authentication because it was not checking if the user had provided a password before attempting to authenticate. The fixed code now checks to make sure that the user has provided a valid password before attempting to authenticate.",697,-35.454091415768794,-0.050866702174704154
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

In the fixed code, an additional check is added to make sure that the 'passwd' field is not empty before granting access. This check prevents users from bypassing authentication by using an empty password.",685,-37.673627682910194,-0.05499799661738714
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; // Add Authentication ret = bind_authentication ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; // Validate ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; } ret_t bind_authentication ( cherokee_validator_ldap_props_t * props , char * dn , char * password ) { int re ; re = ldap_simple_bind_s ( props -> conn , dn , password ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_AUTH , dn ? dn : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""user %s authenticated\\n"" , dn ) ; return ret_ok ; }",795,-48.22215988974301,-0.06065680489275851
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
The code has been modified to check for a valid password in addition to a valid user, which prevents unauthorized users from being able to authenticate.",672,-31.629343147672042,-0.047067474922131015
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; 
// Added code to authenticate user
if ( !authenticate_user(conn->validator->user.buf, conn->validator->passwd.buf) ) {
    return ret_error;
}

re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

// Added function to authenticate user
bool authenticate_user(char* username, char* password) {
    // Perform authentication using username/password 
    // ...
    // Return true if authentication is successful
    return true;
}",727,-52.35519784447266,-0.07201540281220449
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; 

if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; 

ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } 

TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; 

ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; 

re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",657,-16.962346158766035,-0.025817878476051805
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; /* Add check for existance of validator password */ if ( cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",659,-27.598177819384777,-0.04187887377751863
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; if (cherokee_buffer_is_empty(&conn->validator->passwd)) return ret_error; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
The fixed code checks if the password is empty or not. If the password is empty, it returns an error.",670,-21.137543893054673,-0.031548572974708464
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

The vulnerability has been fixed by adding a check to make sure the connection validator's password is not empty before allowing authentication. The code was changed from:

if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ;

to:

if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ;",772,-29.288830842634653,-0.03793890005522623
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; // added line to check if password is in the connection re = verify_password(conn->validator->passwd.buf); if (re != ret_ok) return ret_error; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

//added verification function
int verify_password (char* passwd) {
	if (passwd == NULL) {
		return ret_error;
	}
	return ret_ok;
}",711,-56.61923374808383,-0.07963324015201664
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

The vulnerability has been fixed by adding a check for the presence of the 'passwd' buffer in the user's authentication credentials. This ensures that the user is attempting to authenticate with both a username and password.",686,-41.211444205324405,-0.060074991552951026
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

The vulnerability has been fixed by adding a check to ensure that the password field is not empty. This is done by adding cherokee_buffer_is_empty(&conn->validator->passwd) to the condition in the if statement.",693,-23.762455104608076,-0.03428925700520646
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_simple_bind_s (ldap->conn, dn, conn->validator->passwd.buf); if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

The code has been fixed by replacing the ldap_search_s call with a ldap_simple_bind_s call and providing the password required for authentication. This ensures that the user is authenticated before being granted access.",651,-43.30578041464399,-0.0665219361208049
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",641,-3.7605300980200713,-0.0058666616193760865
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; if(props->password_check && !cherokee_buffer_is_empty(&conn->validator->passwd)) { ret = validate_password(props, conn->validator->passwd.buf); if(ret != ret_ok) return ret; } re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
The code has been modified to add a check of the password before sending the search query to the server. This check is done by calling a new function 'validate_password' which is passed the credentials and checks if the password is valid or not. If the credentials fail the validation, the search query is not sent and the user is not authenticated.",753,-97.73778017683877,-0.12979784884042334
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","

ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; 

//Check if the password is provided
if ( cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ;

ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ;

//Validate the user credentials
ret = validate_credentials ( props , dn , conn -> validator -> user.buf, conn-> validator->passwd.buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",683,-36.414474457380116,-0.05331548236805288
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; if ( cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
The fixed code adds a check to ensure that the password field is not empty before attempting authentication. This prevents an attacker from bypassing authentication by not providing a password.",683,-28.195307489250315,-0.04128156294180134
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; 
 // Added code begins 
if( cherokee_buffer_is_empty (&conn->validator->passwd) ) { 
	return ret_error; 
} 
// Added code ends 

ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",671,-39.183938121091806,-0.05839633102994308
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) )  return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; // validate user credentials prior to search ret = validate_credentials(props, conn->validator->user.buf, conn->validator->passwd.buf); if (ret != ret_ok) return ret;  ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; // validate user against retrieved DN ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",678,-44.73804154163572,-0.06598531200831227
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { 
int re ; 
ret_t ret ; 
size_t size ; 
char * dn ; 
LDAPMessage * message ; 
LDAPMessage * first ; 
char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; 
cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; 
if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; 
size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; 
if ( size != conn -> validator -> user . len ) return ret_error ; 
ret = init_filter ( ldap , props , conn ) ; 
if ( ret != ret_ok ) return ret ; 

//Add authentication
char *userDN = NULL;
char filter[100];
sprintf (filter, ""(&(objectClass=*)(userPrincipalName=%s))"", conn->validator->user.buf );
re = ldap_search_s(ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, filter, attrs, 0, &message);
if(re != LDAP_SUCCESS) {
  LOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH, props->filter.buf ? props->filter.buf : """");
  return ret_error;
}

if (ldap_count_entries(ldap->conn, message) != 1) {
  ldap_msgfree(message);
  return ret_not_found;
}
first = ldap_first_entry(ldap->conn, message);
if (first == NULL) {
  ldap_msgfree(message);
  return ret_not_found;
}
userDN = ldap_get_dn(ldap->conn, first);
if (userDN == NULL) {
  ldap_msgfree(message);
  return ret_error;
}
ldap_msgfree(message);
ret = validate_dn(props, userDN, conn->validator->passwd.buf);
if (ret != ret_ok) return ret;

re = ldap_unbind_s(ldap->conn);
if (re != LDAP_SUCCESS) return ret_error;

TRACE (ENTRIES, ""Access to use %s has been granted\n"", conn->validator->user.buf);
return ret_ok;
}",673,-77.51910013966845,-0.11518439842447022
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty( &conn -> validator -> passwd )) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = authenticate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",642,-15.335250128622718,-0.023886682443337567
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { 
int re ; 
ret_t ret ; 
size_t size ; 
char * dn ; 
LDAPMessage * message ; 
LDAPMessage * first ; 
char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; 
cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; 

// Added authentication check
if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) 
    return ret_error ; 

size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; 
if ( size != conn -> validator -> user . len ) 
    return ret_error ; 

ret = init_filter ( ldap , props , conn ) ; 
if ( ret != ret_ok ) 
    return ret ; 

re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; 
if ( re != LDAP_SUCCESS ) { 
    LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; 
    return ret_error ; 
} 
TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; 

re = ldap_count_entries ( ldap -> conn , message ) ; 
if ( re != 1 ) { 
    ldap_msgfree ( message ) ; 
    return ret_not_found ; 
} 

first = ldap_first_entry ( ldap -> conn , message ) ; 
if ( first == NULL ) { 
    ldap_msgfree ( message ) ; 
    return ret_not_found ; 
} 

dn = ldap_get_dn ( ldap -> conn , first ) ; 
if ( dn == NULL ) { 
    ldap_msgfree ( message ) ; 
    return ret_error ; 
} 

ldap_msgfree ( message ) ; 
ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; 
if ( ret != ret_ok ) 
    return ret ; 

re = ldap_unbind_s ( ldap -> conn ) ; 
if ( re != LDAP_SUCCESS ) 
    return ret_error ; 

TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; 
return ret_ok ; 
}",763,-21.3041309838949,-0.02792153471021612
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; //Added code to check user's authentication credentials before allowing access if (conn->validator->passwd.len == 0 || strlen(conn->validator->passwd.buf) == 0) { return ret_deny; } re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",672,-36.10486243960758,-0.05372747386846366
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; 
if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; 
size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; 
if ( size != conn -> validator -> user . len ) return ret_error ; 
ret = init_filter ( ldap , props , conn ) ; 
if ( ret != ret_ok ) return ret ; 

re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; 
if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } 
TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; 
re = ldap_count_entries ( ldap -> conn , message ) ; 
if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } 
first = ldap_first_entry ( ldap -> conn , message ) ; 
if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } 
dn = ldap_get_dn ( ldap -> conn , first ) ; 
if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } 
ldap_msgfree ( message ) ; 

ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; 
if ( ret != ret_ok ) return ret ; 

re = ldap_unbind_s ( ldap -> conn ) ; 
if ( re != LDAP_SUCCESS ) return ret_error ; 
TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; 
return ret_ok ; 
}",687,-17.662669662378,-0.025709853948148474
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; if ( cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

The original code did not check if the password was provided by the user or not. To fix this vulnerability, a check was added to the code to make sure that a password was provided before attempting to authenticate the user. An if statement was added to check if the validator's password buffer was empty, and if so, return an error.",722,-55.09175815174573,-0.07630437417139298
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

The original code is vulnerable to CWE-287 because it does not perform authentication for the user. The code only checks whether the user buffer is empty or not, however it does not check the user's password. To fix this vulnerability, the code can be updated to check that the user's password buffer is also not empty before proceeding. This is accomplished by adding an additional check for the user's password buffer to the conditional statement at the beginning of the function.",737,-75.9578429199022,-0.10306355891438562
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; // Added code to authenticate user re = ldap_simple_bind_s(ldap -> conn, conn -> validator -> user. buf , conn -> validator -> passwd . buf); if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
The original code was vulnerable to CWE-287: Improper Authentication because the code was not authenticating the user prior to performing the search. To fix this vulnerability, the code was modified to include a ldap_simple_bind_s() function which authenticates the user with the given username and password before performing the search. This ensures that the user is properly authenticated before the search is performed.",801,-74.14515614407526,-0.0925657380075846
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; // Add authentication code before validating DN ret = bind_ldap (props, conn->validator->user.buf, conn->validator->passwd.buf, ldap); if (ret != ret_ok) return ret; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

//Function to authenticate the user
ret_t bind_ldap(cherokee_validator_ldap_props_t * props, char *user_name, char *user_password, cherokee_validator_ldap_t *ldap) {
    int re;
    const char *ldap_filter = ""(&(objectClass=user)(sAMAccountName=%s))"";
    char *auth_filter;
    char *dn;

    auth_filter = malloc(strlen(ldap_filter) + strlen(user_name) - 1);
    sprintf(auth_filter, ldap_filter, user_name);

    re = ldap_search_s(ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, auth_filter, NULL, 0, &message);
    if (re != LDAP_SUCCESS) {
        LOG_ERROR(CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH, props->filter.buf ? props->filter.buf : """");
        return ret_error;
    }

    if (ldap_count_entries(ldap->conn, message) != 1) {
        ldap_msgfree(message);
        return ret_not_found;
    }

    first = ldap_first_entry(ldap->conn, message);
    if (first == NULL) {
        ldap_msgfree(message);
        return ret_not_found;
    }

    dn = ldap_get_dn(ldap->conn, first);
    if (dn == NULL) {
        ldap_msgfree(message);
        return ret_error;
    }
    
    //Authenticate user
    re = ldap_simple_bind_s(ldap->conn, dn, user_password);
    if (re != LDAP_SUCCESS) {
        ldap_msgfree(message);
        return ret_not_found;
    }

    ldap_msgfree(message);
    return ret_ok;
}",1174,-110.03763520070844,-0.09372882044353359
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = authenticate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",643,-7.82736157809956,-0.012173190634680498
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," 
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

The code has been fixed by adding a condition that checks whether the validator's password field is empty. If it is, the code will return an error. This ensures that both the user name and password fields are present and non-empty before a connection is allowed.",699,-51.10217974781694,-0.07310755328729177
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; if (conn->validator->passwd.buf == NULL) return ret_error; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

In the fixed code, the vulnerability is fixed by adding an additional check that ensures that a password is present before proceeding with the authentication process. This check is added as an if statement: 

if (conn->validator->passwd.buf == NULL) return ret_error;",702,-43.52371149549412,-0.0619995890249204
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; } 

The vulnerability in the original code occurs because it does not check to make sure that the password is not empty. This can allow an attacker to authenticate without a password. The fixed code includes a check that the password is not empty before attempting to authenticate.",696,-43.53035886675558,-0.06254361906143042
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; if(!check_username_password_validity(conn->validator->user.buf, conn->validator->passwd.buf)){ return ret_error; } ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }

int check_username_password_validity(char* username, char* password) { 
    // Perform a check against unauthorized users 
    // Add code to implement authentication check here
    return 1; 
}",709,-75.52833934939109,-0.10652798215711014
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; //Added if ( ( conn -> validator == NULL && cherokee_buffer_is_empty ( & conn -> validator -> user )) || ( !conn->validator->passwd || cherokee_buffer_is_empty(&conn->validator->passwd))) return ret_error; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_password ( props , dn , conn -> validator -> passwd . buf ) ; //Changed if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",652,-47.05593010965004,-0.07217167194731601
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:"," ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; if (cherokee_buffer_is_empty (&conn->validator->passwd)) return ret_deny; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }",647,-13.134869900427399,-0.020301189954292732
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the vulnerability.
Original Code: ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
Fixed code:","
ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; 

if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) ) 
    return ret_error;

size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; 
if ( size != conn -> validator -> user . len )
    return ret_error; 

if (props->filter.buf == NULL || props->filter.len == 0) 
    return ret_error;

ret = init_filter ( ldap , props , conn ) ; 
if ( ret != ret_ok ) 
    return ret ; 

re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; 
if ( re != LDAP_SUCCESS ) { 
    LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; 
    return ret_error ; 
} 
TRACE ( ENTRIES , ""subtree search (%s): done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; 

re = ldap_count_entries ( ldap -> conn , message ) ; 
if ( re != 1 ) { 
    ldap_msgfree ( message ) ; 
    return ret_not_found ; 
} 
first = ldap_first_entry ( ldap -> conn , message ) ; 
if ( first == NULL ) { 
    ldap_msgfree ( message ) ; 
    return ret_not_found ; 
} 
dn = ldap_get_dn ( ldap -> conn , first ) ; 
if ( dn == NULL ) { 
    ldap_msgfree ( message ) ; 
    return ret_error ; 
} 
ldap_msgfree ( message ) ; 

if (conn->validator->passwd.buf == NULL || conn->validator->passwd.len == 0) 
    return ret_error;

ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; 
if ( ret != ret_ok ) 
    return ret ; 

re = ldap_unbind_s ( ldap -> conn ) ; 
if ( re != LDAP_SUCCESS ) 
    return ret_error ; 

TRACE ( ENTRIES , ""Access to use %s has been granted\\n"" , conn -> validator -> user . buf ) ; 
return ret_ok ; 
}",782,-45.57633165630639,-0.058281754036197425
