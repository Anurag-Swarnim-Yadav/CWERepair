Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page && ( access ( page , R_OK ) == 0 ) ) { 
char filePath[100];
realpath(page, filePath);
http_response_printf ( res , ""%s"" , file_read ( filePath ) ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && 
( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 

char filePath[100];
realpath(page, filePath);
file_write ( filePath , wikitext ) ; 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page ) {
char filePath[100];
realpath(page, filePath);
if ( unlink ( filePath ) > 0 ) {
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
}
}
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page ) {
char filePath[100];
realpath(page, filePath);
if ( access ( filePath , R_OK ) == 0 ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
}
}
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_send ( res ) ; 
return ; 
} 
} 
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
http_response_send ( res ) ; 
return ; 
}",937,-41.37449467951898,-0.044156344375153665
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { const char * base_dir = ""/var/www/wiki/""; char full_path[PATH_MAX] = { '\0' }; strncat(full_path, base_dir, PATH_MAX-1); strncat(full_path, page, PATH_MAX-1); if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { const char * base_dir = ""/var/www/wiki/""; char full_path[PATH_MAX] = { '\0' }; strncat(full_path, base_dir, PATH_MAX-1); strncat(full_path, page, PATH_MAX-1); file_write ( full_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { const char * base_dir = ""/var/www/wiki/""; char full_path[PATH_MAX] = { '\0' }; strncat(full_path, base_dir, PATH_MAX-1); strncat(full_path, page, PATH_MAX-1); if ( unlink ( full_path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { const char * base_dir = ""/var/www/wiki/""; char full_path[PATH_MAX] = { '\0' }; strncat(full_path, base_dir, PATH_MAX-1); strncat(full_path, page, PATH_MAX-1); if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The vulnerability is fixed by constraining the file access to the directory ""/var/www/wiki/"". The code concatenates the base directory ""/var/www/wiki/"" to the user-supplied input before passing the full path to the access function for read and write requests, and unlink function for delete requests. This way, the user input cannot be used to access files outside of the restricted directory.",1109,-109.94881505922918,-0.09914230393077474
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char page_path[MAX_PATH_SIZE]; //declare size of page_path array if ( page == NULL ) page = http_request_get_query_string ( req ) ; strcpy(page_path, “/home/wiki/”); //add base path to the page_path array strcat(page_path, page); //add the page to the page_path array if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; //update function with page_path array http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char page_path[MAX_PATH_SIZE]; //declare size of page_path array strcpy(page_path, “/home/wiki/”); //add base path to the page_path array strcat(page_path, page); //add the page to the page_path array file_write ( page_path , wikitext ) ; //update function with page_path array http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char page_path[MAX_PATH_SIZE]; //declare size of page_path array if ( page == NULL ) page = http_request_get_query_string ( req ) ; strcpy(page_path, “/home/wiki/”); //add base path to the page_path array strcat(page_path, page); //add the page to the page_path array if ( page && ( unlink ( page_path ) > 0 ) ) { //update function with page_path array http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char page_path[MAX_PATH_SIZE]; //declare size of page_path array if ( page == NULL ) page = http_request_get_query_string ( req ) ; strcpy(page_path, “/home/wiki/”); //add base path to the page_path array strcat(page_path, page); //add the page to the page_path array if ( page && ( access ( page_path , R_OK ) == 0 ) ) { //update function with page_path array http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The above code fixes the vulnerability by declaring a char array to store the page path, adding a base path to the beginning of the array, and adding the page to the end of the array. The array is then used in the access() and unlink() functions instead of the original page variable. This ensures that all file requests are limited to the specified directory, preventing path traversal.",1137,-129.5224290020194,-0.1139159445928051
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
	char path[ PATH_MAX ] ; 
	if ( func != NULL && * func != '\\0' ) { 
		if ( ! strcmp ( func , ""page/get"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && realpath ( page , path ) && ( access ( path , R_OK ) == 0 ) ) { 
				http_response_printf ( res , ""%s"" , file_read ( path ) ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""page/set"" ) ) { 
			char * wikitext = NULL , * page = NULL ; 
			if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) 
				&& ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) 
				&& realpath ( page , path ) ) { 
				file_write ( path , wikitext ) ; 
				http_response_printf ( res , ""success"" ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && realpath ( page , path ) && ( unlink ( path ) > 0 ) ) { 
				http_response_printf ( res , ""success"" ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && realpath ( page , path ) && ( access ( path , R_OK ) == 0 ) ) { 
				http_response_printf ( res , ""success"" ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
			WikiPageList * * pages = NULL ; 
			int n_pages , i ; 
			char * expr = http_request_param_get ( req , ""expr"" ) ; 
			if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
			pages = wiki_get_pages ( & n_pages , expr ) ; 
			if ( pages ) { 
				for ( i = 0 ; i < n_pages ; i ++ ) { 
					struct tm * pTm ; 
					char datebuf [ 64 ] ; 
					pTm = localtime ( & pages [ i ] -> mtime ) ; 
					strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
					http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
				} 
				http_response_send ( res ) ; 
				return ; 
			} 
		} 
	} 
	
	http_response_set_status ( res , 500 , ""Error"" ) ; 
	http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
	http_response_send ( res ) ; 
	return ; 
}",1097,-34.612606746645575,-0.03155205719840071
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * page_path = realpath(page, NULL); if ( page_path && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; free(page_path); return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * page_path = realpath(page, NULL); file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(page_path); return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * page_path = realpath(page, NULL); if ( page_path && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(page_path); return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * page_path = realpath(page, NULL); if ( page_path && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(page_path); return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
In the fixed code above, the vulnerable path has been replaced by the realpath() function which will only return the canonicalized absolute pathname of the given input. This eliminates the possibility of traversing outside of the restricted directory. Additionally, the memory of the absolute path must be freed with the free() function after it is no longer needed.",909,-79.90160087044752,-0.08790055101259353
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Added code below char pagePath[PATH_MAX]; snprintf(pagePath, sizeof(pagePath), ""%s/%s"", ""/path/to/root/of/wiki/files"", page); if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { // Added code below char pagePath[PATH_MAX]; snprintf(pagePath, sizeof(pagePath), ""%s/%s"", ""/path/to/root/of/wiki/files"", page); file_write ( pagePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Added code below char pagePath[PATH_MAX]; snprintf(pagePath, sizeof(pagePath), ""%s/%s"", ""/path/to/root/of/wiki/files"", page); if ( page && ( unlink ( pagePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Added code below char pagePath[PATH_MAX]; snprintf(pagePath, sizeof(pagePath), ""%s/%s"", ""/path/to/root/of/wiki/files"", page); if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; // Added code below char pagePath[PATH_MAX]; snprintf(pagePath, sizeof(pagePath), ""%s/%s"", ""/path/to/root/of/wiki/files"", pages[i]->name); http_response_printf ( res , ""%s\\t%s\\n"" , pagePath , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The fixed code uses the snprintf() function to construct a full path to the page based on a given root directory. By restricting the path to the directory, the code is protected from any malicious attempts at traversing the file system.",1022,-92.95840319669641,-0.09095734167974208
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
	char * path_to_pages = ""/path/to/pages/"";	//the path where all pages are stored.
	if ( func != NULL && * func != '\\0' ) { 
		if ( ! strcmp ( func , ""page/get"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && ( access ( path_to_pages + page , R_OK ) == 0 ) ) { //getting the absolute path of the page
				http_response_printf ( res , ""%s"" , file_read ( path_to_pages + page ) ) ; //reading the page from absolute path
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""page/set"" ) ) { 
			char * wikitext = NULL , * page = NULL ; 
			if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
				file_write ( path_to_pages + page , wikitext ) ; //writing the page to absolute path
				http_response_printf ( res , ""success"" ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && ( unlink ( path_to_pages + page ) > 0 ) ) { //deleting the page from absolute path
				http_response_printf ( res , ""success"" ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && ( access ( path_to_pages + page , R_OK ) == 0 ) ) { //accessing the page from absolute path
				http_response_printf ( res , ""success"" ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
			WikiPageList * * pages = NULL ; 
			int n_pages , i ; 
			char * expr = http_request_param_get ( req , ""expr"" ) ; 
			if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
			pages = wiki_get_pages ( & n_pages , expr ) ; 
			if ( pages ) { 
				for ( i = 0 ; i < n_pages ; i ++ ) { 
					struct tm * pTm ; 
					char datebuf [ 64 ] ; 
					pTm = localtime ( & pages [ i ] -> mtime ) ; 
					strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
					http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
				} 
				http_response_send ( res ) ; 
				return ; 
			} 
		} 
	} 
	http_response_set_status ( res , 500 , ""Error"" ) ; 
	http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
	http_response_send ( res ) ; 
	return ; 
}",1130,-70.16797447761863,-0.06209555263506073
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call (HttpRequest *req, HttpResponse *res, char *func) {
    if (func != NULL && *func != '\0') {
        if (!strcmp(func, ""page/get"")) {
            char *page = http_request_param_get(req, ""page"");
            if (page == NULL) page = http_request_get_query_string(req);
            
            if (page && is_path_valid(page)) {
                char full_path[PATH_MAX];
                strcpy(full_path, ""/pages/"");
                strcat(full_path, page);
                
                if (access(full_path, R_OK) == 0) {
                    http_response_printf(res, ""%s"", file_read(full_path));
                    http_response_send(res);
                    return;
                }
            }
        } else if (!strcmp(func, ""page/set"")) {
            char *wikitext = NULL, *page = NULL;
            if (((wikitext = http_request_param_get(req, ""text"")) != NULL) && ((page = http_request_param_get(req, ""page"")) != NULL)) {
                char full_path[PATH_MAX];
                strcpy(full_path, ""/pages/"");
                strcat(full_path, page);

                if (is_path_valid(full_path)) {
                    file_write(full_path, wikitext);
                    http_response_printf(res, ""success"");
                    http_response_send(res);
                    return;
                }
            }
        } else if (!strcmp(func, ""page/delete"")) {
            char *page = http_request_param_get(req, ""page"");
            if (page == NULL) page = http_request_get_query_string(req);
            
            if (page && is_path_valid(page)) {
                char full_path[PATH_MAX];
                strcpy(full_path, ""/pages/"");
                strcat(full_path, page);

                if (unlink(full_path) > 0) {
                    http_response_printf(res, ""success"");
                    http_response_send(res);
                    return;
                }
            }
        } else if (!strcmp(func, ""page/exists"")) {
            char *page = http_request_param_get(req, ""page"");
            if (page == NULL) page = http_request_get_query_string(req);
            
            if (page && is_path_valid(page)) {
                char full_path[PATH_MAX];
                strcpy(full_path, ""/pages/"");
                strcat(full_path, page);

                if (access(full_path, R_OK) == 0) {
                    http_response_printf(res, ""success"");
                    http_response_send(res);
                    return;
                }
            }
        } else if (!strcmp(func, ""pages"") || !strcmp(func, ""search"")) {
            WikiPageList **pages = NULL;
            int n_pages, i;
            char *expr = http_request_param_get(req, ""expr"");
            if (expr == NULL) expr = http_request_get_query_string(req);
            pages = wiki_get_pages(&n_pages, expr);
            if (pages) {
                for (i = 0; i < n_pages; i++) {
                    struct tm *pTm;
                    char datebuf[64];
                    pTm = localtime(&pages[i]->mtime);
                    strftime(datebuf, sizeof(datebuf), ""%Y-%m-%d %H:%M"", pTm);
                    http_response_printf(res, ""%s\t%s\n"", pages[i]->name, datebuf);
                }
                http_response_send(res);
                return;
            }
        }
    }
    http_response_set_status(res, 500, ""Error"");
    http_response_printf(res, ""<html><body>Failed</body></html>\n"");
    http_response_send(res);
    return;
}

bool is_path_valid(char *path) {
    char root[6] = ""/pages/"";
    int i;
    for (i = 0; i < 6; i++) {
        if (root[i] != path[i]) {
            return false;
        }
    }
    return true;
}",1091,-68.9623308233205,-0.06321020240451009
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 

void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char sanitized_page[MAX_PATH_LENGTH]; if ( page == NULL ) page = http_request_get_query_string ( req ) ; sanitizePath(page, sanitized_page); if ( page && ( access ( sanitized_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( sanitized_page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; char sanitized_page[MAX_PATH_LENGTH]; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { sanitizePath(page, sanitized_page); file_write ( sanitized_page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char sanitized_page[MAX_PATH_LENGTH]; if ( page == NULL ) page = http_request_get_query_string ( req ) ; sanitizePath(page, sanitized_page); if ( page && ( unlink ( sanitized_page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char sanitized_page[MAX_PATH_LENGTH]; if ( page == NULL ) page = http_request_get_query_string ( req ) ; sanitizePath(page, sanitized_page); if ( page && ( access ( sanitized_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

//sanitizePath function
void sanitizePath(const char *path, char *newPath)
{
    int i;

    int len = strlen(path);
    if(len > MAX_PATH_LENGTH) 
    {
        return;
    }

    //remove ../ references
    for(i = 0; i < len - 1; i++)
    {
        if(path[i] == '.' && path[i + 1] == '.' && path[i + 2] == '/')
        {
            return;
        }
    }

    if(strstr(path, "".."") != NULL)
    {
        return;
    }

    //remove absolute paths if necessary
    if(path[0] == '/')
    {
        for(i = 0; i < len - 1; i++)
        {
            newPath[i] = path[i + 1];
        }
    }
    else
    {
        strcpy(newPath, path);
    }
}",1109,-115.47051121886746,-0.10412129054902386
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { if ( page && ( access ( page , R_OK ) == 0 ) ) { char * path = realpath ( page , NULL ) ; if ( path != NULL ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; free ( path ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL ; if ( page && wikitext && ( access ( page , W_OK ) == 0 ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * path = realpath ( page , NULL ) ; if ( page && path && ( unlink ( path ) > 0 ) ) { free ( path ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * path = realpath ( page , NULL ) ; if ( page && path && ( access ( path , R_OK ) == 0 ) ) { free ( path ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The code has been fixed by adding a call to realpath() before accessing the provided page variable. This function will normalize the given path so that it can only access files within the approved directory structure. Additionally, a call to realpath() has been added before the unlink() call.",757,-93.64367337635898,-0.12370366364116113
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char pathbuf[256]; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { //construct the path to the page, using only the page name snprintf(pathbuf, sizeof(pathbuf), ""/var/www/%s"", page); if (( access ( pathbuf , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( pathbuf ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char pathbuf[256]; //construct the path to the page, using only the page name snprintf(pathbuf, sizeof(pathbuf), ""/var/www/%s"", page); file_write ( pathbuf , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char pathbuf[256]; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { //construct the path to the page, using only the page name snprintf(pathbuf, sizeof(pathbuf), ""/var/www/%s"", page); if (( unlink ( pathbuf ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char pathbuf[256]; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { //construct the path to the page, using only the page name snprintf(pathbuf, sizeof(pathbuf), ""/var/www/%s"", page); if (( access ( pathbuf , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",922,-51.910013547804276,-0.05630153313210876
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
if ( func != NULL && * func != '\\0' ) {
if ( ! strcmp ( func , ""page/get"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page ) {
char path[MAX_PATH] = ""/path/to/directory/"";
strcat(path, page);
if ( access ( path , R_OK ) == 0 ) {
http_response_printf ( res , ""%s"" , file_read ( path ) ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""page/set"" ) ) {
char * wikitext = NULL , * page = NULL ;
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
char path[MAX_PATH] = ""/path/to/directory/"";
strcat(path, page);
file_write ( path , wikitext ) ;
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""page/delete"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page ) {
char path[MAX_PATH] = ""/path/to/directory/"";
strcat(path, page);
if ( unlink ( path ) > 0 ) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""page/exists"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page ) {
char path[MAX_PATH] = ""/path/to/directory/"";
strcat(path, page);
if ( access ( path , R_OK ) == 0 ) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
WikiPageList * * pages = NULL ;
int n_pages , i ;
char * expr = http_request_param_get ( req , ""expr"" ) ;
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
pages = wiki_get_pages ( & n_pages , expr ) ;
if ( pages ) {
for ( i = 0 ; i < n_pages ; i ++ ) {
struct tm * pTm ;
char datebuf [ 64 ] ;
pTm = localtime ( & pages [ i ] -> mtime ) ;
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
}
http_response_send ( res ) ;
return ;
}
}
}
http_response_set_status ( res , 500 , ""Error"" ) ;
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
http_response_send ( res ) ;
return ;
}",918,-24.84628956673237,-0.02706567490929452
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[1024]; snprintf(path, sizeof(path), ""%s/%s"", PAGE_ROOT, page); if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[1024]; snprintf(path, sizeof(path), ""%s/%s"", PAGE_ROOT, page); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[1024]; snprintf(path, sizeof(path), ""%s/%s"", PAGE_ROOT, page); if ( unlink ( path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[1024]; snprintf(path, sizeof(path), ""%s/%s"", PAGE_ROOT, page); if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",863,-22.385025764056294,-0.025938616180830005
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char * page; if ( ! strcmp ( func , ""page/get"" ) ) { page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * full_path = malloc (PATH_MAX + 1); realpath(page, full_path); if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; return ; } free(full_path); } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * full_path = malloc (PATH_MAX + 1); realpath(page, full_path); file_write ( full_path , wikitext ) ; free(full_path); http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * full_path = malloc (PATH_MAX + 1); realpath(page, full_path); if ( unlink ( full_path ) > 0 ) { free(full_path); http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * full_path = malloc (PATH_MAX + 1); realpath(page, full_path); if ( access ( full_path , R_OK ) == 0 ) { free(full_path); http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The vulnerability has been fixed by using the realpath() function to convert the page path into the full canonical path. The access() and unlink() functions are then called using the full canonical path to ensure that they are only being applied to the restricted directory. The malloc() function is used to allocate enough memory to store the full canonical path. The memory is then freed after the access() and unlink() functions have been called.",971,-91.10642505721545,-0.09382742024430014
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
	if ( func != NULL && * func != '\\0' ) { 
		if ( ! strcmp ( func , ""page/get"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && ( access ( page , R_OK ) == 0 ) ) { 
				// Check if the requested page is within the allowable directory
				if(strncmp(page, ""allowed/directory/"", 16) == 0) {
					http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
			} 
		} else if ( ! strcmp ( func , ""page/set"" ) ) { 
			char * wikitext = NULL , * page = NULL ; 
			if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
				// Check if the requested page is within the allowable directory 
				if(strncmp(page, ""allowed/directory/"", 16) == 0) {
					file_write ( page , wikitext ) ; 
					http_response_printf ( res , ""success"" ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
			} 
		} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && ( unlink ( page ) > 0 ) ) { 
				// Check if the requested page is within the allowable directory
				if(strncmp(page, ""allowed/directory/"", 16) == 0) {
					http_response_printf ( res , ""success"" ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
			} 
		} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page && ( access ( page , R_OK ) == 0 ) ) { 
				// Check if the requested page is within the allowable directory 
				if(strncmp(page, ""allowed/directory/"", 16) == 0) {
					http_response_printf ( res , ""success"" ) ; 
					http_response_send ( res ) ; 
					return ; 
				}
			} 
		} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
			WikiPageList * * pages = NULL ; 
			int n_pages , i ; 
			char * expr = http_request_param_get ( req , ""expr"" ) ; 
			if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
			pages = wiki_get_pages ( & n_pages , expr ) ; 
			if ( pages ) { 
				for ( i = 0 ; i < n_pages ; i ++ ) { 
					struct tm * pTm ; 
					char datebuf [ 64 ] ; 
					pTm = localtime ( & pages [ i ] -> mtime ) ; 
					strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
					// Check if the requested page is within the allowable directory 
					if(strncmp(pages[i]->name, ""allowed/directory/"", 16) == 0) {
						http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
					}
				} 
				http_response_send ( res ) ; 
				return ; 
			} 
		} 
	} 
	http_response_set_status ( res , 500 , ""Error"" ) ; 
	http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
	http_response_send ( res ) ; 
	return ; 
}",1297,-49.42579610508406,-0.03810778419821439
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { //Get the absolute path of the file char absPath[PATH_MAX]; realpath(page, absPath); //Verify that the path is in the expected directory if (strstr(absPath, ""webserver/data"") != NULL) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { //Get the absolute path of the file char absPath[PATH_MAX]; realpath(page, absPath); //Verify that the path is in the expected directory if (strstr(absPath, ""webserver/data"") != NULL) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Get the absolute path of the file char absPath[PATH_MAX]; realpath(page, absPath); //Verify that the path is in the expected directory if (strstr(absPath, ""webserver/data"") != NULL) { if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Get the absolute path of the file char absPath[PATH_MAX]; realpath(page, absPath); //Verify that the path is in the expected directory if (strstr(absPath, ""webserver/data"") != NULL) { if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; //Get the absolute path of the file char absPath[PATH_MAX]; realpath(pages[i]->name, absPath); //Verify that the path is in the expected directory if (strstr(absPath, ""webserver/data"") != NULL) { http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",1027,-47.935495984353764,-0.046675263860130246
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char page_path[MAX_PATH_SIZE] = ""./pages/""; // Create a new path string to be used with access() strcat(page_path, page); // Append the page name to the path string if ( access ( page_path , R_OK ) == 0 ) { // Use the new path string variable http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char page_path[MAX_PATH_SIZE] = ""./pages/""; // Create a new path string to be used with file_write() strcat(page_path, page); // Append the page name to the path string file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char page_path[MAX_PATH_SIZE] = ""./pages/""; // Create a new path string to be used with unlink() strcat(page_path, page); // Append the page name to the path string if ( unlink ( page_path ) > 0 ) { // Use the new path string variable http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char page_path[MAX_PATH_SIZE] = ""./pages/""; // Create a new path string to be used with access() strcat(page_path, page); // Append the page name to the path string if ( access ( page_path , R_OK ) == 0 ) { // Use the new path string variable http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char page_path[MAX_PATH_SIZE] = ""./pages/""; // Create a new path string to be used with http_response_printf() strcat(page_path, pages[i]->name); // Append the page name to the path string http_response_printf ( res , ""%s\\t%s\\n"" , page_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",1045,-64.01045892876884,-0.06125402768303238
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call(HttpRequest *req, HttpResponse *res, char *func) { 
if (func != NULL && *func != '\\0') { 
if (!strcmp(func, ""page/get"")) { 
char *page = http_request_param_get(req, ""page""); 
if (page == NULL) page = http_request_get_query_string(req); 
if (page && (access(page, R_OK) == 0)) { 
char *path = malloc(256); 
snprintf(path, 256, ""/path/to/www/%s"", page); 
http_response_printf(res, ""%s"", file_read(path)); 
http_response_send(res); 
free(path); 
return; 
} 
} else if (!strcmp(func, ""page/set"")) { 
char *wikitext = NULL, *page = NULL; 
if (((wikitext = http_request_param_get(req, ""text"")) != NULL) && ((page = http_request_param_get(req, ""page"")) != NULL)) { 
char *path = malloc(256); 
snprintf(path, 256, ""/path/to/www/%s"", page); 
file_write(path, wikitext); 
http_response_printf(res, ""success""); 
http_response_send(res); 
free(path); 
return; 
} 
} else if (!strcmp(func, ""page/delete"")) { 
char *page = http_request_param_get(req, ""page""); 
if (page == NULL) page = http_request_get_query_string(req); 
if (page) { 
char *path = malloc(256); 
snprintf(path, 256, ""/path/to/www/%s"", page); 
if (unlink(path) > 0) { 
http_response_printf(res, ""success""); 
http_response_send(res); 
free(path); 
return; 
} 
free(path); 
} 
} else if (!strcmp(func, ""page/exists"")) { 
char *page = http_request_param_get(req, ""page""); 
if (page == NULL) page = http_request_get_query_string(req); 
if (page) { 
char *path = malloc(256); 
snprintf(path, 256, ""/path/to/www/%s"", page); 
if (access(path, R_OK) == 0) { 
http_response_printf(res, ""success""); 
http_response_send(res); 
free(path); 
return; 
} 
free(path); 
} 
} else if (!strcmp(func, ""pages"") || !strcmp(func, ""search"")) { 
WikiPageList **pages = NULL; 
int n_pages, i; 
char *expr = http_request_param_get(req, ""expr""); 
if (expr == NULL) expr = http_request_get_query_string(req); 
pages = wiki_get_pages(&n_pages, expr); 
if (pages) { 
for (i = 0; i < n_pages; i++) { 
struct tm *pTm; 
char datebuf[64]; 
pTm = localtime(&pages[i]->mtime); 
strftime(datebuf, sizeof(datebuf), ""%Y-%m-%d %H:%M"", pTm); 
http_response_printf(res, ""%s\\t%s\\n"", pages[i]->name, datebuf); 
} 
http_response_send(res); 
return; 
} 
} 
} 
http_response_set_status(res, 500, ""Error""); 
http_response_printf(res, ""<html><body>Failed</body></html>\\n""); 
http_response_send(res); 
return; 
}",967,-40.5980519334761,-0.04198350768715212
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char path[PATH_MAX]; char * page; 

if ( ! strcmp ( func , ""page/get"" ) ) { page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if(page != NULL) { realpath(page, path); if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { realpath(page, path); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if(page != NULL) { realpath(page, path); if ( unlink ( path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if(page != NULL) { realpath(page, path); if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The fixed code addresses the vulnerability by using the realpath() function to expand any relative or non-absolute pathnames into an absolute pathname before passing it to the access() and unlink() functions. The realpath() function also resolves any 'path traversal' issues, such as those caused by '..' and '.' elements. This ensures that the access() and unlink() functions can only operate on files that are within the expected directory.",889,-114.28316713418,-0.12855249396420698
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
 void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char valid_page[MAX_PATH]; realpath(page, valid_page); if ( page && ( access ( valid_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( valid_page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char valid_page[MAX_PATH]; realpath(page, valid_page); file_write ( valid_page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char valid_page[MAX_PATH]; realpath(page, valid_page); if ( page && ( unlink ( valid_page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char valid_page[MAX_PATH]; realpath(page, valid_page); if ( page && ( access ( valid_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The fixed code resolves the CWE-22 vulnerability by using the realpath() function to obtain the absolute path of the page. It then passes this absolute path to the access(), unlink(), and file_write() functions instead of the user input. This prevents the user from providing a relative path which could lead to path traversal.",900,-70.16098441081306,-0.07795664934534784
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
	if ( func != NULL && * func != '\\0' ) { 
		if ( ! strcmp ( func , ""page/get"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page ) {
				char * path_file = wiki_get_page_file_path(page); 
				if ( access ( path_file , R_OK ) == 0 ) { 
					http_response_printf ( res , ""%s"" , file_read ( path_file ) ) ; 
					http_response_send ( res ) ; 
					return ; 
				} 
			} 
		} else if ( ! strcmp ( func , ""page/set"" ) ) { 
			char * wikitext = NULL , * page = NULL ; 
			if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
				char * path_file = wiki_get_page_file_path(page); 
				file_write ( path_file , wikitext ) ; 
				http_response_printf ( res , ""success"" ) ; 
				http_response_send ( res ) ; 
				return ; 
			} 
		} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page ) {
				char * path_file = wiki_get_page_file_path(page);
				if ( unlink ( path_file ) > 0 ) {
					http_response_printf ( res , ""success"" ) ; 
					http_response_send ( res ) ; 
					return ;
				}
			} 
		} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
			char * page = http_request_param_get ( req , ""page"" ) ; 
			if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
			if ( page ) {
				char * path_file = wiki_get_page_file_path(page);
				if ( access ( path_file , R_OK ) == 0 ) { 
					http_response_printf ( res , ""success"" ) ;
					http_response_send ( res ) ; 
					return ; 
				}
			}
		} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
			WikiPageList * * pages = NULL ; 
			int n_pages , i ; 
			char * expr = http_request_param_get ( req , ""expr"" ) ; 
			if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
			pages = wiki_get_pages ( & n_pages , expr ) ; 
			if ( pages ) { 
				for ( i = 0 ; i < n_pages ; i ++ ) { 
					struct tm * pTm ; 
					char datebuf [ 64 ] ; 
					pTm = localtime ( & pages [ i ] -> mtime ) ; 
					strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
					http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
				} 
				http_response_send ( res ) ; 
				return ; 
			} 
		} 
	} 
	http_response_set_status ( res , 500 , ""Error"" ) ; 
	http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
	http_response_send ( res ) ; 
	return ; 
}

char * wiki_get_page_file_path(char * page){
	return relative_path(wiki_root_path, page);
}

char * relative_path(char * root_path, char * page){
	//root_path is the path of the directory containing page files
	//page is the page file name
	//returns the full path of the file
	
	char * full_path = malloc(strlen(root_path) + strlen(page) + 2);//2 for 0 and /
	strcpy(full_path, root_path);
	strcat(full_path, ""/"");
	strcat(full_path, page);
	
	return full_path;
}",1356,-145.99346759455167,-0.1076647991110263
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filePath[256]; sprintf(filePath, ""%s%s"", getDir(), page); if ( page && ( access ( filePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char filePath[256]; sprintf(filePath, ""%s%s"", getDir(), page); file_write ( filePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filePath[256]; sprintf(filePath, ""%s%s"", getDir(), page); if ( page && ( unlink ( filePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filePath[256]; sprintf(filePath, ""%s%s"", getDir(), page); if ( page && ( access ( filePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } 

In the fixed code, the vulnerable access and unlink functions are replaced with a combination of a function to get a directory and sprintf to construct a path relative to that directory. This prevents the code from accessing or deleting files outside of the restricted directory.",893,-68.36211002815624,-0.0765533147011828
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char path[PATH_MAX] = ""pages""; if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && (access(path, R_OK ) == 0 ) && realpath(page, path) && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { if (realpath(page, path)) { file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && realpath(page, path) && ( access ( path , R_OK ) == 0 ) && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && realpath(page, path) && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
In the above fixed code, the vulnerability is fixed by adding a check for the real path of the provided page and only using the real path of the page for further validation. It also adds a check to make sure that the page is only accessed if it is in the restricted directory.",877,-101.53119320974434,-0.1157710298856834
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
if ( func != NULL && * func != '\\0' ) {
if ( ! strcmp ( func , ""page/get"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page ) {
char filePath[FILENAME_MAX];
snprintf (filePath, FILENAME_MAX, ""./pages/%s"", page);
if ( access ( filePath , R_OK ) == 0 ) {
http_response_printf ( res , ""%s"" , file_read ( filePath ) ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""page/set"" ) ) {
char * wikitext = NULL , * page = NULL ;
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
char filePath[FILENAME_MAX];
snprintf (filePath, FILENAME_MAX, ""./pages/%s"", page);
file_write ( filePath , wikitext ) ;
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""page/delete"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page ) {
char filePath[FILENAME_MAX];
snprintf (filePath, FILENAME_MAX, ""./pages/%s"", page);
if ( unlink ( filePath ) > 0 ) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""page/exists"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page ) {
char filePath[FILENAME_MAX];
snprintf (filePath, FILENAME_MAX, ""./pages/%s"", page);
if ( access ( filePath , R_OK ) == 0 ) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
WikiPageList * * pages = NULL ;
int n_pages , i ;
char * expr = http_request_param_get ( req , ""expr"" ) ;
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
pages = wiki_get_pages ( & n_pages , expr ) ;
if ( pages ) {
for ( i = 0 ; i < n_pages ; i ++ ) {
struct tm * pTm ;
char datebuf [ 64 ] ;
pTm = localtime ( & pages [ i ] -> mtime ) ;
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
}
http_response_send ( res ) ;
return ;
}
}
}
http_response_set_status ( res , 500 , ""Error"" ) ;
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
http_response_send ( res ) ;
return ;
}",954,-24.748987670438108,-0.025942335084316676
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
// directory that contains wiki pages 
const char *dir = “/usr/wikipages/”; 
if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
// append the directory to the page 
if ( page && ( access ( dir+page , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""%s"" , file_read ( dir+page ) ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
// append the directory to the page 
file_write ( dir+page , wikitext ) ; 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
// append the directory to the page 
if ( page && ( unlink ( dir+page ) > 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
// append the directory to the page 
if ( page && ( access ( dir+page , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
// append the directory to the page 
pages = wiki_get_pages ( & n_pages , dir+expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_send ( res ) ; 
return ; 
} 
} 
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
http_response_send ( res ) ; 
return ; 
}",947,-60.406390812649256,-0.06378710751071727
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char dir[1000]; getcwd(dir, sizeof(dir)); strcat(dir, ""\\pages\\""); strcat(dir, page); if (( access ( dir , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( dir ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char dir[1000]; getcwd(dir, sizeof(dir)); strcat(dir, ""\\pages\\""); strcat(dir, page); file_write ( dir , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char dir[1000]; getcwd(dir, sizeof(dir)); strcat(dir, ""\\pages\\""); strcat(dir, page); if ( ( unlink ( dir ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char dir[1000]; getcwd(dir, sizeof(dir)); strcat(dir, ""\\pages\\""); strcat(dir, page); if ( ( access ( dir , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The fixed code limits the pathname to the restricted directory ‘pages’ which prevents traversal beyond the directory. The code first gets the current working directory and then concatenates ‘pages’ and the page name to the directory. This is then used to check if the file is accessible and to perform file operations such as write, delete, etc.",961,-94.22850305114177,-0.09805255260264492
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Check if the page is within the allowed directory if ( page && ( access ( page , R_OK ) == 0 ) && (strstr(page, ""../"") == NULL)) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { // Check if the page is within the allowed directory if (page && (strstr(page, ""../"") == NULL)) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Check if the page is within the allowed directory if ( page && ( unlink ( page ) > 0 ) && (strstr(page, ""../"") == NULL)) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; // Check if the page is within the allowed directory if ( page && ( access ( page , R_OK ) == 0 ) && (strstr(page, ""../"") == NULL)) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; // Check if the page is within the allowed directory if (strstr(pages[i]->name, ""../"") == NULL) { http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",871,-27.30566124738511,-0.03134978329206098
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
    char* page;
    char* wikitext;
    char* expr;
    char* path;
    char* page_name;
    char datebuf [ 64 ] ; 
    WikiPageList * * pages = NULL ;
    int n_pages , i ;
    if ( func != NULL && * func != '\\0' ) {
        if ( ! strcmp ( func , ""page/get"" ) ) {
            page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            page_name = get_page_name_from_url(page);
            path = get_absolute_path(page_name);
            if ( page && ( access ( path , R_OK ) == 0 ) ) {
                http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; 
                free(page_name);
                free(path);
                return ;
            }
            
        } else if ( ! strcmp ( func , ""page/set"" ) ) {
            wikitext = http_request_param_get ( req , ""text"" ) ;
            page = http_request_param_get ( req , ""page"" ) ;
            page_name = get_page_name_from_url(page);
            path = get_absolute_path(page_name);
            if ( ( wikitext != NULL ) && ( page != NULL ) ) {
                file_write ( path , wikitext ) ; 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                free(page_name);
                free(path);
                return ;
            }
        } else if ( ! strcmp ( func , ""page/delete"" ) ) {
            page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            page_name = get_page_name_from_url(page);
            path = get_absolute_path(page_name);
            if ( page && ( unlink ( path ) > 0 ) ) {
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                free(page_name);
                free(path);
                return ;
            }
        } else if ( ! strcmp ( func , ""page/exists"" ) ) {
            page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            page_name = get_page_name_from_url(page);
            path = get_absolute_path(page_name);
            if ( page && ( access ( path , R_OK ) == 0 ) ) {
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                free(page_name);
                free(path);
                return ;
            }
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
            expr = http_request_param_get ( req , ""expr"" ) ;
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
            pages = wiki_get_pages ( & n_pages , expr ) ;
            if ( pages ) {
                for ( i = 0 ; i < n_pages ; i ++ ) {
                    struct tm * pTm ;
                    pTm = localtime ( & pages [ i ] -> mtime ) ;
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
                }
                http_response_send ( res ) ; 
                return ;
            }
        }
    }
    http_response_set_status ( res , 500 , ""Error"" ) ;
    http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
    http_response_send ( res ) ; 
    return ;
}

// Function to get the page name from the url
char* get_page_name_from_url(char* page) {
    char* page_name = malloc(sizeof(char)*strlen(page));
    if (page_name == NULL) {
        return NULL;
    }
    strcpy(page_name, page);
    return page_name;
}

// Function to get the absolute path for the page
char* get_absolute_path(char* page_name){
    char* path;
    char* root_dir = ""\\web\\wiki\\pages\\"";
    int path_length = strlen(root_dir) + strlen(page_name);
    path = malloc(sizeof(char)*path_length);
    if (path == NULL) {
        return NULL;
    }
    strcpy(path, root_dir);
    strcat(path, page_name);
    return path;
}",1300,-138.20653144994955,-0.1063127164999612
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { // Path Traversal Vulnerability Fix: // Check if the file is in the allowed directory if (strncmp(page, ALLOWED_DIRECTORY, strlen(ALLOWED_DIRECTORY)) == 0) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } else { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { // Path Traversal Vulnerability Fix: // Check if the file is in the allowed directory if (strncmp(page, ALLOWED_DIRECTORY, strlen(ALLOWED_DIRECTORY)) == 0) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } else { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { // Path Traversal Vulnerability Fix: // Check if the file is in the allowed directory if (strncmp(page, ALLOWED_DIRECTORY, strlen(ALLOWED_DIRECTORY)) == 0) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } else { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { // Path Traversal Vulnerability Fix: // Check if the file is in the allowed directory if (strncmp(page, ALLOWED_DIRECTORY, strlen(ALLOWED_DIRECTORY)) == 0) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } else { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; // Path Traversal Vulnerability Fix: // Check if the file is in the allowed directory if (strncmp(pages[i]->name, ALLOWED_DIRECTORY, strlen(ALLOWED_DIRECTORY)) == 0) { http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } else { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; } } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",1288,-37.9359468090411,-0.029453374851739985
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) 
page = http_request_get_query_string ( req ) ; 
if ( page ) { 
char pageName[MAX_PATH_SIZE];
snprintf(pageName, MAX_PATH_SIZE, ""./%s"", page);
if ( access ( pageName , R_OK ) == 0 ) { 
http_response_printf ( res , ""%s"" , file_read ( pageName ) ) ; 
http_response_send ( res ) ; 
return ; 
} 
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
char pageName[MAX_PATH_SIZE];
snprintf(pageName, MAX_PATH_SIZE, ""./%s"", page);
file_write ( pageName , wikitext ) ; 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) 
page = http_request_get_query_string ( req ) ; 
if ( page ) { 
char pageName[MAX_PATH_SIZE];
snprintf(pageName, MAX_PATH_SIZE, ""./%s"", page);
if ( unlink ( pageName ) > 0 ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) 
page = http_request_get_query_string ( req ) ; 
if ( page ) { 
char pageName[MAX_PATH_SIZE];
snprintf(pageName, MAX_PATH_SIZE, ""./%s"", page);
if ( access ( pageName , R_OK ) == 0 ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) 
expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\t%s\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_send ( res ) ; 
return ; 
} 
} 
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\n"" ) ; 
http_response_send ( res ) ; 
return ; 
}",1017,-34.644620464589806,-0.034065506848170904
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char filepath[FILENAME_MAX]; snprintf(filepath, FILENAME_MAX, ""/path/to/restricted/dir/%s"", page); if ( access ( filepath , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char filepath[FILENAME_MAX]; snprintf(filepath, FILENAME_MAX, ""/path/to/restricted/dir/%s"", page); file_write ( filepath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char filepath[FILENAME_MAX]; snprintf(filepath, FILENAME_MAX, ""/path/to/restricted/dir/%s"", page); if ( unlink ( filepath ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char filepath[FILENAME_MAX]; snprintf(filepath, FILENAME_MAX, ""/path/to/restricted/dir/%s"", page); if ( access ( filepath , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",901,-21.785164490288285,-0.024178872908200096
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char page_path[1024]; if (realpath(page, page_path) == NULL) { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return; } if ( access ( page_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char page_path[1024]; if (realpath(page, page_path) == NULL) { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return; } file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char page_path[1024]; if (realpath(page, page_path) == NULL) { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return; } if ( unlink ( page_path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char page_path[1024]; if (realpath(page, page_path) == NULL) { http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return; } if ( access ( page_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",1067,-18.90352267671884,-0.01771651609814324
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char * path_prefix = ""/opt/wiki/pages/"" ; char * page_path ; if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page_path = malloc ( strlen ( path_prefix ) + strlen ( page ) + 1 ) ; strcpy ( page_path , path_prefix ) ; strcat ( page_path , page ) ; if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; free ( page_path ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL , * page_path ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { page_path = malloc ( strlen ( path_prefix ) + strlen ( page ) + 1 ) ; strcpy ( page_path , path_prefix ) ; strcat ( page_path , page ) ; file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( page_path ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page_path = malloc ( strlen ( path_prefix ) + strlen ( page ) + 1 ) ; strcpy ( page_path , path_prefix ) ; strcat ( page_path , page ) ; if ( page && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( page_path ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; page_path = malloc ( strlen ( path_prefix ) + strlen ( page ) + 1 ) ; strcpy ( page_path , path_prefix ) ; strcat ( page_path , page ) ; if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( page_path ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { page_path = malloc ( strlen ( path_prefix ) + strlen ( pages [ i ] -> name ) + 1 ) ; strcpy ( page_path , path_prefix ) ; strcat ( page_path , pages [ i ] -> name ) ; struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , page_path , datebuf ) ; free ( page_path ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",1059,-34.47178600137072,-0.03255126156881088
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char basepath[512], filename[512]; realpath(page, basepath); if ( page && ( access ( filename , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( filename ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char basepath[512], filename[512]; realpath(page, basepath); file_write ( filename , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char basepath[512], filename[512]; realpath(page, basepath); if ( page && ( unlink ( filename ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char basepath[512], filename[512]; realpath(page, basepath); if ( page && ( access ( filename , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",829,-32.70895538829385,-0.03945591723557763
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
  if ( func != NULL && * func != '\\0' ) {
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;

      char * dir = getenv(""PWD"");
      char buffer[1024];
      snprintf(buffer, sizeof(buffer), ""%s/%s"", dir, page);

      if ( page && ( access ( buffer , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""%s"" , file_read ( buffer ) ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        char * dir = getenv(""PWD"");
        char buffer[1024];
        snprintf(buffer, sizeof(buffer), ""%s/%s"", dir, page);

        file_write ( buffer , wikitext ) ;
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;

      char * dir = getenv(""PWD"");
      char buffer[1024];
      snprintf(buffer, sizeof(buffer), ""%s/%s"", dir, page);

      if ( page && ( unlink ( buffer ) > 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;

      char * dir = getenv(""PWD"");
      char buffer[1024];
      snprintf(buffer, sizeof(buffer), ""%s/%s"", dir, page);

      if ( page && ( access ( buffer , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;

      char * dir = getenv(""PWD"");
      char buffer[1024];
      snprintf(buffer, sizeof(buffer), ""%s/%s"", dir, expr);

      pages = wiki_get_pages ( & n_pages , buffer ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
        }
        http_response_send ( res ) ;
        return ;
      }
    }
  }
  http_response_set_status ( res , 500 , ""Error"" ) ;
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
  http_response_send ( res ) ;
  return ;
}",1061,-36.3683997352006,-0.0342774738314803
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * abs_path = realpath ( page , NULL ) ; // Get absolute path of page if ( ! strcmp ( func , ""page/get"" ) ) { if ( abs_path && ( access ( abs_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( abs_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( abs_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { if ( abs_path && ( unlink ( abs_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { if ( abs_path && ( access ( abs_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; free ( abs_path ) ; }",710,-31.418792616960488,-0.044251820587268294
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
 if ( func != NULL && * func != '\\0' ) {
 if ( ! strcmp ( func , ""page/get"" ) ) {
 char * page = http_request_param_get ( req , ""page"" ) ;
 if ( page == NULL ) page = http_request_get_query_string ( req ) ;
 
 if ( page ) {
 char * sanitized_page = sanitize_path(page);
 if ( access ( sanitized_page , R_OK ) == 0 ) {
 http_response_printf ( res , ""%s"" , file_read ( page ) ) ;
 http_response_send ( res ) ;
 free(sanitized_page);
 return ;
 }
 free(sanitized_page);
 }
 } else if ( ! strcmp ( func , ""page/set"" ) ) {
 char * wikitext = NULL , * page = NULL ;
 if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) &&
 ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
 char * sanitized_page = sanitize_path(page);
 file_write ( sanitized_page , wikitext ) ;
 http_response_printf ( res , ""success"" ) ;
 http_response_send ( res ) ;
 free(sanitized_page);
 return ;
 }
 } else if ( ! strcmp ( func , ""page/delete"" ) ) {
 char * page = http_request_param_get ( req , ""page"" ) ;
 if ( page == NULL ) page = http_request_get_query_string ( req ) ;
 if ( page ) {
 char * sanitized_page = sanitize_path(page);
 if ( unlink ( sanitized_page ) > 0 ) {
 http_response_printf ( res , ""success"" ) ;
 http_response_send ( res ) ;
 free(sanitized_page);
 return ;
 }
 free(sanitized_page);
 }
 } else if ( ! strcmp ( func , ""page/exists"" ) ) {
 char * page = http_request_param_get ( req , ""page"" ) ;
 if ( page == NULL ) page = http_request_get_query_string ( req ) ;
 if ( page ) {
 char * sanitized_page = sanitize_path(page);
 if ( access ( sanitized_page , R_OK ) == 0 ) {
 http_response_printf ( res , ""success"" ) ;
 http_response_send ( res ) ;
 free(sanitized_page);
 return ;
 }
 free(sanitized_page);
 }
 } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
 WikiPageList * * pages = NULL ;
 int n_pages , i ;
 char * expr = http_request_param_get ( req , ""expr"" ) ;
 if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
 pages = wiki_get_pages ( & n_pages , expr ) ;
 if ( pages ) {
 for ( i = 0 ; i < n_pages ; i ++ ) {
 struct tm * pTm ;
 char datebuf [ 64 ] ;
 pTm = localtime ( & pages [ i ] -> mtime ) ;
 strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
 http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
 }
 http_response_send ( res ) ;
 return ;
 }
 }
 }
 http_response_set_status ( res , 500 , ""Error"" ) ;
 http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
 http_response_send ( res ) ;
 return ;
 }

char* sanitize_path(char *path) {
    // Check for ../ and ./
    if (strstr(path, ""../"") || strstr(path, ""./"")) {
        return NULL;
    }
    char* new_path = malloc(strlen(path)+1);
    strcpy(new_path, path);
    return new_path;
}",1045,-67.9671878279289,-0.06504037112720469
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","

void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
    if ( func != NULL && * func != '\\0' ) {
        if ( ! strcmp ( func , ""page/get"" ) ) {
            char * page = http_request_param_get ( req , ""page"" ) ;
            char * clean_path = clean_pathname(page);
            if ( clean_path && ( access ( clean_path , R_OK ) == 0 ) ) {
                http_response_printf ( res , ""%s"" , file_read ( clean_path ) ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/set"" ) ) {
            char * wikitext = NULL , * page = NULL ;
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
                char * clean_path = clean_pathname(page);
                file_write ( clean_path , wikitext ) ;
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/delete"" ) ) {
            char * page = http_request_param_get ( req , ""page"" ) ;
            char * clean_path = clean_pathname(page);
            if ( clean_path && ( unlink ( clean_path ) > 0 ) ) {
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/exists"" ) ) {
            char * page = http_request_param_get ( req , ""page"" ) ;
            char * clean_path = clean_pathname(page);
            if ( clean_path && ( access ( clean_path , R_OK ) == 0 ) ) {
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
            WikiPageList * * pages = NULL ;
            int n_pages , i ;
            char * expr = http_request_param_get ( req , ""expr"" ) ;
            char * clean_expr = clean_pathname(expr);
            pages = wiki_get_pages ( & n_pages , clean_expr ) ;
            if ( pages ) {
                for ( i = 0 ; i < n_pages ; i ++ ) {
                    struct tm * pTm ;
                    char datebuf [ 64 ] ;
                    pTm = localtime ( & pages [ i ] -> mtime ) ;
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
                }
                http_response_send ( res ) ;
                return ;
            }
        }
    }
    http_response_set_status ( res , 500 , ""Error"" ) ;
    http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
    http_response_send ( res ) ;
    return ;
}

// This new function could be used to clean the pathname before passing it to any file access method
char * clean_pathname(char * pathname) { 
    // Implement a check that pathname contains only valid characters 
    return pathname; 
}",923,-89.45641531287491,-0.09691919318838019
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char pagepath[256] = """"; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( strlcpy(pagepath, ""/path/to/wiki/restricted/pages/"", 256) < 256) ) { if ( strlcat(pagepath, page, 256) < 256 ) { if ( access ( pagepath , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char pagepath[256] = """"; if(strlcpy(pagepath, ""/path/to/wiki/restricted/pages/"", 256) < 256) { if ( strlcat(pagepath, page, 256) < 256 ) { file_write ( pagepath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char pagepath[256] = """"; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( strlcpy(pagepath, ""/path/to/wiki/restricted/pages/"", 256) < 256) ) { if ( strlcat(pagepath, page, 256) < 256 ) { if ( unlink ( pagepath ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char pagepath[256] = """"; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( strlcpy(pagepath, ""/path/to/wiki/restricted/pages/"", 256) < 256) ) { if ( strlcat(pagepath, page, 256) < 256 ) { if ( access ( pagepath , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The fixed code first defines a char array of length 256 and sets the array elements to the empty string. The code then uses this array to store the path of the restricted directory. It then uses the strlcpy and strlcat functions to add the page path to the restricted directory path, and uses the updated path for the access and unlink functions. This prevents the code from accessing any path outside of the restricted directory.",1058,-139.24836509341935,-0.1316147118085249
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char fixed_page[250] = """"; strncpy(fixed_page, page, 249); if ( page && ( access ( fixed_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( fixed_page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char fixed_page[250] = """"; strncpy(fixed_page, page, 249); file_write ( fixed_page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char fixed_page[250] = """"; strncpy(fixed_page, page, 249); if ( page && ( unlink ( fixed_page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char fixed_page[250] = """"; strncpy(fixed_page, page, 249); if ( page && ( access ( fixed_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; char fixed_expr[250] = """"; strncpy(fixed_expr, expr, 249); pages = wiki_get_pages ( & n_pages , fixed_expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The code has been fixed by adding an extra line of code before each function call to access, unlink, and wiki_get_pages that copies the input parameter to a fixed-length char array and then passes this to the function instead of the original parameter. This limits the length of the input parameter and the pathname that is used, and also prevents malicious users from passing path traversal strings to the functions.",955,-114.50343224495289,-0.11989888193188784
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char allowed_pages[16][255] = { ""index.html"", ""about.html"", ""contact.html"", ""page1.html"", ""page2.html"", ""page3.html"", ""page4.html"", ""page5.html"", ""page6.html"", ""page7.html"", ""page8.html"", ""page9.html"", ""page10.html"", ""page11.html"", ""page12.html"" }; int page_valid = 0; int i; if (page == NULL) page = http_request_get_query_string(req); for (i = 0; i < 16; i++) { if (!strcmp(page, allowed_pages[i])) { page_valid = 1; } } if (page_valid && (access(page, R_OK) == 0)) { http_response_printf(res, ""%s"", file_read(page)); http_response_send(res); return; } } else if (!strcmp(func, ""page/set"")) { char *wikitext = NULL, *page = NULL; if (((wikitext = http_request_param_get(req, ""text"")) != NULL) && ((page = http_request_param_get(req, ""page"")) != NULL)) { char allowed_pages[16][255] = { ""index.html"", ""about.html"", ""contact.html"", ""page1.html"", ""page2.html"", ""page3.html"", ""page4.html"", ""page5.html"", ""page6.html"", ""page7.html"", ""page8.html"", ""page9.html"", ""page10.html"", ""page11.html"", ""page12.html"" }; int page_valid = 0; int i; for (i = 0; i < 16; i++) { if (!strcmp(page, allowed_pages[i])) { page_valid = 1; } } if (page_valid && (file_write(page, wikitext) > 0)) { http_response_printf(res, ""success""); http_response_send(res); return; } } 

} else if (!strcmp(func, ""page/delete"")) { char *page = http_request_param_get(req, ""page""); char allowed_pages[16][255] = { ""index.html"", ""about.html"", ""contact.html"", ""page1.html"", ""page2.html"", ""page3.html"", ""page4.html"", ""page5.html"", ""page6.html"", ""page7.html"", ""page8.html"", ""page9.html"", ""page10.html"", ""page11.html"", ""page12.html"" }; int page_valid = 0; int i; if (page == NULL) page = http_request_get_query_string(req); for (i = 0; i < 16; i++) { if (!strcmp(page, allowed_pages[i])) { page_valid = 1; } } if (page_valid && (unlink(page) > 0)) { http_response_printf(res, ""success""); http_response_send(res); return; } 

} else if (!strcmp(func, ""page/exists"")) { char *page = http_request_param_get(req, ""page""); char allowed_pages[16][255] = { ""index.html"", ""about.html"", ""contact.html"", ""page1.html"", ""page2.html"", ""page3.html"", ""page4.html"", ""page5.html"", ""page6.html"", ""page7.html"", ""page8.html"", ""page9.html"", ""page10.html"", ""page11.html"", ""page12.html"" }; int page_valid = 0; int i; if (page == NULL) page = http_request_get_query_string(req); for (i = 0; i < 16; i++) { if (!strcmp(page, allowed_pages[i])) { page_valid = 1; } } if (page_valid && (access(page, R_OK) == 0)) { http_response_printf(res, ""success""); http_response_send(res); return; } 

} else if (!strcmp(func, ""pages"") || !strcmp(func, ""search"")) { WikiPageList **pages = NULL; int n_pages, i; char *expr = http_request_param_get(req, ""expr""); if (expr == NULL) expr = http_request_get_query_string(req); pages = wiki_get_pages(&n_pages, expr); if (pages) { for (i = 0; i < n_pages; i++) { struct tm *pTm; char datebuf[64]; pTm = localtime(&pages[i]->mtime); strftime(datebuf, sizeof(datebuf), ""%Y-%m-%d %H:%M"", pTm); http_response_printf(res, ""%s\t%s\n"", pages[i]->name, datebuf); } http_response_send(res); return; } } } 
http_response_set_status(res, 500, ""Error""); http_response_printf(res, ""<html><body>Failed</body></html>\n""); http_response_send(res); return; }",1292,-71.67434804927555,-0.05547550158612659
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char finalPath[256]; // create a path buffer of fixed size snprintf(finalPath, 256, ""./data/%s"", page); // prepend the data directory to the page name // use snprintf to prevent malicious input from exceeding buffer size if ( ( access ( finalPath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( finalPath ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char finalPath[256]; // create a path buffer of fixed size snprintf(finalPath, 256, ""./data/%s"", page); // prepend the data directory to the page name // use snprintf to prevent malicious input from exceeding buffer size file_write ( finalPath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char finalPath[256]; // create a path buffer of fixed size snprintf(finalPath, 256, ""./data/%s"", page); // prepend the data directory to the page name // use snprintf to prevent malicious input from exceeding buffer size if ( ( unlink ( finalPath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char finalPath[256]; // create a path buffer of fixed size snprintf(finalPath, 256, ""./data/%s"", page); // prepend the data directory to the page name // use snprintf to prevent malicious input from exceeding buffer size if ( ( access ( finalPath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",959,-76.06576028579352,-0.07931778966193276
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char * file_path = malloc(PATH_MAX); char * resolved_path = realpath(page, file_path); if (resolved_path) { http_response_printf ( res , ""%s"" , file_read ( resolved_path ) ) ; http_response_send ( res ) ; free(file_path); return ; } else { free(file_path); /* Error */ } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The code has been updated to use the realpath() function before accessing the file. This function resolves any symbolic links or relative path names and returns the full path name of the file in an absolute path format. This ensures that the code is not vulnerable to path traversal attacks as it only allows access to the files within the specified directory.",873,-96.6895656597583,-0.11075551621965442
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char abs_page[FILENAME_MAX]; realpath(page, abs_page); if ( abs_page && ( access ( abs_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( abs_page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char abs_page[FILENAME_MAX]; realpath(page, abs_page); file_write ( abs_page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char abs_page[FILENAME_MAX]; realpath(page, abs_page); if ( abs_page && ( unlink ( abs_page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char abs_page[FILENAME_MAX]; realpath(page, abs_page); if ( abs_page && ( access ( abs_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

The vulnerability has been fixed by using the realpath() method to get the absolute path of the page name provided and using the absolute path for file system operations.",877,-45.593230773106484,-0.05198772037982495
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * sanitized; sanitized = sanitize_pathname(page); if ( sanitized && ( access ( sanitized , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( sanitized ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * sanitized; sanitized = sanitize_pathname(page); file_write ( sanitized , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * sanitized; sanitized = sanitize_pathname(page); if ( sanitized && ( unlink ( sanitized ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * sanitized; sanitized = sanitize_pathname(page); if ( sanitized && ( access ( sanitized , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

// The function sanitize_pathname() should be implemented with code that restricts path traversal.",846,-48.14952769617083,-0.05691433533826339
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { //replace the relative path with an absolute path. char absolute_path[MAX_PATH]; realpath(page, absolute_path); http_response_printf ( res , ""%s"" , file_read ( absolute_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { //replace the relative path with an absolute path. char absolute_path[MAX_PATH]; realpath(page, absolute_path); file_write ( absolute_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { //replace the relative path with an absolute path. char absolute_path[MAX_PATH]; realpath(page, absolute_path); if (unlink(absolute_path) > 0) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { //replace the relative path with an absolute path. char absolute_path[MAX_PATH]; realpath(page, absolute_path); if (access(absolute_path, R_OK) == 0) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; //replace the relative path with an absolute path. char absolute_path[MAX_PATH]; realpath(pages[i]->name, absolute_path); http_response_printf ( res , ""%s\\t%s\\n"" , absolute_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
In the fixed code, the vulnerability is fixed by replacing the relative paths with absolute paths using the realpath() API. This prevents malicious users from changing the directory using the relative path, thus preventing the path traversal attack.",970,-72.64489713110797,-0.07489164652691543
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char page [ 256 ] ; memset ( page , 0 , sizeof ( page ) ) ; strncpy ( page , http_request_param_get ( req , ""page"" ) , sizeof ( page ) ) ; if ( page == NULL ) { strncpy ( page , http_request_get_query_string ( req ) , sizeof ( page ) ) ; } if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , page [ 256 ] ; memset ( page , 0 , sizeof ( page ) ) ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( strncpy ( page , http_request_param_get ( req , ""page"" ) , sizeof ( page ) ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char page [ 256 ] ; memset ( page , 0 , sizeof ( page ) ) ; strncpy ( page , http_request_param_get ( req , ""page"" ) , sizeof ( page ) ) ; if ( page == NULL ) { strncpy ( page , http_request_get_query_string ( req ) , sizeof ( page ) ) ; } if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char page [ 256 ] ; memset ( page , 0 , sizeof ( page ) ) ; strncpy ( page , http_request_param_get ( req , ""page"" ) , sizeof ( page ) ) ; if ( page == NULL ) { strncpy ( page , http_request_get_query_string ( req ) , sizeof ( page ) ) ; } if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char expr [ 256 ] ; memset ( expr , 0 , sizeof ( expr ) ) ; strncpy ( expr , http_request_param_get ( req , ""expr"" ) , sizeof ( expr ) ) ; if ( expr == NULL ) { strncpy ( expr , http_request_get_query_string ( req ) , sizeof ( expr ) ) ; } pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

In the fixed code, the input obtained from ""page"" and ""expr"" parameters are first assigned to local variables that have a length limit. This prevents malicious inputs from traversing the directory tree and accessing files outside the intended directory.",975,-83.53567380686881,-0.08567761416089109
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { // Check if the requested page is within the allowed directory. char pagePath[2048] = {0}; snprintf(pagePath, sizeof(pagePath), ""/allowed/directory/%s"", page); if ( access ( pagePath , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { // Check if the requested page is within the allowed directory. char pagePath[2048] = {0}; snprintf(pagePath, sizeof(pagePath), ""/allowed/directory/%s"", page); file_write ( pagePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { //Check if the requested page is within the allowed directory. char pagePath[2048] = {0}; snprintf(pagePath, sizeof(pagePath), ""/allowed/directory/%s"", page); if ( unlink ( pagePath ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { //Check if the requested page is within the allowed directory. char pagePath[2048] = {0}; snprintf(pagePath, sizeof(pagePath), ""/allowed/directory/%s"", page); if ( access ( pagePath , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",935,-41.48767059080651,-0.04437184020407113
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[256]; 
realpath(page, path); 
if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[256]; 
realpath(page, path); 
file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[256]; 
realpath(page, path); 
if ( page && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[256]; 
realpath(page, path); 
if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char path[256]; 
realpath(pages[i]->name, path); 
http_response_printf ( res , ""%s\\t%s\\n"" , path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",828,-19.569738308168503,-0.0236349496475465
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[PATH_MAX]; 
snprintf(path, PATH_MAX, ""/wiki/pages/%s"", page); 
if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[PATH_MAX]; 
snprintf(path, PATH_MAX, ""/wiki/pages/%s"", page); 
file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[PATH_MAX]; 
snprintf(path, PATH_MAX, ""/wiki/pages/%s"", page); 
if ( page && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[PATH_MAX]; 
snprintf(path, PATH_MAX, ""/wiki/pages/%s"", page); 
if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",868,-21.759783545651032,-0.025068875052593354
