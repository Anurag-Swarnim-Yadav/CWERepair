Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched || bytes_matched >= input_forwards_size || bytes_matched >= input_backwards_size ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }

The fixed code checks the bytes_matched",1000,-19.074486422277424,-0.019074486422277423
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop && bytes_matched < max_bytes_matched ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max && bytes_matched + i < max_bytes_matched; i ++ ) { next_input = input + i * input_incr ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",978,-13.663162946067505,-0.013970514259782725
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS && input_backwards_size > 0 ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS && input_backwards_size > 0) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched || bytes_matched < 0 ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched || bytes_matched + i < 0) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",1000,-16.17094452457096,-0.01617094452457096
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { if (sp >= MAX_FAST_RE_STACK) { break; } sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",986,-10.26664452769984,-0.010412418385091117
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; //added code to prevent out of bounds read if(input < input_data || input > (input_data + input_forwards_size)) { if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS; } bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; //added code to prevent out of bounds read if(next_input < input_data || next_input > (input_data + input_forwards_size)) { break; } if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr *",1000,-33.87758558328931,-0.03387758558328931
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; int max_input_forwards_size; int max_input_backwards_size;  max_input_forwards_size = (int) input_forwards_size; max_input_backwards_size = (int) input_backwards_size; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? max_input_backwards_size : max_input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; if ( (flags & RE_FLAGS_BACKWARDS ? next_input < input_data : next_input > input_data + max_input_forwards_size) || (flags & RE_FLAGS_BACKWARDS ? next_input > input_data + max_input_backwards_size : next_input < input_data) ) { break; }",1000,-31.067905524864432,-0.031067905524864433
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { // Check if the value of ip is within the bounds of the codestack if (ip >= code+MAX_FAST_RE_STACK) break; if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { // Check if the value of sp is within the bounds of the codestack if (sp >= MAX_FAST_RE_STACK) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if (",1000,-39.87516460921678,-0.03987516460921678
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * verify_ip ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; verify_ip = ip;  // Added for CWE-125
switch ( * ip ) { case RE_OPCODE_LITERAL : if ( verify_ip + 2 > code + input_forwards_size && verify_ip + 2 < code + input_forwards_size + input_backwards_size) { // Added for CWE-125
 if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; }
}
else { // Added for CWE-125
  return -1; // Added for CWE-125
}
 break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( verify_ip + 3 > code + input_forwards_size && verify_ip + 3 < code + input_forwards_size + input_backwards_size) { // Added for CWE-125
if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } 
}
else { // Added for CWE-125
  return -1; // Added for CWE-125
}
break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; if (verify_ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) > code + input_forwards_size && verify_ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) < code + input_forwards_size + input_backwards_size) { // Added for CWE-125
for ( i = repeat_any_args -> min + 1 ; i <=",1000,-76.50995922244253,-0.07650995922244254
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { // Added condition to check if ip is still within bounds of code array if ( ip >= code + max_bytes_matched ) { break; } if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",998,-26.968641939517745,-0.027022687314146036
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS && max_bytes_matched > 0) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",976,-5.691876879614819,-0.005831841065179118
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop && bytes_matched < max_bytes_matched) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",964,-7.021426217745845,-0.007283637155338014
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:"," 
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL && bytes_matched < max_bytes_matched ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",979,-9.119205423578002,-0.009314816571581208
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { if (bytes_matched <= max_bytes_matched){ //Fixed code FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return",1000,-16.174659226746467,-0.016174659226746466
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) { if (input_backwards_size == 0) { //Added if statement to check if input_backwards_size is 0 before decrementing input assert ( FALSE ); // added assert statement to prevent out of bounds read } else { input -- ; } } code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } }",1000,-50.06548077562999,-0.05006548077562999
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; if ( max_bytes_matched > MAX_FAST_RE_STACK ) return -1; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",990,-10.442818870009416,-0.0105483018888984
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:"," 
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) { if ( bytes_matched >= 0 && bytes_matched <= max_bytes_matched ) { * matches = bytes_matched ; } else { * matches = - 1 ; } } return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",1000,-15.628827665062174,-0.015628827665062173
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched || bytes_matched < 0) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }

The vulnerability in the original code is that there is no check that the number of bytes matched is greater than or equal to",1000,-26.198669079696757,-0.026198669079696757
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched || bytes_matched < 0 ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { if (i < 0) break; next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",982,-12.146229705391631,-0.012368869353759299
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop && bytes_matched < max_bytes_matched ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i > max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",964,-6.832910673561102,-0.007088081611577907
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; int max_input_size ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; max_input_size = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( bytes_matched >= max_input_size || * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( bytes_matched >= max_input_size || ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : if ( bytes_matched >= max_input_size ) { break; } bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( bytes_matched + i >= max_input_size ){ break; } if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } }",1000,-29.87725422009944,-0.02987725422009944
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : if (input_forwards_size < 2 || input_backwards_size < 2) { stop = TRUE; break; } value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
The code has",1000,-16.879486798926237,-0.016879486798926237
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; int input_size; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : input_size = flags & RE_FLAGS_BACKWARDS ? (int) input_backwards_size : (int)input_forwards_size; if(bytes_matched >= input_size) {stop = TRUE;} else { bytes_matched ++ ; input += input_incr ; ip += 1 ; } break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert (",1000,-26.37550738024373,-0.02637550738024373
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( bytes_matched + 1 <= max_bytes_matched && * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( bytes_matched + 1 <= max_bytes_matched && ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i > max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; } 
The vulnerability has been fixed by",1000,-16.14059161461651,-0.01614059161461651
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 && sp < MAX_FAST_RE_STACK ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",980,-5.065710333353797,-0.00516909217689163
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL: if ( bytes_matched + 1 <= max_bytes_matched && * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( bytes_matched + 1 <= max_bytes_matched && ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i > max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",992,-17.73430578594407,-0.017877324380992005
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS && max_bytes_matched > 0 ) input -- ; //added check to avoid out-of-bounds read code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; // added check to avoid out-of-bounds read if (next_input >= input_data && next_input < input_data + max_bytes_matched){  if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert (",1000,-29.842223665270346,-0.029842223665270347
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 && sp < MAX_FAST_RE_STACK ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop && sp < MAX_FAST_RE_STACK ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",992,-7.364390919883379,-0.007423781169237277
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL && bytes_matched <= max_bytes_matched) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",978,-5.8759902820724035,-0.00600817002256892
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL && bytes_matched <= max_bytes_matched ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",978,-5.399670599842565,-0.005521135582661109
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; if (sp >= MAX_FAST_RE_STACK) {return -4;} code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",987,-11.287376950479374,-0.011436045542532294
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched || bytes_matched < 0) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched || bytes_matched + i < 0) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }

The vulnerability has been fixed by adding a check to make sure that bytes_matched",1000,-14.275966204063685,-0.014275966204063685
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS && input_backwards_size > 0 ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",977,-5.9334451635998935,-0.006073127086591498
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { //Added check on maximum stack size to prevent out-of-bounds read if (sp >= MAX_FAST_RE_STACK) return -4; if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS",1000,-25.434243273518632,-0.025434243273518634
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL && bytes_matched < max_bytes_matched ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",978,-6.407330852350204,-0.006551463039212887
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { if (bytes_matched < max_bytes_matched) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",982,-8.004785753569053,-0.008151512987341195
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop && bytes_matched < max_bytes_matched) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",964,-6.962244238721443,-0.00722224506091436
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; 
uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; 
uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; 
int matches_stack [ MAX_FAST_RE_STACK ] ; 
uint8_t * ip = code ; 
uint8_t * input = input_data ; 
uint8_t * next_input ; 
uint8_t * next_opcode ; 
uint8_t mask ; 
uint8_t value ; 
int i ; 
int stop ; 
int input_incr ; 
int sp = 0 ; 
int bytes_matched ; 
int max_bytes_matched ; 
max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; 
input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; 
if ( flags & RE_FLAGS_BACKWARDS ) 
    input -- ; 
code_stack [ sp ] = code ; 
input_stack [ sp ] = input ; 
matches_stack [ sp ] = 0 ; 
sp ++ ; 
while ( sp > 0 ) { 
    sp -- ; 
    ip = code_stack [ sp ] ; 
    input = input_stack [ sp ] ; 
    bytes_matched = matches_stack [ sp ] ; 
    stop = FALSE ; 
    while ( ! stop ) { 
        if ( * ip == RE_OPCODE_MATCH ) { 
            if ( flags & RE_FLAGS_EXHAUSTIVE ) { 
                FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; 
                break ; 
            } else { 
                if ( matches != NULL ) {
                    if(bytes_matched < max_bytes_matched){
                        * matches = bytes_matched ; 
                        return ERROR_SUCCESS ; 
                    }
                }
            } 
        } 
        if ( bytes_matched >= max_bytes_matched ) break ; 
        switch ( * ip ) { 
            case RE_OPCODE_LITERAL : 
                if ( * input == * ( ip + 1 ) ) { 
                    bytes_matched ++ ; 
                    input += input_incr ; 
                    ip += 2 ; 
                } else { 
                    stop = TRUE ; 
                } 
                break ; 
            case RE_OPCODE_MASKED_LITERAL : 
                value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; 
                mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; 
                if ( ( * input & mask ) == value ) { 
                    bytes_matched ++ ; 
                    input += input_incr ; 
                    ip += 3 ; 
                } else { 
                    stop = TRUE ; 
                } 
                break ; 
            case RE_OPCODE_ANY : 
                bytes_matched ++ ; 
                input += input_incr ; 
                ip += 1 ; 
                break ; 
            case RE_OPCODE_REPEAT_ANY_UNGREEDY : 
                repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; 
                next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; 
                for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { 
                    next_input = input + i * input_incr ; 
                    if ( bytes_matched + i >= max_bytes_",1000,-26.8348469915118,-0.0268348469915118
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : //Check for buffer overflow if((ip + 1) + sizeof(int16_t) > code + max_bytes_matched) { 
    stop = TRUE; 
    break; 
} 
value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : //Check for buffer overflow 
if ( ( ip + 1 ) + sizeof ( RE_REPEAT_ANY_ARGS ) > code + max_bytes_matched ) { 
    stop = TRUE ; 
    break ; 
} 
repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++",1000,-49.29381372668739,-0.04929381372668739
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; if ( max_bytes_matched < 0 || max_bytes_matched > input_backwards_size + input_forwards_size ) { max_bytes_matched = input_backwards_size + input_forwards_size; } code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } }",1000,-15.176442556241094,-0.015176442556241093
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : if ( ( ip + 2 ) <= ( code + MAX_FAST_RE_STACK ) ) { value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; if ( ( next_opcode + MAX_FAST_RE_STACK ) < ( code_stack + MAX_FAST_RE_STACK ) ) { code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default",1000,-26.951071652739593,-0.02695107165273959
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","

int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { if (bytes_matched <= input_forwards_size && bytes_matched <=input_backwards_size) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { stop = TRUE; } } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS",1000,-21.651022606793806,-0.021651022606793805
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) { if (input == 0) { // Added line return -1; } input -- ; } // Added line code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",988,-18.974638058090818,-0.019205099249079774
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; uint8_t max_ip_value;  //added
int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; max_ip_value = ip + MAX_FAST_RE_STACK; //added 
while ( sp > 0 && ip <= max_ip_value) { //modified 
 sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches !=",1000,-36.528547589705425,-0.036528547589705425
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { if ( bytes_matched <= max_bytes_matched ) { // added line FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",985,-16.584721809197003,-0.016837281024565484
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec(uint8_t *code, uint8_t *input_data, size_t input_forwards_size, size_t input_backwards_size, int flags, RE_MATCH_CALLBACK_FUNC callback, void *callback_args, int *matches)
{
    RE_REPEAT_ANY_ARGS *repeat_any_args;
    uint8_t *code_stack[MAX_FAST_RE_STACK];
    uint8_t *input_stack[MAX_FAST_RE_STACK];
    int matches_stack[MAX_FAST_RE_STACK];
    uint8_t *ip = code;
    uint8_t *input = input_data;
    uint8_t *next_input;
    uint8_t *next_opcode;
    uint8_t mask;
    uint8_t value;
    int i;
    int stop;
    int input_incr;
    int sp = 0;
    int bytes_matched;
    int max_bytes_matched;
    max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? (int)input_backwards_size : (int)input_forwards_size;
    input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;
    if (flags & RE_FLAGS_BACKWARDS)
        input--;
    code_stack[sp] = code;
    input_stack[sp] = input;
    matches_stack[sp] = 0;
    sp++;
    while (sp > 0)
    {
        sp--;
        ip = code_stack[sp];
        input = input_stack[sp];
        bytes_matched = matches_stack[sp];
        stop = FALSE;
        while (!stop)
        {
            if (*ip == RE_OPCODE_MATCH)
            {
                if (flags & RE_FLAGS_EXHAUSTIVE)
                {
                    FAIL_ON_ERROR(callback(flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data, bytes_matched, flags, callback_args));
                    break;
                }
                else
                {
                    if (matches != NULL && bytes_matched <= max_bytes_matched) // Check added
                        *matches = bytes_matched;
                    return ERROR_SUCCESS;
                }
            }
            if (bytes_matched >= max_bytes_matched)
                break;
            switch (*ip)
            {
            case RE_OPCODE_LITERAL:
                if (*input == *(ip + 1))
                {
                    bytes_matched++;
                    input += input_incr;
                    ip += 2;
                }
                else
                {
                    stop = TRUE;
                }
                break;
            case RE_OPCODE_MASKED_LITERAL:
                value = *(int16_t *)(ip + 1) & 0xFF;
                mask = *(int16_t *)(ip + 1) >> 8;
                if ((*input & mask) == value)
                {
                    bytes_matched++;
                    input += input_incr;
                    ip += 3;
                }
                else
                {
                    stop = TRUE;
                }
                break;
            case RE_OPCODE_ANY:
                bytes_matched++;
                input += input_incr;
                ip += 1;
                break;
            case RE_OPCODE_REPEAT_ANY_UNGREEDY:
                repeat_any_args = (RE_REPEAT_ANY_ARGS *)(ip + 1);
                next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);
                for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)
                {
                    next_input = input + i * input_incr;
                    if (bytes_matched + i >= max_bytes_matched)
                        break;
                    if (*(next_opcode) != RE_OPCODE_LITERAL || (*(next_opcode) == RE_OPCODE_LITERAL && *",1000,-19.713536324431374,-0.019713536324431374
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { if (bytes_matched >= 0 && bytes_matched <= max_bytes_matched) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { break; } } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",993,-10.536082971652398,-0.010610355459871499
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop && bytes_matched < max_bytes_matched) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max && bytes_matched + i < max_bytes_matched; i ++ ) { next_input = input + i * input_incr ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }",960,-8.333466127701243,-0.008680693883022127
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; if ( max_bytes_matched > MAX_FAST_RE_STACK ) max_bytes_matched = MAX_FAST_RE_STACK; //Add condition to avoid out-of-bounds read code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL )",1000,-22.28015125370378,-0.02228015125370378
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched || bytes_matched < 0) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }

The code was fixed by adding a check for bytes_matched being less than 0 to the if statement in the while loop",1000,-21.089984548895025,-0.021089984548895026
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
Fixed code:","
int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( ip - code < sizeof(code) && * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( next_opcode - code < sizeof(code) && * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
The vulnerability in the original code was that it did",1000,-21.999511740088682,-0.02199951174008868
