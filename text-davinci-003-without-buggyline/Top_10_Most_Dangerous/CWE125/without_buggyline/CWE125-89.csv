Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; len = expr_end - expr_start ; o = PyUnicode_DecodeUTF8 ( expr_start , len , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len && i < expr_end - expr_start; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",517,-11.078233381706877,-0.021427917566164172
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","

static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { 
    int all_whitespace = 1 ; 
    int kind ; 
    void * data ; 
    PyCompilerFlags cf ; 
    mod_ty mod ; 
    char * str ; 
    PyObject * o , * fstring_name ; 
    Py_ssize_t len ; 
    Py_ssize_t i ; 
    
    //Check if the length of expression is greater than 0
    if(expr_end - expr_start <= 0) {
        ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; 
        return NULL ; 
    }
    
    assert ( expr_end >= expr_start ) ; 
    assert ( * ( expr_start - 1 ) == '{' ) ; 
    assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; 
    o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; 
    if ( o == NULL ) return NULL ; 
    len = PyUnicode_GET_LENGTH ( o ) ; 
    kind = PyUnicode_KIND ( o ) ; 
    data = PyUnicode_DATA ( o ) ; 
    for ( i = 0 ; i < len ; i ++ ) { 
        if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { 
            all_whitespace = 0 ; 
            break ; 
        } 
    } 
    Py_DECREF ( o ) ; 
    if ( all_whitespace ) { 
        ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; 
        return NULL ; 
    } 
    len = expr_end - expr_start ; 
    str = PyMem_RawMalloc ( len + 3 ) ; 
    if ( str == NULL ) return NULL ; 
    str [ 0 ] = '(' ; 
    memcpy ( str + 1 , expr_start , len ) ; 
    str [ len + 1 ] = ')' ; 
    str [ len + 2 ] = 0 ; 
    cf . cf_flags = PyCF_ONLY_AST ; 
    fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; 
    mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; 
    Py_DECREF ( fstring_name ) ; 
    PyMem_RawFree ( str ) ; 
    if ( ! mod ) return NULL ; 
    return mod -> v . Expression . body ; 
}",706,-25.317697982590563,-0.0358607620150008
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:"," 
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; if ( expr_end < expr_start ) { ast_error ( c , n , ""f-string: expression beginning is higher than expression end"" ) ; return NULL ; } 
if ( * ( expr_start - 1 ) != '{' ) { ast_error ( c , n , ""f-string: expression must start with '{'"" ) ; return NULL ; } 
if ( * expr_end != '}' && * expr_end != '!' && * expr_end != ':' ) { ast_error ( c , n , ""f-string: expression must end with '}', '!' or ':'"" ) ; return NULL ; } 
o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",605,-31.565117282957875,-0.052173747575136986
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; if ( expr_end > expr_start ) { assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; if ( len + 3 > 0 ) { str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: Invalid expression"" ) ; return NULL ; } }",547,-18.89746402622168,-0.034547466227096306
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end >= expr_start) { o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; if (len > 0) { str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",585,-13.807359589262095,-0.02360232408420871
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; if (len > 0){ for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } }}else { all_whitespace = 0; } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",530,-17.326755371926954,-0.032691991267786706
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; if (len == 0) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",544,-6.379745353084129,-0.011727473075522295
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end > expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( i < len - 1 && ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",519,-7.7089994760699145,-0.014853563537706964
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end > expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len && i + 1 < len; i ++ ) { // Added condition i + 1 < len to fix the vulnerability if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",531,-19.21980762133694,-0.03619549457878896
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","

static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; // Check the expression length before decoding if (expr_end - expr_start > 0) { o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",561,-20.61142818490979,-0.03674051369859143
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end > expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { // Fixed the vulnerability if ( i < len && ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",521,-17.24092964609652,-0.033091995481951096
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; // Check if the end of the expression exceeds the start assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; // Check that the end of the expression is within the array bounds if (expr_end >= c->c_arena->size) { ast_error(c, n, ""f-string: expression out of bounds""); return NULL; } o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",575,-47.38785806689146,-0.08241366620328949
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * expr_start == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( i >= 0 && i < len && ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",517,-11.66582942748535,-0.022564466977727952
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; len = expr_end - expr_start ; 
if(len < 0){
ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ;
}
o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; 
if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; 
if ( ! mod ) return NULL ; 
return mod -> v . Expression . body ;
}",565,-33.84835863126568,-0.05990859934737289
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; if ( expr_end < expr_start ) return NULL; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",515,-8.936188738463303,-0.017351822793132625
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start > 0) { o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",553,-5.932464051041477,-0.010727783094107554
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end > expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( i < len && ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; if ( len > 0 ) { str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error(c, n, ""f-string: empty expression not allowed"") ; return NULL ; } 
}",552,-21.79686392099344,-0.03948707232064029
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; // Check boundary length of expr_start before decoding o = PyUnicode_DecodeUTF8 ( expr_start , (expr_end - expr_start >= 0) ? (expr_end - expr_start) : 0, NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",539,-31.56362031825813,-0.05855959242719505
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_SIZE ( o ) ; // Changed from GET_LENGTH to GET_SIZE kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { // Added check for i < len if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",530,-22.03193709787132,-0.04156969263749306
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start > 0) { o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",553,-5.882336682407416,-0.010637136857879596
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end > expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; if (len == 0) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",544,-7.47078763045195,-0.01373306549715432
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; if (expr_start - 1 < 0) { return NULL; } assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",528,-9.726425805285418,-0.018421260994858746
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if(expr_end - expr_start > 0){  o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",553,-12.090911758747229,-0.02186421656192989
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","

static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start > 0) { o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",554,-7.446611064742338,-0.013441536217946458
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; if ( len > 0 ) { data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ((str == NULL) || (len <= 0)) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",527,-23.377811854248215,-0.04436017429648618
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start == 0) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",550,-6.1224808155391255,-0.011131783300980228
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","

static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; if ( expr_end < expr_start ) { ast_error(c, n, ""f-string: invalid expression boundaries"") ; return NULL ; } assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; if (len > 0) { str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error(c, n, ""f-string: invalid expression boundaries"") ; return NULL ; } }",568,-22.834451823210237,-0.04020149968875042
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end > expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( i < len && ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",517,-5.62731789477424,-0.010884560724901819
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","

static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start > 0) { o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",554,-7.451071863044433,-0.013449588200441214
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; len = expr_end - expr_start ; if ( len > 0 ) { o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",547,-10.284507041855154,-0.018801658211801013
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","

static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; if (expr_end < expr_start) { ast_error(c, n, ""f-string: Out-of-bounds read detected.""); return NULL; } assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",541,-13.531843368476359,-0.025012649479623585
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start > 0) { o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",553,-8.86232048292644,-0.01602589599082539
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start == 0) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",550,-6.106394799880285,-0.011102535999782337
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if ( expr_end - expr_start < 1 ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; o = PyUnicode_DecodeUTF8 ( expr_start , len , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",544,-12.116610176636698,-0.022273180471758636
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; // Add check to ensure expr_end is not negative if (expr_end < 0) return NULL; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; // Add check to ensure data is not out of bounds if (data < 0 || data > len) return NULL; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; // Add check to ensure expr_start is not negative if (expr_start < 0) return NULL; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",581,-37.939261631028565,-0.06529993396046224
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; // added a check for valid range of expr_end. 
if ( expr_end <= expr_start ) return NULL; 
len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; // added a check for valid range of expr_end. 
if ( expr_end < expr_start || len < 0 ) return NULL; 
str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",575,-52.891369668289684,-0.09198499072746032
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","

static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end > expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; // Add size check condition  if (len > SIZE_MAX - 3) { ast_error(c, n, ""f-string: expression length exceeds max allowed length""); return NULL; }  str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",557,-43.95791622485243,-0.0789190596496453
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { 
int all_whitespace = 1 ; 
int kind ; 
void * data ; 
PyCompilerFlags cf ; 
mod_ty mod ; 
char * str ; 
PyObject * o , * fstring_name ; 
Py_ssize_t len ; 
Py_ssize_t i ; 

//Added this check to prevent out-of-bounds read
if (expr_end < expr_start) return NULL; 

assert ( expr_end >= expr_start ) ; 
assert ( * ( expr_start - 1 ) == '{' ) ; 
assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; 
o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; 
if ( o == NULL ) return NULL ; 
len = PyUnicode_GET_LENGTH ( o ) ; 
kind = PyUnicode_KIND ( o ) ; 
data = PyUnicode_DATA ( o ) ; 
for ( i = 0 ; i < len ; i ++ ) { 
if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { 
all_whitespace = 0 ; 
break ; 
} 
} 
Py_DECREF ( o ) ; 
if ( all_whitespace ) { 
ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; 
return NULL ; 
} 
len = expr_end - expr_start ; 
str = PyMem_RawMalloc ( len + 3 ) ; 
if ( str == NULL ) return NULL ; 
str [ 0 ] = '(' ; 
memcpy ( str + 1 , expr_start , len ) ; 
str [ len + 1 ] = ')' ; 
str [ len + 2 ] = 0 ; 
cf . cf_flags = PyCF_ONLY_AST ; 
fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; 
mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; 
Py_DECREF ( fstring_name ) ; 
PyMem_RawFree ( str ) ; 
if ( ! mod ) return NULL ; 
return mod -> v . Expression . body ; 
}",630,-27.303598234985078,-0.04333904481743663
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; 

// Add check for if expr_end is greater than expr_start
if (expr_end <= expr_start) {
  ast_error ( c , n , ""f-string: expression end is less than or equal to expression start"" ) ;
  return NULL ;
}

o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; 

// Add check for if len is greater than 0
if (len <= 0) {
  ast_error ( c , n , ""f-string: length of expression is not greater than 0"" ) ;
  return NULL ;
}

for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; 

// Add check for if str is not NULL
if (str == NULL) {
  ast_error ( c , n , ""f-string: memory allocation failed"" ) ;
  return NULL ;
}

str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; 

// Add check for if mod is not NULL
if ( ! mod ) {
  ast_error ( c , n , ""f-string: mod is null"" ) ;
  return NULL ; 
}

return mod -> v . Expression . body ; }",718,-56.08789544531745,-0.07811684602411902
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { 
int all_whitespace = 1 ; 
int kind ; 
void * data ; 
PyCompilerFlags cf ; 
mod_ty mod ; 
char * str ; 
PyObject * o , * fstring_name ; 
Py_ssize_t len ; 
Py_ssize_t i ; 

if ( expr_end < expr_start ) {
return NULL;
}

if ( * ( expr_start - 1 ) != '{' ) {
return NULL;
}

if ( * expr_end != '}' && * expr_end != '!' && * expr_end != ':' ) {
return NULL;
}

o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; 
if ( o == NULL ) return NULL ; 
len = PyUnicode_GET_LENGTH ( o ) ; 
kind = PyUnicode_KIND ( o ) ; 
data = PyUnicode_DATA ( o ) ; 
for ( i = 0 ; i < len ; i ++ ) { 
if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { 
all_whitespace = 0 ; 
break ; 
} 
} 
Py_DECREF ( o ) ; 
if ( all_whitespace ) { 
ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; 
return NULL ; 
} 
len = expr_end - expr_start ; 
str = PyMem_RawMalloc ( len + 3 ) ; 
if ( str == NULL ) return NULL ; 
str [ 0 ] = '(' ; 
memcpy ( str + 1 , expr_start , len ) ; 
str [ len + 1 ] = ')' ; 
str [ len + 2 ] = 0 ; 
cf . cf_flags = PyCF_ONLY_AST ; 
fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; 
mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; 
Py_DECREF ( fstring_name ) ; 
PyMem_RawFree ( str ) ; 
if ( ! mod ) return NULL ; 
return mod -> v . Expression . body ; 
}",618,-20.4446288404299,-0.033081923690016016
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start > 0) { o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",553,-5.927430479550846,-0.010718680794847824
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start > 0){ o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; if (len > 0){ str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",585,-14.072729231373835,-0.024055947404057837
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end > expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; if(expr_end >= expr_start){ assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else{return NULL;} }",529,-21.84601274226823,-0.04129681047687756
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","

static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start < 0) { ast_error( c, n, ""f-string: empty expression not allowed"" ); return NULL; } o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",550,-16.51650970756051,-0.030030017650110017
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
 static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end < expr_start) return NULL; 
 o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len && i < expr_end - expr_start; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",538,-24.584993951297104,-0.045697014779362645
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' || expr_end == 0) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; if (len > 0) { str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } 
    else {
        return NULL;
    }
}",541,-28.149807542008762,-0.05203291597413819
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; if (expr_end - expr_start <= 0) { ast_error(c, n, ""f-string: empty expression not allowed""); return NULL; } assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",548,-11.446781555848704,-0.02088828751067282
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","

static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start > 0){ o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } 
else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",555,-14.280723192235685,-0.025731032778803037
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; if (expr_end - expr_start > 0) { o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; } else { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } }",553,-5.867297995613733,-0.010609942125883785
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
Fixed code:","
static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { int all_whitespace = 1 ; int kind ; void * data ; PyCompilerFlags cf ; mod_ty mod ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; 

if (expr_end <= expr_start) //Added to prevent out-of-bounds read 
	return NULL; 

assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string: empty expression not allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }",535,-25.398380410891775,-0.047473608244657524
