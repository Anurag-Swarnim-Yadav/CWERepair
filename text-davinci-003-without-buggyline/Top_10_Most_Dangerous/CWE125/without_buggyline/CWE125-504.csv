Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; size_t ep_len = ep + item_len - ext; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } 
if (id_len > ep_len) {
  ND_PRINT((ndo, ""Error: Out of bounds read"")); 
  return NULL;
}
idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",827,-38.059974743586224,-0.04602173487737149
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( id_len > MAX_ID_LEN ) { ND_PRINT ( ( ndo , ""%s"", ""ID length exceeds maximum length"" ) ) ; return NULL ; } if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",814,-25.260066299567043,-0.031032022481040592
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; 
//Check whether the length of the data is valid
if (ndo->ndo_snapend - (const u_char *)ext < sizeof(struct ikev2_id)) { ND_PRINT((ndo, ""[|%s]"", NPSTR(tpay))); return NULL; } 
ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; 
//Check whether the length of the data with type is valid
if (ndo->ndo_snapend - (const u_char *)ext < id_len) { ND_PRINT((ndo, ""[|%s]"", NPSTR(tpay))); return NULL; }
switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",909,-51.7204295206625,-0.056898162288957645
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; if (id_len > 0 && id_len <= item_len) { ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
else {
  return NULL;
}
}",803,-16.635539351221706,-0.02071673642742429
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } if (id_len - sizeof ( struct ikev2_id) < 0) { goto trunc; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",798,-10.122256143826329,-0.012684531508554297
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; if (idtype_len > 0) { dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",786,-9.504040863348576,-0.012091655042428213
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; if (id_len > sizeof(struct isakmp_gen)) { // Added bounds check ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",794,-18.539868643494135,-0.023349960508179012
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; 

//Check if the length of ID is within bounds
if(id_len > sizeof(struct ikev2_id)) {
  ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; 
  if ( 2 < ndo -> ndo_vflag && 4 < id_len ) {
    ND_PRINT ( ( ndo , "" "" ) ) ; 
    if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ;
  } 
  idtype_len = id_len - sizeof ( struct ikev2_id ) ;
  dumpascii = 0 ; dumphex = 0 ; 
  typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; 
  switch ( id . type ) {
    case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; 
    case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; 
    case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; 
    case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; 
    case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; 
    case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; 
    case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; 
  } 
  if ( dumpascii ) {
    ND_TCHECK2 ( * typedata , idtype_len ) ; 
    for ( i = 0 ; i < idtype_len ; i ++ ) {
      if ( ND_ISPRINT ( typedata [ i ] ) ) {
        ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; 
      } 
      else {
        ND_PRINT ( ( ndo , ""."" ) ) ; 
      } 
    } 
  } 
  if ( dumphex ) {
    if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ;
  } 
  return ( const u_char * ) ext + id_len ; 
 }
 trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; 
}",896,-46.02561986154408,-0.051367879309759015
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; if (id_len < 4) { return NULL; } ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",787,-6.500368811767279,-0.00825968082816681
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , (id_len > ndo-> ndo_snapend) ? (ndo-> ndo_snapend - ext - 1) : (id_len - 4)) ) goto trunc ; }  idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , (idtype_len > ndo-> ndo_snapend) ? (ndo-> ndo_snapend - typedata) : idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",836,-31.696694625757942,-0.03791470649014108
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; if (item_len < (u_int)id_len)
    id_len = item_len;  // make sure not to read past the end of the buffer
    
ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",812,-43.92730327538397,-0.054097664132246266
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( id_len > sizeof(struct isakmp_gen) ) { if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( id_len > sizeof(struct isakmp_gen) ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",810,-9.416682893872448,-0.011625534436879565
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } 

//Adding a check to ensure id_len is greater than 0
if (id_len > 0) {
	idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; } //Adding a return statement 
return NULL ;

}",812,-41.16915909962564,-0.05070093485175571
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; 

// Check if the item_len is greater than the id_len. If not, return a NULL pointer.
if (item_len < id_len) {
  return NULL;
}

ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { 
  // Check if the typedata pointer is within the bounds of the item_len. If not, return a NULL pointer.
  if (typedata + idtype_len > ext + item_len) {
    return NULL;
  }
  ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { 
  // Check if the typedata pointer is within the bounds of the item_len. If not, return a NULL pointer.
  if (typedata + idtype_len > ext + item_len) {
    return NULL;
  }
  if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",937,-47.01470108663457,-0.05017577490569324
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , ( id_len - 4 ) <= ep - typedata ? id_len - 4 : ep - typedata ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) && i < id_len ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , ( id_len - 4 ) <= ep - typedata ? id_len - 4 : ep - typedata ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",817,-27.034890193497723,-0.033090440873314225
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( id_len > (int) sizeof(struct isakmp_gen) ) { // Added check to prevent out-of-bounds read // if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - ((int) sizeof(struct isakmp_gen) + 1) ) ) goto trunc ; } } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",855,-32.869967236250176,-0.03844440612426921
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { 
  struct ikev2_id id ; 
  int id_len , idtype_len , i ; 
  unsigned int dumpascii , dumphex ; 
  const unsigned char * typedata ; 
  if (item_len < sizeof(id))
  {
    return NULL;
  }
  ND_TCHECK ( * ext ) ; 
  UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; 
  ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; 
  id_len = ntohs ( id . h . len ) ; 
  ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; 
  if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { 
    ND_PRINT ( ( ndo , "" "" ) ) ; 
    if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; 
  } 
  idtype_len = id_len - sizeof ( struct ikev2_id ) ; 
  dumpascii = 0 ; 
  dumphex = 0 ; 
  typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; 
  switch ( id . type ) { 
    case ID_IPV4_ADDR : 
      ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; 
      dumphex = 1 ; 
      break ; 
    case ID_FQDN : 
      ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; 
      dumpascii = 1 ; 
      break ; 
    case ID_RFC822_ADDR : 
      ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; 
      dumpascii = 1 ; 
      break ; 
    case ID_IPV6_ADDR : 
      ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; 
      dumphex = 1 ; 
      break ; 
    case ID_DER_ASN1_DN : 
      ND_PRINT ( ( ndo , "" dn:"" ) ) ; 
      dumphex = 1 ; 
      break ; 
    case ID_DER_ASN1_GN : 
      ND_PRINT ( ( ndo , "" gn:"" ) ) ; 
      dumphex = 1 ; 
      break ; 
    case ID_KEY_ID : 
      ND_PRINT ( ( ndo , "" keyid:"" ) ) ; 
      dumphex = 1 ; 
      break ; 
  } 
  if (idtype_len > item_len) 
  {
    return NULL;
  }
  if ( dumpascii ) { 
    ND_TCHECK2 ( * typedata , idtype_len ) ; 
    for ( i = 0 ; i < idtype_len ; i ++ ) { 
      if ( ND_ISPRINT ( typedata [ i ] ) ) { 
        ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; 
      } else { 
        ND_PRINT ( ( ndo , ""."" ) ) ; 
      } 
    } 
  } 
  if ( dumphex ) { 
    if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; 
  } 
  return ( const u_char * ) ext + id_len ; 
trunc : 
  ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR",1000,-28.82257327588575,-0.02882257327588575
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; if (id_len > 0 && idtype_len > 0) { switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; } else { ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; } trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",821,-14.335615476775759,-0.017461163796316393
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( id_len - 4 > 0 && ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( idtype_len > 0 && ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",789,-8.103142068546255,-0.010270142038715152
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; 
//Check if ID length is within bounds
if (id_len < 4) {
  //Throw an error if length is out of bounds
  ND_PRINT ( ( ndo , ""Error: ID length is out of bounds [|%s]"" , NPSTR ( tpay ) ) ) ;
  return NULL;
}

if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } 
//Check if ID type length is within bounds
if (idtype_len < 0) {
  //Throw an error if length is out of bounds
  ND_PRINT ( ( ndo , ""Error: ID type length is out of bounds [|%s]"" , NPSTR ( tpay ) ) ) ;
  return NULL;
}

if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",927,-43.23417382505284,-0.04663880671526736
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; if (id_len > 4) {
    ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; 
    if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } 
   }
    idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",795,-23.002328175737354,-0.028933746133002963
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( id_len > sizeof(struct isakmp_gen) ) { if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } else { ND_PRINT( ( ndo, ""Array out of bounds read would have occurred"") ); goto trunc; } } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( idtype_len > 0 ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } else { ND_PRINT( ( ndo, ""Array out of bounds read would have occurred"") ); goto trunc; } } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",855,-36.42359393871664,-0.04260069466516567
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( id_len <= sizeof(struct isakmp_gen)+1 ) { goto trunc; } if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( id_len <= sizeof(struct isakmp_gen)+1 ) { goto trunc; } if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",818,-20.060922620281463,-0.024524355281517682
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; if (id_len <= 4) {
ND_PRINT( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ;
return NULL ;
}

switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",817,-23.935634772773227,-0.02929698258601374
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; if ( sizeof(id) > ntohs(id.h.len)) { UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; } else { UNALIGNED_MEMCPY ( & id , ext , ntohs(id.h.len) ) ; } ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = ntohs(id.h.len) - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + ntohs(id.h.len) ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",841,-23.738353055164954,-0.028226341325998754
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; if (id_len > 4) {
  id_len = 4;
}
 ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",794,-14.325059141786465,-0.018041636198723506
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; if (idtype_len > 0 && idtype_len + sizeof(struct ikev2_id) > id_len) { goto trunc; } switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",808,-15.650770516164979,-0.01936976549030319
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; if (idtype_len < 0) { goto trunc; } dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",788,-7.561974059755809,-0.009596413781416001
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; //Check if id_len is greater than 4 before accessing ext if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; //Check for out of bounds read by comparing id_len and idtype_len before accessing ext if ( id_len < idtype_len ) { goto trunc; } switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { //Check for out of bounds read by comparing id_len and idtype_len before accessing typedata if ( id_len < idtype_len ) { goto trunc; } ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { //Check for out of bounds read by comparing id_len and idtype_len before accessing typedata if ( id_len < idtype_len ) { goto trunc; } if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",897,-51.90179162110504,-0.05786152912051844
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } //adding the check to check if the id_len and item_len are equal  else if (id_len != item_len) { ND_PRINT( (ndo, "" [|%s]"" , NPSTR( tpay ))); return NULL; }  idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",831,-49.99085019389921,-0.060157461123825764
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; if (id_len < 4){ ND_PRINT ( ( ndo , "" len=%d(invalid)"" , id_len - 4 ) ) ; return NULL; } ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",813,-18.268989800270194,-0.02247108216515399
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; if (typedata >= ep && typedata < (ep + item_len)) { switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",791,-23.15617485014144,-0.02927455733266933
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; if (id_len <= 0) { goto trunc; } ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",787,-13.119396804658427,-0.016670135711128877
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; if (id_len > MAX_ID_LEN) { ND_PRINT ( ( ndo , "" len=%d"" , 0 ) ) ; return NULL; } ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",812,-15.071610884017877,-0.018561097147805267
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } if (id_len > 4) {
    idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
else {
    return NULL;
  }",796,-17.78769829454585,-0.02234635464138926
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } // Added condition to check if id_len is less than or equal to 4 if (id_len <= 4) { ND_PRINT( ( ndo, "" [|%s]"" , NPSTR ( tpay ) ) ); return NULL; }  idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",827,-29.994481947913364,-0.036269022911624385
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; // Check to make sure memory accesses are in bounds if (id_len - 4 > ep - ext) { if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { // Check to make sure memory accesses are in bounds if (idtype_len > ep - ext) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",823,-33.82593481114523,-0.041100771337965046
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; if(idtype_len > 0) { //ADDED if statement to ensure length is greater than 0 before proceeding switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",799,-27.28235684807041,-0.03414562809520702
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; if (item_len < sizeof(struct isakmp_gen)) { return NULL; } ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; if (idtype_len > item_len) { return NULL; } switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",810,-12.50178323789024,-0.015434300293691654
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; if (idtype_len > 0) { dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; } trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",785,-9.443576951913792,-0.012030034333648144
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } //Added if-statement to check for out-of-bounds read if (id_len <= sizeof(struct ikev2_id)) { //If out-of-bounds, jump to trunc goto trunc; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",822,-33.025674217165815,-0.04017721924229418
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; if ( idtype_len > 0 ) { switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",785,-9.862484832368969,-0.012563674945692953
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; if (item_len != ntohs(ext->len)) { ND_PRINT((ndo, ""[|%s]"", NPSTR(tpay))); return NULL; } UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",815,-15.299187570861632,-0.018772009289400773
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } if(id_len > sizeof(struct ikev2_id)) { // Added check to prevent out of bounds read idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; } trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",801,-18.558596080197702,-0.023169283495877283
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; 
if (id_len > 4 && 2 < ndo -> ndo_vflag) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",776,-13.504002420266685,-0.01740206497457047
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; if (id_len < sizeof ( struct ikev2_id)) { goto trunc; } switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",795,-10.9804588032638,-0.01381189786574063
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; if (id_len < 4) { return NULL; } ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",787,-6.633054557729879,-0.00842827770994902
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; int data_length = id_len - 4; if (data_length > 0) { if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , data_length ) ) goto trunc ; } } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",793,-15.690258713951643,-0.019785950458955412
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { 
struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; 

ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; 
ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; 

// Validate the length of the ID
if (id.h.len > sizeof(struct ikev2_id)) {
  id_len = ntohs ( id . h . len ) ; 
  ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; 
  if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { 
    ND_PRINT ( ( ndo , "" "" ) ) ; 
    if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; 
  } 

  idtype_len = id_len - sizeof ( struct ikev2_id ) ; 
  dumpascii = 0 ; dumphex = 0 ; 
  typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; 
  switch ( id . type ) { 
    case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; 
    case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; 
    case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; 
    case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; 
    case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; 
    case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; 
    case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; 
  } 
  if ( dumpascii ) { 
    ND_TCHECK2 ( * typedata , idtype_len ) ; 
    for ( i = 0 ; i < idtype_len ; i ++ ) { 
      if ( ND_ISPRINT ( typedata [ i ] ) ) { 
        ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; 
      } else { 
        ND_PRINT ( ( ndo , ""."" ) ) ; 
      } 
    } 
  } 
  if ( dumphex ) { 
    if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; 
  } 
  return ( const u_char * ) ext + id_len ;
}else{
  goto trunc;
}
trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; 
}",921,-52.04855527410462,-0.05651308933127538
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
Fixed code:","

static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { 
 struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; 
 
 if (item_len < sizeof(struct ikev2_id)) {
 	ND_PRINT((ndo, "" [|%s]"" , NPSTR (tpay)));
 	return NULL;
 }
 
 ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "" len=%d"" , id_len - 4 ) ) ; 
 
 if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "" "" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } 
 
 idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; 
 
 if (idtype_len > item_len) {
 	ND_PRINT((ndo, "" [|%s]"" , NPSTR (tpay)));
 	return NULL;
 }
 
 switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "" ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "" fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "" rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "" ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "" dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "" gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "" keyid:"" ) ) ; dumphex = 1 ; break ; } 
 
 if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "" [|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",896,-32.2144796434114,-0.03595366031630737
