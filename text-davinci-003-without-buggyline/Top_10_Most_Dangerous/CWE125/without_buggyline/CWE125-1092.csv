Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { if (str >= 0 && str < end) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",450,-17.183933673803587,-0.03818651927511908
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) 
{
    const char * literal_start = *str;
    const char * literal_end;
    int in_named_escape = 0;
    int result = 0;
    assert(*literal == NULL);
    for ( ; *str < end; ( *str ) ++ ) 
    {
        if (*str >= end){
            break;
        }
        char ch = * * str ; 
        if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) 
        {
            in_named_escape = 1 ; 
        } 
        else if ( in_named_escape && ch == '}' ) 
        {
            in_named_escape = 0 ; 
        } 
        else if ( ch == '{' || ch == '}' ) 
        {
            if ( recurse_lvl == 0 ) 
            {
                if ( * str + 1 < end && * ( * str + 1 ) == ch ) 
                {
                    literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; 
                } 
                if ( ch == '}' ) 
                {
                    ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; 
                }
            } break ; 
        } 
    }
    literal_end = * str ; 
    assert ( * str <= end ) ; 
    assert ( * str == end || * * str == '{' || * * str == '}' ) ; 
    done : if ( literal_start != literal_end ) 
    {
        if ( raw ) 
            * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; 
        else 
            * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; 
        if ( ! * literal ) 
            return - 1 ; 
    } 
    return result ; 
}",572,-48.71421904080375,-0.08516471860280375
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; int escaped = 0; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if (recurse_lvl == 0 && (escaped || *str > literal_start)) { escaped = 0; if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } else if (*str > literal_start && *(str-1) == '\\') { escaped = 1; continue; } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",485,-30.569403600048645,-0.0630296981444302
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; if (*str + 2 >= end) { ast_error ( c , n , ""f-string: Out-of-bounds read detected"" ) ; return - 1 ; } } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 >= end) { ast_error ( c , n , ""f-string: Out-of-bounds read detected"" ) ; return - 1 ; } if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",515,-23.82368931829261,-0.04625959090930604
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:"," 

static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str < end - 1; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",447,-7.746423977278608,-0.01732980755543313
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { 
const char * literal_start = * str ; 
const char * literal_end ; 
int in_named_escape = 0 ; 
int result = 0 ; 
assert ( * literal == NULL ) ; 
for ( ; * str < end && * str < end - 1; ( * str ) ++ ) { // Check for out of bounds read
char ch = * * str ; 
if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { 
in_named_escape = 1 ; 
} else if ( in_named_escape && ch == '}' ) { 
in_named_escape = 0 ; 
} else if ( ch == '{' || ch == '}' ) { 
if ( recurse_lvl == 0 ) { 
if ( * str + 1 < end && * ( * str + 1 ) == ch ) { 
literal_end = * str + 1 ; 
* str += 2 ; 
result = 1 ; 
goto done ; 
} 
if ( ch == '}' ) { 
ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; 
return - 1 ; 
} 
} 
break ; 
} 
} 
literal_end = * str ; 
assert ( * str <= end ) ; 
assert ( * str == end || * * str == '{' || * * str == '}' ) ; 
done : 
if ( literal_start != literal_end ) { 
if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; 
else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; 
if ( ! * literal ) return - 1 ; 
} 
return result ; 
}",530,-21.005197812606365,-0.03963244870303088
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","

static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && *str < end - 1; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",446,-6.421164276772283,-0.014397229320117227
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && *str < end-1; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",445,-4.8850644396543395,-0.010977672898099639
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str >= 0; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end && * str >= 0) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }

The vulnerability has been fixed by adding a condition to the for loop that checks that the value of str is greater than or equal to 0.",478,-20.066872428552323,-0.04198090466224335
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; //Added check to make sure str is never out of bounds if (str >= end) break; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",458,-21.52522739944224,-0.04699831309921886
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } if(*str == end) { break; //Add this line before break, to stop the out-of-bounds read break; } } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",465,-43.50556282285289,-0.09356035015667287
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end; ( * str ) ++ ) { char ch = * * str ; if ( * str >= end ) { break; } if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",449,-10.700030035802257,-0.02383080186147496
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str < end + 1; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",445,-5.0993663240634755,-0.011459250166434776
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","

static int fstring_find_literal(const char** str, const char* end, int raw, PyObject** literal, int recurse_lvl, struct compiling* c, const node* n) {
    const char* literal_start = *str;
    const char* literal_end;
    int in_named_escape = 0;
    int result = 0;
    assert(*literal == NULL);
    for (; *str < end && *str > 0; (*str)++) {
        char ch = **str;
        if (!in_named_escape && ch == '{' && (*str) - literal_start >= 2 && *(*str - 2) == '\\' && *(*str - 1) == 'N') {
            in_named_escape = 1;
        } else if (in_named_escape && ch == '}') {
            in_named_escape = 0;
        } else if (ch == '{' || ch == '}') {
            if (recurse_lvl == 0) {
                if (*str + 1 < end && *(*str + 1) == ch) {
                    literal_end = *str + 1;
                    *str += 2;
                    result = 1;
                    goto done;
                }
                if (ch == '}') {
                    ast_error(c, n, ""f-string: single '}' is not allowed"");
                    return -1;
                }
            }
            break;
        }
    }
    literal_end = *str;
    assert(*str <= end);
    assert(*str == end || **str == '{' || **str == '}');
done:
    if (literal_start != literal_end) {
        if (raw)
            *literal = PyUnicode_DecodeUTF8Stateful(literal_start, literal_end - literal_start, NULL, NULL);
        else
            *literal = decode_unicode_with_escapes(c, n, literal_start, literal_end - literal_start);
        if (!*literal)
            return -1;
    }
    return result;
}",501,-12.778647958789161,-0.02550628335087657
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && str - literal_start < end - literal_start; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; } 
The vulnerability has been fixed by adding an additional condition in the loop, checking that the pointer is not out of bounds. The condition is ""str - literal_start < end - literal_start"". This ensures that the loop only iterates until the end of the buffer is reached.",509,-47.9408670954695,-0.09418637936241551
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; if (* str >= end) { return 0; } for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",449,-10.390646349260527,-0.02314175133465596
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && *str < end-1; ( * str ) ++ ) { char ch = * * str ; if ( * str > literal_start + 1 && ! in_named_escape && ch == '{' && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",443,-18.381453777991563,-0.04149312365235116
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && *str < end -1 ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",445,-8.56902570359046,-0.01925623753615834
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; if(*str >= end){ return -1; } for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",449,-8.362103651549209,-0.018623838867592894
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:"," 
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str < end - 1; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",446,-6.756127691702047,-0.015148268367044948
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str < end-1; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",445,-5.146143346761582,-0.011564367071374341
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && str < end; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",442,-6.157045381007756,-0.013929966925356915
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","

static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl, struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str < end - 1; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; }  } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",447,-22.224612500546563,-0.049719491052676874
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { 
  const char * literal_start = * str ; 
  const char * literal_end ; 
  int in_named_escape = 0 ; 
  int result = 0 ; 
  assert ( * literal == NULL ) ; 
  for ( ; * str < end ; ( * str ) ++ ) { 
    char ch = * * str ; 
    if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { 
      in_named_escape = 1 ; 
    } else if ( in_named_escape && ch == '}' ) { 
      in_named_escape = 0 ; 
    } else if ( ch == '{' || ch == '}' ) { 
      if ( recurse_lvl == 0 ) { 
        if ( * str + 1 < end && * ( * str + 1 ) == ch ) { 
          literal_end = * str + 1 ; 
          * str += 2 ; 
          result = 1 ; 
          goto done ; 
        } 
        if ( ch == '}' ) { 
          ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; 
          return - 1 ; 
        } 
      } 
      // added code
      if (*str + 1 == end) {
        break;
      }
      // added code
      break ; 
    } 
  } 
  literal_end = * str ; 
  assert ( * str <= end ) ; 
  assert ( * str == end || * * str == '{' || * * str == '}' ) ; 
  done : 
  if ( literal_start != literal_end ) { 
    if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; 
    else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; 
    if ( ! * literal ) return - 1 ; 
  } 
  return result ; 
}",579,-27.975782184178513,-0.04831741309875391
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && ( * str ) - literal_start < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( literal_end <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",450,-16.190759858792738,-0.03597946635287275
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","

static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { 
    const char * literal_start = * str ;
    const char * literal_end ;
    int in_named_escape = 0 ;
    int result = 0 ;
    int escape_count = 0;
    assert ( * literal == NULL ) ;
    for ( ; * str < end ; ( * str ) ++ ) {
        char ch = * * str ;
        if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) {
            in_named_escape = 1 ;
        } else if ( in_named_escape && ch == '}' ) {
            in_named_escape = 0 ;
        } else if ( ch == '{' || ch == '}' ) {
            if ( recurse_lvl == 0 ) {
                if ( * str + 1 < end && * ( * str + 1 ) == ch ) {
                    literal_end = * str + 1 ;
                    * str += 2 ;
                    result = 1 ;
                    goto done ;
                }
                if ( ch == '}' ) {
                    if(escape_count > 0) {
                        escape_count--;
                        continue;
                    }
                    ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; 
                    return - 1 ;
                }
            }
            break ; 
        }
        if(*str - literal_start >= 2 && *(*str - 2) == '\\\\') {
            escape_count++;
        }
    }
    literal_end = * str ;
    assert ( * str <= end ) ;
    assert ( * str == end || * * str == '{' || * * str == '}' ) ;
    done : 
    if ( literal_start != literal_end ) {
        if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ;
        else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ;
        if ( ! * literal ) return - 1 ;
    }
    return result ;
}",584,-46.522784406692786,-0.07966230206625477
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && *str < end - 2; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",445,-5.647679026247361,-0.012691413542128901
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal(const char **str, const char *end, int raw, PyObject **literal, int recurse_lvl, struct compiling *c, const node *n) {
    const char *literal_start = *str;
    const char *literal_end;
    int in_named_escape = 0;
    int result = 0;
    assert(*literal == NULL);
    for (; *str < end && *str < end - 1; (*str)++) {
        char ch = **str;
        if (!in_named_escape && ch == '{' && (*str) - literal_start >= 2 && *(*str - 2) == '\\' && *(*str - 1) == 'N') {
            in_named_escape = 1;
        } else if (in_named_escape && ch == '}') {
            in_named_escape = 0;
        } else if (ch == '{' || ch == '}') {
            if (recurse_lvl == 0) {
                if (*str + 1 < end && *(*str + 1) == ch) {
                    literal_end = *str + 1;
                    *str += 2;
                    result = 1;
                    goto done;
                }
                if (ch == '}') {
                    ast_error(c, n, ""f-string: single '}' is not allowed"");
                    return -1;
                }
            }
            break;
        }
    }
    literal_end = *str;
    assert(*str <= end);
    assert(*str == end || **str == '{' || **str == '}');
done:
    if (literal_start != literal_end) {
        if (raw)
            *literal = PyUnicode_DecodeUTF8Stateful(literal_start, literal_end - literal_start, NULL, NULL);
        else
            *literal = decode_unicode_with_escapes(c, n, literal_start, literal_end - literal_start);
        if (!*literal)
            return -1;
    }
    return result;
}
The CWE-125 vulnerability has been fixed by changing the for loop condition from:
for (; *str < end; (*str)++) 
to
for (; *str < end && *str < end - 1; (*str)++)",559,-29.136241651074208,-0.05212207808778928
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; if (end - * str < 2) { return result; } for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }

The code has been fixed by adding an if statement to check if the pointer is within the bounds of the array before proceeding with the operation. This prevents an out-of-bounds read from occurring.",495,-40.36175085885129,-0.081538890623942
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && *str < end - 2; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",445,-5.593235411267831,-0.01256906833992771
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","

static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str < end - 1; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",446,-5.44542244838048,-0.012209467373050403
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; 

if(*str >= end) 
  return -1;

assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",456,-18.334076610584557,-0.04020630835654508
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && *str < end-2; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",445,-5.666076940989214,-0.012732757170762278
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; int num_backslashes = 0; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { // Check that there are no more than 2 consecutive backslashes before an open brace if (num_backslashes > 1) { ast_error ( c , n , ""f-string: more than two consecutive backslashes not allowed before '{'"" ) ; return - 1 ; } if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } else if (ch == '\\') { num_backslashes++; } else { num_backslashes = 0; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",535,-48.21706370947618,-0.09012535272799285
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str < end + 1; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",445,-5.303481880072752,-0.011917936809152253
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str < end; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",443,-6.971357454203421,-0.01573669854221991
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { if (*str + 1 >= end) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",475,-12.757112643992782,-0.02685707925051112
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","

static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; if ( * str >= end ) { ast_error(c, n, ""f-string: out of bounds read""); return -1; } assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",470,-16.64607726807512,-0.03541718567675558
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && *str > 0; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",443,-6.9263750850441035,-0.015635158205517162
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; //Added check to prevent out-of-bounds read if (literal_end + 1 < end) * str += 2 ; else return -1; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",466,-28.409672372122188,-0.060964962171936025
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; int literal_length = 0; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { literal_length++; char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; if (literal_length > end - literal_start) { return -1; } assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",468,-17.563373553841274,-0.03752857596974631
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 >= end || * ( * str + 1 ) != ch ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",428,-7.955852022807714,-0.0185884393056255
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && *str - literal_start <= end-literal_start; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",452,-10.199808867879877,-0.02256594882274309
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; if ( * str >= end ) { ast_error ( c , n , ""f-string: index out of bounds"" ) ; return - 1 ; } for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",471,-11.414090292519973,-0.02423373735142245
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str >= literal_start; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",445,-5.38487117668778,-0.01210083410491636
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","

static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; int i; for ( i = 0; i < end - *str; i++ ) { char ch = * ( * str + i ) ; if ( ! in_named_escape && ch == '{' && ( * str + i ) - literal_start >= 2 && * ( * str + i - 2 ) == '\\\\' && * ( * str + i - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + i + 1 < end && * ( * str + i + 1 ) == ch ) { literal_end = * str + i + 1 ; * str += i + 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str + i; assert ( * str + i <= end ) ; assert ( * str + i == end || * ( * str + i ) == '{' || * ( * str + i ) == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",476,-15.621862741100383,-0.03281903937205963
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * str < end - 2; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",445,-5.37059098872313,-0.012068743794883438
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { 
    const char * literal_start = * str ; 
    const char * literal_end ; 
    int in_named_escape = 0 ; 
    int result = 0 ; 
    assert ( * literal == NULL ) ; 
    for ( ; * str < end ; ( * str ) ++ ) { 
        char ch = * * str ; 
        if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { 
            in_named_escape = 1 ; 
        } else if ( in_named_escape && ch == '}' ) { 
            in_named_escape = 0 ; 
        } else if ( ch == '{' || ch == '}' ) { 
            if ( recurse_lvl == 0 ) { 
                if ( * str + 1 < end && * ( * str + 1 ) == ch ) { 
                    literal_end = * str + 1 ; 
                    * str += 2 ; 
                    result = 1 ; 
                    goto done ; 
                } 
                if ( ch == '}' ) { 
                    ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; 
                    return - 1 ; 
                } 
            } 
            if ( * str >= end ) {
                ast_error ( c , n , ""f-string: Unterminated literal"" ) ; 
                return - 1 ;
            }
            break ; 
        } 
    } 
    literal_end = * str ; 
    assert ( * str <= end ) ; 
    assert ( * str == end || * * str == '{' || * * str == '}' ) ; 
    done : 
    if ( literal_start != literal_end ) { 
        if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; 
        else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; 
        if ( ! * literal ) return - 1 ; 
    } 
    return result ; 
}",593,-26.670954759338407,-0.044976314939862407
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; int nesting_level = 0; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { nesting_level++; if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; if (nesting_level > 0) // added if statement to prevent out-of-bounds read { ast_error ( c , n , ""f-string: Unexpected end of input before closing brace"" ) ; return - 1 ; } assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",501,-49.49456590768922,-0.09879154871794256
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
Fixed code:","
static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; if (str > end) { return -1; } for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { in_named_escape = 0 ; } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string: single \'}\' is not allowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; assert ( * str <= end ) ; assert ( * str == end || * * str == '{' || * * str == '}' ) ; done : if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }",450,-10.022129760636416,-0.022271399468080925
