Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (j + 1 < maxw) { // added to fix out-of-bounds read sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",853,-15.97129916973671,-0.018723680152094618
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (i * maxw + j >= max || i * maxw + j + 1 >= max) { break; } sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { if (i * maxw + j >= max) { break; } sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",872,-12.476999025130208,-0.014308485120562165
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { //Check if y points to valid memory location if(y + 1 >= img->comps[0].data + max) { break; } sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } //Check if y points to valid memory location if(y >= img->comps[0].data + max) { break; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",889,-28.910939772207673,-0.03252074215096476
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (j < maxw && i < maxh) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { if (j < maxw && i < maxh) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",859,-9.390550341444632,-0.010931956160005392
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; (i < maxh) && (i < maxw); ++ i ) { for ( j = 0U ; (j < ( maxw & ~ ( unsigned int ) 1U )) && (j < maxh); j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if (( j < maxw ) && (j < maxh)) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",853,-12.689049448782669,-0.014875790678525989
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:"," 
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; if ( maxh < 1 || maxw < 1 ) goto fails; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( ( j + 1 ) < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",860,-23.34114599446703,-0.02714086743542678
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if(j + 2 < maxw) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } else { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } }  if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",888,-16.71266482879432,-0.018820568500894506
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < maxw ; j ++ ) { if ( j < ( maxw & ~ ( unsigned int ) 1U ) ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } else { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",832,-6.05420591876537,-0.007276689806208377
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { //Check to ensure loop condition is not greater than maxw for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) && j < maxw; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",848,-24.571666202150112,-0.02897602146479966
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if(j+1< maxw) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } else { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",887,-14.102178384772717,-0.015898735495797876
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",840,-5.252051085220677,-0.006252441768119854
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; if ( j + 1 >= maxw ) { break ; } else { ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",847,-14.94064047432207,-0.017639481079482964
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (j+2 <= maxw && i+2 <= maxh) { // Check bounds of array before reading sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if (j < maxw && i+2 <= maxh) { // Check bounds of array before reading sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",870,-30.831728250722485,-0.03543876810427872
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( ( i * j + 1 ) < max ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { if ( ( i * j + 1 ) < max ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",859,-13.7815771500984,-0.0160437452271227
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (j >= maxw) { 
            break; 
        } 
        sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { if (j >= maxw) { 
            break; 
        } 
        sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",871,-16.582014533197967,-0.019037904171295025
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",839,-5.915951027243084,-0.007051193119479242
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; if ( ( i * maxw + j ) < maxw ) { ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",847,-19.06475842131795,-0.02250856956472013
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (j+1 < maxw) {  //added check to detect out-of-bounds read sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",855,-23.127804414280174,-0.027050063642432953
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( i * maxw + j >= max || i * maxw + j + 1 >= max) { break; } sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw && i * maxw + j < max) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",866,-14.647901335981505,-0.016914435722842385
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( j >= maxw ){ // Prevent out-of-bounds reads continue; } sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",851,-22.225907077488944,-0.026117399621021085
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; // Check bounds of max before proceeding if (max == 0) return; // No data, return y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",851,-34.51880769179401,-0.04056264123595066
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; if ( maxw % 2 != 0 ) { for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { // Added bounds check if (y < maxw * maxh && cb < maxw * maxh && cr < maxw * maxh) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; } ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } } else { for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < maxw ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free",1000,-33.88639532171325,-0.03388639532171325
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( y < img->comps[0].data + img->comps[0].data_size && cb < img->comps[1].data + img->comps[1].data_size && cr < img->comps[2].data + img->comps[2].data_size) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { if ( y < img->comps[0].data + img->comps[0].data_size && cb < img->comps[1].data + img->comps[1].data_size && cr < img->comps[2].data + img->comps[2].data_size) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",973,-15.605630194232036,-0.01603867440311617
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; if (maxw == 0 || maxh == 0) goto fails; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",846,-8.316349671941252,-0.00983020055785018
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (j < maxw) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",840,-5.252554707402235,-0.006253041318335995
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if( i * maxw + j < max ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { if( i * maxw + j < max) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",857,-15.272008867922208,-0.017820313731531166
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:"," 
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",841,-7.9692802107249525,-0.009475957444381632
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if(((j + 1) < maxw) && (i < maxh)) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { if(i < maxh) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",860,-15.167736424535581,-0.01763690281922742
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) { goto fails ; } for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( j < maxw && i < maxh) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; } ++ y ; ++ r ; ++ g ; ++ b ; if ( j + 1 < maxw && i < maxh ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; } ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw && i < maxh) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
The vulnerability has been fixed by adding an if statement within the for loop that checks if the values of j and i are within the bounds of the maxw and maxh variables, respectively. This ensures that an out-of-bounds read does not occur.",922,-54.32757133612966,-0.05892361316283043
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if(maxw >= j + 2) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",842,-14.024554576201604,-0.01665624058931307
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) {
    int * d0 , * d1 , * d2 , * r , * g , * b ;
    const int * y , * cb , * cr ;
    unsigned int maxw , maxh , max ;
    int offset , upb ;
    unsigned int i , j ;
    
    upb = ( int ) img -> comps [ 0 ] . prec ;
    offset = 1 << ( upb - 1 ) ;
    upb = ( 1 << upb ) - 1 ;
    maxw = ( unsigned int ) img -> comps [ 0 ] . w ;
    maxh = ( unsigned int ) img -> comps [ 0 ] . h ;
    max = maxw * maxh ;
    y = img -> comps [ 0 ] . data ;
    cb = img -> comps [ 1 ] . data ;
    cr = img -> comps [ 2 ] . data ;
    
    if (maxw == 0 || maxh == 0) {
    	return;
    }
    
    d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;
    d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;
    d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;
    if ( r == NULL || g == NULL || b == NULL ) goto fails ;
    for ( i = 0U ; i < maxh ; ++ i ) {
        for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) {
            sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;
            ++ y ;
            ++ r ;
            ++ g ;
            ++ b ;
            sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;
            ++ y ;
            ++ r ;
            ++ g ;
            ++ b ;
            ++ cb ;
            ++ cr ;
        }
        if ( j < maxw ) {
            sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;
            ++ y ;
            ++ r ;
            ++ g ;
            ++ b ;
        }
    }
    
    free ( img -> comps [ 0 ] . data ) ;
    img -> comps [ 0 ] . data = d0 ;
    free ( img -> comps [ 1 ] . data ) ;
    img -> comps [ 1 ] . data = d1 ;
    free ( img -> comps [ 2 ] . data ) ;
    img -> comps [ 2 ] . data = d2 ;
	
	# if defined ( USE_JPWL ) || defined ( USE_MJ2 )
    img -> comps [ 1 ] . w = maxw ;
    img -> comps [ 1 ] . h = maxh ;
    img -> comps [ 2 ] . w = maxw ;
    img -> comps [ 2 ] . h = maxh ;
	# else
    img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;
    img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ;
    img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ;
    img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;
	# endif
    img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;
    img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;
    img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;
    img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;
    return ;
fails :
    if ( r ) free ( r ) ;
    if ( g ) free ( g ) ;
    if ( b ) free ( b ) ;
}",992,-39.23794786031507,-0.0395543829237047
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (j+1 >= maxw) { // Added line sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } else { // Added line sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } // Added line ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",896,-20.678115832221145,-0.02307825427703253
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; if ( j + 1 < maxw ) { // Added check to prevent out-of-bounds read ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; if ( j + 1 < maxw ) { // Added check to prevent out-of-bounds read ++ cb ; ++ cr ; } } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",877,-16.555279472002837,-0.018877171575829917
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( j + 1 < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } else { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",835,-7.836797189626357,-0.009385385855839949
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; /* Added checks against array bounds */ if (j + 1 < maxw) { sycc_to_rgb ( offset , upb , * (y + 1), * cb , * cr , r + 1 , g + 1 , b + 1 ) ; ++ y ; ++ r ; ++ g ; ++ b ; } ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",846,-37.31745513490079,-0.04411046706253048
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (i*maxw+j >= max)  // check boundary
	continue;
sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { if (i*maxw+j >= max)  // check boundary
	continue;
sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",871,-28.21563691036778,-0.032394531469997455
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",839,-5.905526537808573,-0.00703876822146433
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (j + 1 < maxw) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",842,-6.425284076486152,-0.007630978713166451
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { /* Check that the indexes used for cb and cr are within the range of the arrays */ if (cb[i * maxw + j] < max && cr[i * maxw + j] < max) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } /* Check that the index used for cb and cr are within the range of the arrays */ if ( j < maxw && cb[i * maxw + j] < max && cr[i * maxw + j] < max) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",922,-47.068371793843504,-0.05105029478724892
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( ( j + 2 ) > maxw ) continue ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",844,-12.869638216507008,-0.015248386512449062
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( ( i * maxw + j ) < max ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } if ( ( i * maxw + j + 1 ) < max ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } ++ cb ; ++ cr ; } if ( j < maxw && ( i * maxw + j ) < max ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",874,-11.310408083785054,-0.012940970347580153
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < maxw ; j ++ ) { if ( j < ( maxw & ~ ( unsigned int ) 1U ) ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } else { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",832,-6.111827889209781,-0.007345946982223295
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",840,-5.2792176892769245,-0.00628478296342491
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ((j + 1) < maxw) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",843,-7.656044242183019,-0.009081903015638219
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 ; int * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < maxw ; ++ j ) { if ( j < ( maxw & ~ ( unsigned int ) 1U ) ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ cb ; ++ cr ; } else { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; } ++ r ; ++ g ; ++ b ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",775,-18.85823696808187,-0.024333208991073378
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if(j >= maxw) // check for array out of bounds { break; } sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",849,-22.725151347204413,-0.026766962717555257
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( j + 1 < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } else { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",887,-6.756822284633089,-0.007617612496767857
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if ( j + 1 < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } else { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",894,-6.981569869827222,-0.007809362270500248
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { if (j + 1 < maxw) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } else { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }",894,-7.689118277866707,-0.008600803442803923
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; unsigned int maxw , maxh , max ; int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < maxh ; ++ i ) { for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; return ; fails : if ( r ) free ( r ) ; if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
Fixed code:","
static void sycc422_to_rgb ( opj_image_t * img ) { 
    int * d0 , * d1 , * d2 , * r , * g , * b ; 
    const int * y , * cb , * cr ; 
    unsigned int maxw , maxh , max ; 
    int offset , upb ; 
    unsigned int i , j ; 
    upb = ( int ) img -> comps [ 0 ] . prec ; 
    offset = 1 << ( upb - 1 ) ; 
    upb = ( 1 << upb ) - 1 ; 
    maxw = ( unsigned int ) img -> comps [ 0 ] . w ;
    maxh = ( unsigned int ) img -> comps [ 0 ] . h ; 
    max = maxw * maxh ; 
    y = img -> comps [ 0 ] . data ; 
    cb = img -> comps [ 1 ] . data ; 
    cr = img -> comps [ 2 ] . data ; 
    d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;
    d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; 
    d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; 
    if ( r == NULL || g == NULL || b == NULL ) goto fails ; 
    for ( i = 0U ; i < maxh ; ++ i ) { 
        for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { 
            if (j+1 < maxw) {
                sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; 
                ++ y ; 
                ++ r ; 
                ++ g ; 
                ++ b ; 
                sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; 
                ++ y ; 
                ++ r ; 
                ++ g ; 
                ++ b ; 
                ++ cb ; 
                ++ cr ;
            }
        } 
        if ( j < maxw ) { 
            sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; 
            ++ y ; 
            ++ r ; 
            ++ g ; 
            ++ b ; 
            ++ cb ; 
            ++ cr ; 
        } 
    } 
    free ( img -> comps [ 0 ] . data ) ; 
    img -> comps [ 0 ] . data = d0 ; 
    free ( img -> comps [ 1 ] . data ) ; 
    img -> comps [ 1 ] . data = d1 ; 
    free ( img -> comps [ 2 ] . data ) ; 
    img -> comps [ 2 ] . data = d2 ; 

# if defined ( USE_JPWL ) || defined ( USE_MJ2 )
    img -> comps [ 1 ] . w = maxw ; 
    img -> comps [ 1 ] . h = maxh ; 
    img -> comps [ 2 ] . w = maxw ; 
    img -> comps [ 2 ] . h = maxh ; 
# else 
    img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; 
    img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; 
    img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; 
    img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; 
# endif 
    img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; 
    img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; 
    img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; 
    img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;",1000,-31.23464388237474,-0.031234643882374742
