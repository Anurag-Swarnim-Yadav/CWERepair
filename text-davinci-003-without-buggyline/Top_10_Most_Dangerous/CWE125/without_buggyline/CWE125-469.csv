Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","

static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( len >= opcode_desc->size && ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( len >= 2 && ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",583,-8.004016197758503,-0.013729015776601206
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = 0;

if (len >= 2) {
  ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ;
}

int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",588,-11.62627649192856,-0.019772579067905714
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:"," 
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ;

if (len < 2){
  return NULL;
}

ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } 

if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } 

INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",593,-22.043234925540336,-0.037172402909848794
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; if(len < 2) return NULL; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",578,-6.929695594458725,-0.011989092723977033
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if ( len < 2 ) { goto INVALID_OP ; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",584,-6.867069270770605,-0.011758680258168844
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = 0 ; int fail ; char * t ; if (len >= 2) { ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; } memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",581,-8.741250694504203,-0.01504518191825164
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; 

if (len < 2) {
   op -> family = R_ANAL_OP_FAMILY_UNKNOWN ;
   op -> type = R_ANAL_OP_TYPE_UNK ;
   op -> addr = addr ;
   op -> fail = UT64_MAX ;
   op -> jump = UT64_MAX ;
   op -> ptr = UT64_MAX ;
   op -> val = UT64_MAX ;
   op -> nopcode = 1 ;
   op -> cycles = 1 ;
   op -> size = 2 ;
   r_strbuf_set ( & op -> esil , ""1,$"" ) ;
   return NULL ; 
}

for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { 
    if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { 
        fail = 0 ; 
        op -> cycles = opcode_desc -> cycles ; 
        op -> size = opcode_desc -> size ; 
        op -> type = opcode_desc -> type ; 
        op -> jump = UT64_MAX ; 
        op -> fail = UT64_MAX ; 
        op -> addr = addr ; 
        r_strbuf_setf ( & op -> esil , """" ) ; 
        opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; 
        if ( fail ) { 
            goto INVALID_OP ; 
        } 
        if ( op -> cycles <= 0 ) { 
            opcode_desc -> cycles = 2 ; 
        } 
        op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; 
        t = r_strbuf_get ( & op -> esil ) ; 
        if ( t && strlen ( t ) > 1 ) { 
            t += strlen ( t ) - 1 ; 
            if ( * t == ',' ) { 
                * t = '\\0' ; 
            } 
        } 
        return opcode_desc ; 
    } 
} 

if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { 
    goto INVALID_OP ; 
} 
INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; 
op -> type = R_ANAL_OP_TYPE_UNK ; 
op -> addr = addr ; 
op -> fail = UT64_MAX ; 
op -> jump = UT64_MAX ; 
op -> ptr = UT64_MAX ; 
op -> val = UT64_MAX ; 
op -> nopcode = 1 ; 
op -> cycles = 1 ; 
op -> size = 2 ; 
r_strbuf_set ( & op -> esil , ""1,$"" ) ; 
return NULL ; 
}",841,-21.22819197331518,-0.02524160757825824
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector && len >= opcode_desc->size ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",578,-6.464881633526942,-0.011184916320980868
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if ( len < 2 ) { goto INVALID_OP ; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",584,-4.558322652315103,-0.007805347007388875
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:"," 
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if (len < 2) { goto INVALID_OP; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",585,-8.068233067464101,-0.013791851397374532
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","

static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = 0; int fail ; char * t ; if(len > 1) { ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; } memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",582,-13.22011080824067,-0.022714967024468506
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:"," 
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; 
	if (len < 2) { return NULL; } 
int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",586,-22.527930863777947,-0.03844356802692482
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( len > 0 && ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( len > 0 && ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",577,-7.031567807100244,-0.012186426008839246
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = 0 ; int fail ; char * t ; if ( len < 2 ) { goto INVALID_OP ; } ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }

The vulnerability has been fixed by adding a check to verify that the length of the buffer is greater than or equal to 2 bytes before attempting to read the buffer. If the buffer is less than two bytes, the program will jump to the INVALID_OP label.",644,-38.6624609043667,-0.06003487718069363
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; 
if (len < 2) { goto INVALID_OP; } 
for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",588,-10.594082401566412,-0.018017146941439476
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if (len < 2) { op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",696,-6.507916572973647,-0.009350454846226505
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; if (len < 2) { return NULL; } memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",580,-4.787153990968344,-0.008253713777531627
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; uint16_t ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ins <= 0xFFFF && ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",577,-15.959563194366398,-0.027659554929577813
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; if ( len < 2 ) { return NULL ; } memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",580,-5.3232196089304,-0.009177964842983449
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; if (len < 2) { return NULL; } memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",580,-4.976049863087754,-0.008579396315668541
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { // CWE-125: Boundary check added if (len >= opcode_desc->size) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",592,-21.68484075530815,-0.03662979857315566
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; if (len < 2) return NULL; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if (len < 2 || ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",582,-13.143909663067507,-0.022584037221765475
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { 
OPCODE_DESC * opcode_desc ; 
ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; 
int fail ; 
char * t ; 
memset ( op , 0 , sizeof ( RAnalOp ) ) ; 
op -> ptr = UT64_MAX ; 
op -> val = UT64_MAX ; 
op -> jump = UT64_MAX ; 
r_strbuf_init ( & op -> esil ) ; 

if ( len < 2 ) {
	goto INVALID_OP;
}

for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { 
	if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { 
		fail = 0 ; 
		op -> cycles = opcode_desc -> cycles ; 
		op -> size = opcode_desc -> size ; 
		op -> type = opcode_desc -> type ; 
		op -> jump = UT64_MAX ; 
		op -> fail = UT64_MAX ; 
		op -> addr = addr ; 
		r_strbuf_setf ( & op -> esil , """" ) ; 
		opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; 
		if ( fail ) { 
			goto INVALID_OP ; 
		} 
		if ( op -> cycles <= 0 ) { 
			opcode_desc -> cycles = 2 ; 
		} 
		op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; 
		t = r_strbuf_get ( & op -> esil ) ; 
		if ( t && strlen ( t ) > 1 ) { 
			t += strlen ( t ) - 1 ; 
			if ( * t == ',' ) { 
				* t = '\\0' ; 
			} 
		} 
		return opcode_desc ; 
	} 
} 
if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { 
	goto INVALID_OP ; 
} 

INVALID_OP : 
op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; 
op -> type = R_ANAL_OP_TYPE_UNK ; 
op -> addr = addr ; 
op -> fail = UT64_MAX ; 
op -> jump = UT64_MAX ; 
op -> ptr = UT64_MAX ; 
op -> val = UT64_MAX ; 
op -> nopcode = 1 ; 
op -> cycles = 1 ; 
op -> size = 2 ; 
r_strbuf_set ( & op -> esil , ""1,$"" ) ; 
return NULL ; 
}",760,-16.870040244069912,-0.0221974213737762
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { 
OPCODE_DESC * opcode_desc ; 
ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; 
int fail ; 
char * t ; 
if(len < 2) {
    goto INVALID_OP;
}
memset ( op , 0 , sizeof ( RAnalOp ) ) ; 
op -> ptr = UT64_MAX ; 
op -> val = UT64_MAX ; 
op -> jump = UT64_MAX ; 
r_strbuf_init ( & op -> esil ) ; 
for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { 
    if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { 
        fail = 0 ; 
        op -> cycles = opcode_desc -> cycles ; 
        op -> size = opcode_desc -> size ; 
        op -> type = opcode_desc -> type ; 
        op -> jump = UT64_MAX ; 
        op -> fail = UT64_MAX ; 
        op -> addr = addr ; 
        r_strbuf_setf ( & op -> esil , """" ) ; 
        opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; 
        if ( fail ) { 
            goto INVALID_OP ; 
        } 
        if ( op -> cycles <= 0 ) { 
            opcode_desc -> cycles = 2 ; 
        } 
        op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; 
        t = r_strbuf_get ( & op -> esil ) ; 
        if ( t && strlen ( t ) > 1 ) { 
            t += strlen ( t ) - 1 ; 
            if ( * t == ',' ) { 
                * t = '\\0' ; 
            } 
        } 
        return opcode_desc ; 
    } 
} 
if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { 
    goto INVALID_OP ; 
} 
INVALID_OP : 
op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; 
op -> type = R_ANAL_OP_TYPE_UNK ; 
op -> addr = addr ; 
op -> fail = UT64_MAX ; 
op -> jump = UT64_MAX ; 
op -> ptr = UT64_MAX ; 
op -> val = UT64_MAX ; 
op -> nopcode = 1 ; 
op -> cycles = 1 ; 
op -> size = 2 ; 
r_strbuf_set ( & op -> esil , ""1,$"" ) ; 
return NULL ; 
}",723,-14.505651583089211,-0.020063141885323942
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( len > 0 && ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( len > 0 && ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
The vulnerability has been fixed by adding a condition to check if the length of the buffer is greater than 0 before accessing the buffer. This condition will ensure that the code will not try to access the memory out of bounds.",622,-37.40307417130239,-0.060133559760936324
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if ( len < 2 ) { goto INVALID_OP ; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",584,-4.499232664766804,-0.0077041655218609666
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if ( len > 1 ) { ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",579,-11.039431250104801,-0.019066375216070467
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","

static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; if (len < opcode_desc->size) { goto INVALID_OP; } opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",590,-8.642481708582201,-0.014648274082342714
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins ; if(len < 2) { goto INVALID_OP; } ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",586,-8.4971549231008,-0.014500264373892149
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if (len < 2) { goto INVALID_OP; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",584,-4.550997660325403,-0.007792804212885964
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","

static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { 
	OPCODE_DESC * opcode_desc ; 
	if (len < 2) {
		return NULL;
	}
	ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; 
	int fail ; 
	char * t ; 
	memset ( op , 0 , sizeof ( RAnalOp ) ) ; 
	op -> ptr = UT64_MAX ; 
	op -> val = UT64_MAX ; 
	op -> jump = UT64_MAX ; 
	r_strbuf_init ( & op -> esil ) ; 
	for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { 
		if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { 
			fail = 0 ; 
			op -> cycles = opcode_desc -> cycles ; 
			op -> size = opcode_desc -> size ; 
			op -> type = opcode_desc -> type ; 
			op -> jump = UT64_MAX ; 
			op -> fail = UT64_MAX ; 
			op -> addr = addr ; 
			r_strbuf_setf ( & op -> esil , """" ) ; 
			opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; 
			if ( fail ) { 
				goto INVALID_OP ; 
			} 
			if ( op -> cycles <= 0 ) { 
				opcode_desc -> cycles = 2 ; 
			} 
			op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; 
			t = r_strbuf_get ( & op -> esil ) ; 
			if ( t && strlen ( t ) > 1 ) { 
				t += strlen ( t ) - 1 ; 
				if ( * t == ',' ) { 
					* t = '\0' ; 
				} 
			} 
			return opcode_desc ; 
		} 
	} 
	if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { 
		goto INVALID_OP ; 
	} 
	INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; 
	op -> type = R_ANAL_OP_TYPE_UNK ; 
	op -> addr = addr ; 
	op -> fail = UT64_MAX ; 
	op -> jump = UT64_MAX ; 
	op -> ptr = UT64_MAX ; 
	op -> val = UT64_MAX ; 
	op -> nopcode = 1 ; 
	op -> cycles = 1 ; 
	op -> size = 2 ; 
	r_strbuf_set ( & op -> esil , ""1,$"" ) ; 
	return NULL ; 
}",806,-13.433672967831185,-0.016667088049418344
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; if (len < 2) { return NULL; } memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",580,-4.976049863087754,-0.008579396315668541
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if (len < 3) { 
  goto INVALID_OP; 
}

for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } 

if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { 
  goto INVALID_OP ; 
} 

INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",602,-24.732580154701264,-0.041084020190533664
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( len > 2 ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } } if ( len > 2 && ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",581,-13.242042824705141,-0.022791812090714528
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = 0; 

if(len >= 2) {
    ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; 
}

int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { 
if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",592,-19.357047900448546,-0.03269771604805498
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; //Added check to prevent out-of-bounds read if(len < 2) { goto INVALID_OP; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",596,-15.51560107605549,-0.0260328877115025
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 0 ] << 8 ) | buf [ 1 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0x00ff ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",570,-9.624211702790303,-0.01688458193471983
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; if ( len < 2 ) { return NULL ; } memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",580,-5.442941485630295,-0.00938438187177637
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail = 0; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; if (len >= op->size) { opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; } else { fail = 1; //If the buffer length is less than the length of the instruction set fail to 1 } if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",605,-38.36956125593002,-0.06342076240649591
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; if (len < 2) { return NULL; } memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",580,-4.8897772075225845,-0.00843065035779756
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if ( len < 2 ) { op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",696,-6.463036405934512,-0.009285971847607056
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if ( len < 2 ) { goto INVALID_OP ; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",584,-4.557314668228395,-0.007803621007240403
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; 
if (len < 2) {
    goto INVALID_OP;
}

for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { 
    if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { 
        fail = 0 ; 
        op -> cycles = opcode_desc -> cycles ; 
        op -> size = opcode_desc -> size ; 
        op -> type = opcode_desc -> type ; 
        op -> jump = UT64_MAX ; 
        op -> fail = UT64_MAX ; 
        op -> addr = addr ; 
        r_strbuf_setf ( & op -> esil , """" ) ; 
        opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; 
        if ( fail ) { 
            goto INVALID_OP ; 
        } 
        if ( op -> cycles <= 0 ) { 
            opcode_desc -> cycles = 2 ; 
        } 
        op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; 
        t = r_strbuf_get ( & op -> esil ) ; 
        if ( t && strlen ( t ) > 1 ) { 
            t += strlen ( t ) - 1 ; 
            if ( * t == ',' ) { 
                * t = '\\0' ; 
            } 
        } 
        return opcode_desc ; 
    } 
} 
if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { 
    goto INVALID_OP ; 
} 
INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",680,-13.26772800723399,-0.019511364716520572
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { 
OPCODE_DESC * opcode_desc ; 
ut16 ins ;
if ( len < 2 ) {
  goto INVALID_OP;
}
ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; 
int fail ; 
char * t ; 
memset ( op , 0 , sizeof ( RAnalOp ) ) ; 
op -> ptr = UT64_MAX ; 
op -> val = UT64_MAX ; 
op -> jump = UT64_MAX ; 
r_strbuf_init ( & op -> esil ) ; 
for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { 
if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { 
fail = 0 ; 
op -> cycles = opcode_desc -> cycles ; 
op -> size = opcode_desc -> size ; 
op -> type = opcode_desc -> type ; 
op -> jump = UT64_MAX ; 
op -> fail = UT64_MAX ; 
op -> addr = addr ; 
r_strbuf_setf ( & op -> esil , """" ) ; 
opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; 
if ( fail ) { 
goto INVALID_OP ; 
} 
if ( op -> cycles <= 0 ) { 
opcode_desc -> cycles = 2 ; 
} 
op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; 
t = r_strbuf_get ( & op -> esil ) ; 
if ( t && strlen ( t ) > 1 ) { 
t += strlen ( t ) - 1 ; 
if ( * t == ',' ) { 
* t = '\\0' ; 
} 
} 
return opcode_desc ; 
} 
} 
if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { 
goto INVALID_OP ; 
} 
INVALID_OP : 
op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; 
op -> type = R_ANAL_OP_TYPE_UNK ; 
op -> addr = addr ; 
op -> fail = UT64_MAX ; 
op -> jump = UT64_MAX ; 
op -> ptr = UT64_MAX ; 
op -> val = UT64_MAX ; 
op -> nopcode = 1 ; 
op -> cycles = 1 ; 
op -> size = 2 ; 
r_strbuf_set ( & op -> esil , ""1,$"" ) ; 
return NULL ; 
}",701,-18.066825797506137,-0.02577293266406011
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if(len >= 2) { for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; } } else { goto INVALID_OP; }",587,-15.71587517999824,-0.02677321155025254
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = 0 ; int fail ; char * t ; if (len >= 2) { ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; } else { goto INVALID_OP ; } memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",591,-10.273665065298715,-0.017383528029270245
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; if (len < opcode_desc->size) { goto INVALID_OP; } op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",589,-8.753430432362277,-0.014861511769715242
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if (len < 2) { goto INVALID_OP; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",584,-4.667910249637907,-0.007992997002804635
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; if ( len < 2 ) { op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; } for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",696,-6.2591331178039535,-0.0089930073531666
"The Original Code is vulnerable to CWE-125: Out-of-bounds Read. Fix the vulnerability.
Original Code:
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
Fixed code:","
static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ;  int fail ; char * t ; if ( len < 2 ) return NULL; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",579,-14.14702543030228,-0.024433549965979757
