Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } spin_lock_irq ( & head -> lock ) ; hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; spin_unlock_irq ( & head -> lock ) ; return 0 ; }",238,-11.688427275793853,-0.04911103897392375
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if ( hlist_unhashed ( & event -> hlist_entry ) ) hlist_add_head_rcu ( & event -> hlist_entry , head ) ; else hlist_replace_rcu ( & event -> hlist_entry , head ) ; synchronize_rcu ( ) ; perf_event_update_userpage ( event ) ; return 0 ; }",257,-13.327893321072153,-0.05185950708588386
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; kfree ( event ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",217,-3.8502213914395487,-0.01774295572091958
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if (!refcount_inc_not_zero(&event->refcount)) return -ENOENT; hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",233,-9.625784213247853,-0.04131237859763027
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; int retval = 0; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; retval = - EINVAL ; } else{ hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; } return retval; }",223,-10.611641895446123,-0.04758583809617096
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:"," 
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } /* Prevent use after free vulnerability */ refcount_inc( & event->refcount ); hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",230,-22.316737711136533,-0.09702929439624579
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } /* Added reference to prevent use-after-free vulnerability */ atomic_inc ( & event -> refcount ) ; hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; /* Removed reference */ atomic_dec ( & event -> refcount ) ; return 0 ; }",249,-24.80867581374044,-0.0996332361997608
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } refcount_inc(&event->refcount); hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }

void perf_swevent_del(struct perf_event* event) {
 struct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);
 hlist_del_rcu(&event->hlist_entry);
 perf_event_update_userpage(event);
 refcount_dec(&event->refcount);
}",304,-23.869661289397055,-0.07851862266249031
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; if ( swhash -> online ) { if ( head ) { //Check that head is not NULL hlist_add_head_rcu ( & event -> hlist_entry , head ) ; //Update adding the node at the head of list perf_event_update_userpage ( event ) ; } else { return - EINVAL ; } } else { head = find_swevent_head ( swhash , event ) ; hlist_add_head_rcu ( & event -> hlist_entry , head ) ; //Update adding the node at the head of list perf_event_update_userpage ( event ) ; } return 0 ; }",272,-64.78020751242875,-0.23816252761922332
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if ( event ) { hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; } else { return - ENOMEM ; } return 0 ; }",226,-12.157097436865648,-0.053792466534803754
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; rcu_read_lock (); perf_event_update_userpage ( event ) ; rcu_read_unlock (); return 0 ; }",226,-8.569232744353549,-0.03791695904581217
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } // Add a check for existing element to avoid double-free. hlist_node * node ; hlist_for_each ( node , head ) { if ( node == &event->hlist_entry ) { // Element already exists, so return. return 0 ; } } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",269,-46.736613695280624,-0.17374205834676812
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; /* Add a reference to the object to prevent it from being freed */ refcount_inc(&event->refcount); perf_event_update_userpage ( event ) ; return 0 ; }",235,-19.39262810565475,-0.08252182172619044
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; int retval = - EINVAL ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return retval ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; retval = 0 ; perf_event_update_userpage ( event ) ; return retval ; }",224,-14.302469104751053,-0.06385030850335291
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; if ( event != NULL ) { rcu_assign_pointer ( event -> hlist_entry , event ) ; } perf_event_update_userpage ( event ) ; return 0 ; }",237,-14.391436972864543,-0.06072336275470271
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; kfree(event); return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",216,-4.167537257784151,-0.01929415397122292
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; //Add in ordered list head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_tail_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",216,-30.493961481412057,-0.1411757475991299
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if ( event -> state != PERF_EVENT_STATE_ACTIVE ) { hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; } else { return - EINVAL ; } }",239,-14.068123714237348,-0.05886244231898472
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } refcount_inc ( & event -> refcount ) ; hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",223,-5.659090485067849,-0.02537708737698587
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } 

if(&event->hlist_entry != NULL){
  hlist_add_head_rcu ( & event -> hlist_entry , head ) ;
}
perf_event_update_userpage ( event ) ; return 0 ; }",231,-20.65160274015896,-0.0894008776630258
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } /* Add reference to prevent Use After Free vulnerability */ atomic_inc(&event->refcount); hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",230,-13.415852494410755,-0.058329793453959805
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; int retval = 0; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; retval = - EINVAL ; } else { hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; } /* Replace the return statement with an else statement and a variable that returns failure and success. */ return retval ; }",242,-59.441962835459535,-0.24562794560107246
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if ( ! event -> hlist_entry ) { event -> hlist_entry = kzalloc ( sizeof ( struct hlist_node ) , GFP_KERNEL ) ; if ( ! event -> hlist_entry ) return - ENOMEM ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",267,-10.80587959375315,-0.040471459152633525
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } /* added code to prevent use after free */ if ( hlist_unhashed ( & event -> hlist_entry ) ) { INIT_HLIST_NODE ( & event -> hlist_entry ) ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",258,-20.01071796604784,-0.07756092234902263
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } 

//Added to fix Use after Free
refcount_inc(&event->refcount);
hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; refcount_dec(&event->refcount);
return 0 ;
}",245,-28.03441018983715,-0.11442616404015163
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } refcount_inc(&event->refcount); hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",221,-6.065764006063552,-0.027446895955038696
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if ( event -> hlist_entry ) { hlist_add_head_rcu ( & event -> hlist_entry , head ) ; } else { event -> hlist_entry = kmalloc ( sizeof ( struct hlist_node ) , GFP_KERNEL ) ; INIT_HLIST_NODE ( event -> hlist_entry ) ; hlist_add_head_rcu ( event -> hlist_entry , head ) ; } perf_event_update_userpage ( event ) ; return 0 ; }",289,-14.554155720209053,-0.05036040041594828
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; // Add reference to event object to ensure it isn't freed prematurely. refcount_inc(&event->refcount); head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; refcount_dec(&event->refcount); return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ;
//Decrement reference counter when done.
refcount_dec(&event->refcount); return 0 ; }",265,-41.665233379914866,-0.15722729577326364
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } //Add the following two lines to prevent Use After Free  if ( event -> hlist_entry ){ hlist_del_init ( & event -> hlist_entry ) ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",250,-29.011342319559255,-0.11604536927823701
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if(event->state != PERF_EVENT_STATE_DEAD) { hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; } else { return - EINVAL ; } return 0 ; }",239,-14.880618806863952,-0.0622620033759998
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; if ( event -> hlist_entry . next != NULL ) { hlist_del_rcu ( & event -> hlist_entry ) ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",264,-13.89405754561595,-0.05262900585460587
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if ( event -> hlist_entry ) { return - EINVAL ; } event -> hlist_entry = kmalloc ( sizeof ( * event -> hlist_entry ) , GFP_KERNEL ) ; if ( ! event -> hlist_entry ) { return - ENOMEM ; } hlist_add_head_rcu ( event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; } 

The fixed code implements a fix for the CWE-416 vulnerability by first checking if the ""event->hlist_entry"" is already allocated, if so, it returns an error. If the entry is not allocated, then it allocates memory for it and adds it to the list using the hlist_add_head_rcu() function. This prevents the use of a previously freed memory, thereby mitigating the vulnerability.",364,-83.39906991468159,-0.22911832394143294
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if ( ! event -> hlist_entry ) { event -> hlist_entry = kmalloc ( sizeof ( struct hlist_node ) , GFP_KERNEL ) ; if ( ! event -> hlist_entry ) { return - ENOMEM ; } } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",268,-10.148843106377491,-0.03786881756111004
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } rcu_assign_pointer ( event -> hlist_entry , & head ) ; rcu_assign_pointer ( * head , event ) ; perf_event_update_userpage ( event ) ; return 0 ; }",223,-16.427003377908537,-0.07366369227761677
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if (!hlist_unhashed(&hwc->hlist_entry)) { hlist_del_rcu(&hwc->hlist_entry); } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",246,-14.382617600603492,-0.05846592520570525
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } refcount_inc (& event -> refcount ) ; hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",222,-9.361316459869053,-0.042168092161572315
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; /* Acquire reference to avoid Use After Free */ refcount_acquire ( & event -> refcnt ) ; return 0 ; }",235,-22.344025376159895,-0.09508095904748891
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } if ( event -> hlist_entry.pprev != NULL ) { hlist_del_rcu ( & event -> hlist_entry ) ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",244,-9.462684826001446,-0.03878149518853052
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; // add a rcu_read_lock for read-side synchronization rcu_read_lock(); // add a kref_get to take a reference for event kref_get(&event->refcount); rcu_read_unlock(); return 0 ; }",263,-44.89626113710088,-0.17070821725133414
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; // Add reference to prevent Use After Free error atomic_inc (& event -> refcount ) ; return 0 ; }",230,-22.338310124046455,-0.09712308749585415
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; /* Free the event before returning */ free(event); return - EINVAL ; } /* Acquire the lock before adding the event to the hlist. */ spin_lock(&swhash->lock); hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; spin_unlock(&swhash->lock); return 0 ; }",256,-31.024652653564605,-0.12119004942798674
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } rcu_read_lock(); hlist_add_head_rcu ( & event -> hlist_entry , head ) ; rcu_read_unlock(); perf_event_update_userpage ( event ) ; return 0 ; }",226,-5.526802144568148,-0.02445487674587676
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; //Add a reference count to prevent use-after-free event->refcount++; return 0 ; }",228,-17.78645399636289,-0.0780107631419425
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","

static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } 

if (event != NULL) {  // Added check for NULL 
   hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; 
}

return 0 ; }",236,-30.93099331931964,-0.13106353101406626
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; if (!event) { return -EINVAL; } head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } refcount_set(&event->refcount, 1); hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",235,-16.712115039935895,-0.07111538314866338
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; int ret = 0 ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; ret = - EINVAL ; goto out ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; out : 
return ret ; }",224,-13.919841805444001,-0.06214215091716072
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } // Add reference count before adding event to the list atomic_inc ( & event -> refcount ) ; hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",232,-17.053805838455283,-0.07350778378644518
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( ! swhash -> online ) { // Check to make sure we are not using a freed pointer return - EINVAL ; } if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) return - EINVAL ; hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",224,-32.21980164343145,-0.1438384001938904
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","

static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } 

// Acquire the lock and increment the reference count of the event 
mutex_lock(&event->lock); 
refcount_inc(&event->refcount);

hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ;

// Release the lock and decrement the reference count of the event
mutex_unlock(&event->lock); 
refcount_dec(&event->refcount);

return 0 ; }",293,-30.54554889041703,-0.10425102010381239
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
Fixed code:","
static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; rcu_assign_pointer(event->free_state, false); perf_event_update_userpage ( event ) ; return 0 ; }",227,-19.296375230968554,-0.08500605828620508
