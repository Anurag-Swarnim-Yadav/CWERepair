Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:"," 
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd != NULL ) {  // Check if bfqd is NULL before accessing it. bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",145,-27.924470004336335,-0.19258255175404368
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { if (timer) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",121,-5.9215025028054304,-0.04893803721326802
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = NULL; int valid_bfqq = 0; if ( bfqd->in_service_queue ) { bfqq = bfqd->in_service_queue; valid_bfqq = 1; } if (valid_bfqq) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",152,-17.722228255576606,-0.11659360694458294
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; 

// Add reference counting to check if bfqq is still in use
if (bfqd->in_service_queue && atomic_inc_not_zero(&bfqd->in_service_queue->refcount)) 
   bfqq = bfqd->in_service_queue;

if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; 

// Decrement the reference count
if (bfqq) 
	atomic_dec(&bfqq->refcount);

return HRTIMER_NORESTART ; }",205,-50.534460490699466,-0.2465095633692657
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq && atomic_read(&bfqq->ref) > 0 ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",127,-5.696143166230429,-0.04485152099394038
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { // Check if the bfqq is valid if(bfqq->ref) { bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; } } return HRTIMER_NORESTART ; }",145,-21.634020495377392,-0.1492001413474303
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { 
struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ;
if (bfqd) {
	struct bfq_queue * bfqq = bfqd -> in_service_queue ; 
	if ( bfqq ) {
		bfq_idle_slice_timer_body ( bfqq ) ;
	}
	return HRTIMER_NORESTART ;
}
return HRTIMER_NORESTART;
}",152,-20.841008237990405,-0.13711189630256845
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( ! bfqd ) return HRTIMER_NORESTART ; bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",137,-5.375223674924401,-0.039235209306017524
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { /* Use reference counter to make sure that bfq_queue is not freed */ atomic_inc(&bfqq->ref); bfq_idle_slice_timer_body ( bfqq ) ; atomic_dec(&bfqq->ref); } return HRTIMER_NORESTART ; }",152,-28.819228032315785,-0.18960018442313017
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; if ( bfqd ) { struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",124,-3.982842093241141,-0.03211969430033178
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = NULL ; if ( bfqd ) bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",128,-6.284895312714196,-0.04910074463057966
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( ! bfqd ) return HRTIMER_NORESTART ; bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; else kfree ( bfqd ) ; return HRTIMER_NORESTART ; }",147,-12.092354757690702,-0.08226091671898436
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd ; struct bfq_queue * bfqq ; if ( timer ) { bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",130,-4.741675616680198,-0.03647442782061691
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd ; struct bfq_queue * bfqq ; if ( timer ) { bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",130,-4.7521168565377545,-0.03655474505029042
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd -> in_service_queue ) { bfqq = bfqd -> in_service_queue ; bfq_idle_slice_timer_body ( bfqq ) ; } else { bfqq = NULL ; } return HRTIMER_NORESTART ; }",137,-9.326647066251049,-0.06807771581205145
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; bfqq = bfqd -> in_service_queue ; if ( bfqq ) { bfq_idle_slice_timer_body ( bfqq ) ; if ( bfqd -> in_service_queue == NULL ) { kfree ( bfqq ) ; } } return HRTIMER_NORESTART ; }",146,-20.191870117989026,-0.1383004802601988
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; 
if ( bfqq ) { if (atomic_read(&bfqq->ref) > 0) { bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; } else { return HRTIMER_RESTART; } } else { return HRTIMER_NORESTART; } }",161,-18.919930379031307,-0.11751509552193358
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer) 
{ 
    struct bfq_data *bfqd = container_of(timer, struct bfq_data, idle_slice_timer); 
    struct bfq_queue *bfqq = bfqd->in_service_queue; 
    if (bfqq) { 
        if (!refcount_inc_not_zero(&bfqq->ref)) 
            return HRTIMER_NORESTART; 
        bfq_idle_slice_timer_body(bfqq); 
        refcount_dec(&bfqq->ref); 
    } 
    return HRTIMER_NORESTART; 
}",178,-18.7886337529157,-0.10555412220739158
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq && ! bfq_check_for_use_after_free ( bfqq ) ) { bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; } return HRTIMER_NORESTART ; } 
bool bfq_check_for_use_after_free ( struct bfq_queue * bfqq ) { if ( bfqq -> in_service_queue == NULL ) { free ( bfqq ) ; return true ; } return false ; }",206,-35.4091136212878,-0.17188890107421262
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { if (refcount_inc_not_zero(&bfqq->ref)) bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec(&bfqq->ref) ; } return HRTIMER_NORESTART ; }",144,-10.645630001530598,-0.07392798612174027
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; 
if ( bfqd ) { struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; } 
return HRTIMER_NORESTART ; }",128,-10.020443874537543,-0.07828471776982455
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { if (refcount_inc_not_zero(&bfqq->ref)) { bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec(&bfqq->ref); } } return HRTIMER_NORESTART ; }",145,-5.373484286817097,-0.037058512322876526
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:"," 
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { if ( atomic_read ( & bfqq -> ref ) > 0 ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",134,-12.560007383531246,-0.09373139838456154
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { if (refcount_inc_not_zero(&bfqq->refcnt)) { bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec(&bfqq->refcnt); } } return HRTIMER_NORESTART ; }",149,-7.027972721285802,-0.04716760215628055
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { if (timer) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; if (bfqd) { struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; } }",129,-12.310594621836838,-0.09543096606075069
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; if (bfqd == NULL) { return HRTIMER_NORESTART; } struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",135,-9.142556159583126,-0.06772263821913427
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = NULL ; if ( bfqd ) bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",128,-6.282856228871801,-0.04908481428806095
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { if (bfqd->in_service_queue != NULL){ bfq_idle_slice_timer_body ( bfqq ) ; } } return HRTIMER_NORESTART ; }",132,-11.508158080944204,-0.08718301576472882
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; 
if ( bfqq ) { 
    refcount_inc(&bfqq->ref);
    bfq_idle_slice_timer_body ( bfqq ) ; 
    refcount_dec(&bfqq->ref);
}
return HRTIMER_NORESTART ; }",149,-13.519476893338599,-0.09073474425059462
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( ! bfqd || ! bfqd - > in_service_queue ) return HRTIMER_NORESTART ; bfqq = bfqd - > in_service_queue ; bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",145,-12.316719233043392,-0.08494289126236822
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( ! bfqd || ! bfqd -> in_service_queue ) return HRTIMER_NORESTART ; bfqq = bfqd -> in_service_queue ; bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",143,-7.117382730602204,-0.049771907207008415
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = NULL; if ( bfqd->in_service_queue ) { bfqq = kmemdup(bfqd->in_service_queue, sizeof(*bfqd->in_service_queue)); if (!bfqq) return HRTIMER_NORESTART; bfq_idle_slice_timer_body ( bfqq ) ; kfree(bfqq); } return HRTIMER_NORESTART ; }",167,-18.22104953255269,-0.10910808103324965
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; if ( bfqd ) { struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",124,-3.98217020570444,-0.03211427585245516
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = NULL ; 
 struct bfq_queue * bfqq = NULL;
 
  if(timer != NULL)
  {
    bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ;
    bfqq = bfqd -> in_service_queue; 
  }
  
if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",154,-43.015787364223954,-0.2793232945728828
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd -> in_service_queue ) { bfqq = bfqd -> in_service_queue ; bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",128,-5.269377595770952,-0.04116701246696056
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = NULL ; struct bfq_queue * bfqq = NULL ; if ( timer ) { bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; bfqq = bfqd -> in_service_queue ; } if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",134,-5.845807311631431,-0.04362542769874202
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( ! bfqd || ! bfqd -> in_service_queue ) { return HRTIMER_NORESTART ; } bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",151,-10.989420280937331,-0.07277761775455187
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd == NULL) { return HRTIMER_NORESTART; } // check if bfqd is null bfqq = bfq_get_queue ( bfqd ) ; // try to get queue if it's valid if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",161,-45.791675117281116,-0.28442034234336094
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = NULL ; struct bfq_queue * bfqq = NULL ; if ( timer ) { bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; } else { return HRTIMER_NORESTART ; } }",147,-10.484224633385779,-0.07132125600942707
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd ) { bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",128,-5.1507477781754005,-0.04024021701699532
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; if ( bfqd != NULL ) { struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { bfq_idle_slice_timer_body ( bfqq ) ; } } return HRTIMER_NORESTART ; }",128,-8.936110892629443,-0.06981336634866753
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd ; struct bfq_queue * bfqq ; if ( timer ) { bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",130,-4.8401934653016525,-0.037232257425397326
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd == NULL ) return HRTIMER_NORESTART ; bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }",138,-5.6909286170044,-0.04123861316669855
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ,* tmp; if (bfqd->in_service_queue) { 
    bfqq = bfqd->in_service_queue; 
    #ifdef CONFIG_SMP
    tmp = bfqq;
    #endif
    bfq_idle_slice_timer_body ( bfqq ) ; 
    #ifdef CONFIG_SMP
    if (tmp != bfqq)
        kfree(tmp);
    #endif
} 
return HRTIMER_NORESTART ; }",191,-44.744606749056125,-0.23426495680134096
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = NULL ; if ( bfqd -> in_service_queue ) { bfqq = bfqd -> in_service_queue ; bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",130,-6.0367399454527,-0.04643646111886692
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { if(bfqq->ref) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",124,-11.2063431747934,-0.09037373528059194
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ;  if ( bfqd -> in_service_queue ) { bfqq = bfqd -> in_service_queue ; bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",129,-9.740506732327836,-0.07550780412657238
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { // Add reference count to prevent Use After Free bfq_get_bfqq(bfqd, bfqq->pid, bfqq->bfqd->in_service_bic); bfq_idle_slice_timer_body ( bfqq ) ; // Release reference count once the timer has been processed bfq_put_bfqq(bfqd, bfqq); } return HRTIMER_NORESTART ; }",187,-34.66445428697158,-0.18537141329931328
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = NULL ; if ( bfqd ){ bfqq = bfqd -> in_service_queue ; if ( bfqq ){ bfq_idle_slice_timer_body ( bfqq ) ; } } return HRTIMER_NORESTART ; }",132,-10.805365731555698,-0.08185883129966438
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd != NULL ) { bfqq = bfqd->in_service_queue; if ( bfqq != NULL ) bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",132,-10.364025424476194,-0.07851534412481966
