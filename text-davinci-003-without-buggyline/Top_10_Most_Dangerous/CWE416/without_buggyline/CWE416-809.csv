Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; return ; } bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",317,-4.0979249930063615,-0.012927208179830793
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq == NULL || bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",293,-3.7759064290917284,-0.012887052659016138
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; kref_put ( & bfqq -> ref , bfq_free_bfqq_fn ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; kref_put ( & bfqq -> ref , bfq_free_bfqq_fn ) ; }",335,-7.805108601668802,-0.02329883164677254
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq) {
    struct bfq_data *bfqd = bfqq->bfqd;
    enum bfqq_expiration reason;
    unsigned long flags;
    spin_lock_irqsave(&bfqd->lock, flags);
    bfq_clear_bfqq_wait_request(bfqq);
    if (bfqq != bfqd->in_service_queue) {
        spin_unlock_irqrestore(&bfqd->lock, flags);
        return;
    }
    if (bfq_bfqq_budget_timeout(bfqq)) {
        reason = BFQQE_BUDGET_TIMEOUT;
    } else if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0) {
        reason = BFQQE_TOO_IDLE;
    }
    else
    {
        spin_unlock_irqrestore(&bfqd->lock, flags);
        goto schedule_dispatch;
    }
    bfq_bfqq_expire(bfqd, bfqq, true, reason);
    spin_unlock_irqrestore(&bfqd->lock, flags);

schedule_dispatch:
    bfq_schedule_dispatch(bfqd);
}",336,-23.083318948315583,-0.068700354012844
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; /* Added refcount to avoid Use After Free */ atomic_inc(&bfqq->refcount); return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; /* Added refcount to avoid Use After Free */ atomic_inc(&bfqq->refcount); bfq_schedule_dispatch ( bfqd ) ; }",327,-21.52876500085434,-0.06583720183747505
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = NULL ; 
if (bfqq) {
    bfqd = bfqq -> bfqd ; 
    enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ;
}
}",310,-18.601385589877367,-0.0600044696447657
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; return ; } bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",317,-4.169762831446163,-0.013153825966707139
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { bfq_schedule_dispatch ( bfqd ) ; spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",303,-9.63705776884587,-0.0318054711843098
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq) {
    struct bfq_data *bfqd = bfqq->bfqd;
    enum bfqq_expiration reason;
    unsigned long flags;
    spin_lock_irqsave(&bfqd->lock, flags);
    bfq_clear_bfqq_wait_request(bfqq);
    
    if (bfqq != bfqd->in_service_queue) {
        spin_unlock_irqrestore(&bfqd->lock, flags);
        return;
    }
    
    if (bfq_bfqq_budget_timeout(bfqq))
        reason = BFQQE_BUDGET_TIMEOUT;
    else if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)
        reason = BFQQE_TOO_IDLE;
    else
        goto schedule_dispatch;

    bfq_bfqq_expire(bfqd, bfqq, true, reason);

schedule_dispatch:
    spin_unlock_irqrestore(&bfqd->lock, flags);
    
    // Add reference check before calling bfq_schedule_dispatch()
    if (refcount_inc_not_zero(&bfqq->ref))
        bfq_schedule_dispatch(bfqd);
}",346,-38.92876941578677,-0.11251089426527967
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; int budget_timeout ; int too_idle ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; budget_timeout = bfq_bfqq_budget_timeout ( bfqq ) ; too_idle = ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; if ( budget_timeout ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( too_idle ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : bfq_schedule_dispatch ( bfqd ) ; }",318,-16.323232723512966,-0.05133092051419172
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; if ( bfqq == NULL ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",320,-5.332287406173303,-0.01666339814429157
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if ( bfqq == NULL ) return ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",297,-4.30676862120487,-0.014500904448501245
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if (!bfqq) return; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",294,-5.849107589860739,-0.019894923775036526
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq == NULL || bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",293,-3.7759064290917284,-0.012887052659016138
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = NULL ; enum bfqq_expiration reason ; unsigned long flags ; if ( ! bfqq ) { return ; } bfqd = bfqq -> bfqd ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",305,-8.34435161010437,-0.027358529869194657
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; return ; } bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",317,-4.0979249930063615,-0.012927208179830793
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , false , reason ) ; // Set false to prevent freeing the bfqq before completing // all operations related to it. schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; bfq_put_queue ( bfqq ) ; // Increment the reference count of the bfqq. }",331,-45.36772041143814,-0.13706259943032673
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if ( bfqq == NULL ) return ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",297,-4.2215561493715335,-0.014213993768927721
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if (!bfqq) { return; } spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",296,-6.04739650804237,-0.02043039360825125
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; kref_put( &bfqq->ref, bfq_queue_release); return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; kref_put( &bfqq->ref, bfq_queue_release); }",325,-10.567470151721297,-0.03251529277452707
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = NULL ; enum bfqq_expiration reason ; unsigned long flags ; if ( bfqq ) { bfqd = bfqq -> bfqd ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; } }",302,-6.741560321954335,-0.02232304742368985
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; // added bfq_ref_bfqq to get the reference count of the bfqq before expiration. bfq_ref_bfqq(bfqd, bfqq); bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; // added bfq_put_bfqq to put the reference count of the bfqq after expiration. bfq_put_bfqq(bfqd, bfqq); schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",367,-40.48356433436974,-0.1103094396031873
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; goto schedule_dispatch ; } bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : bfq_schedule_dispatch ( bfqd ) ; }",289,-4.946306197998641,-0.01711524635985689
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if ( ! bfqq ) return ; bfqd = bfqq -> bfqd ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",301,-7.698901746161362,-0.025577746664987914
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if ( ! bfqq ) return ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; } 

The vulnerability has been fixed by adding a check for a null bfqq pointer before the spin_lock_irqsave() call. This prevents the code from attempting to access or modify a freed memory address.",342,-33.2878233694955,-0.09733281686986987
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:"," 
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; goto schedule_dispatch ; } bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; schedule_dispatch : bfq_schedule_dispatch ( bfqd ) ; }",311,-8.475177820820933,-0.027251375629649303
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if (!bfqq) return; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",294,-5.796956380680984,-0.019717538709799268
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; 

// Check if bfqq is valid before proceeding.
if (bfqq == NULL) return;

spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; 
// Check if bfqq is valid before freeing.
if (bfqq != NULL) kfree(bfqq); }",340,-32.75323404213822,-0.09633304130040653
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; 
//avoid use after free 
if(bfqq == NULL) 
{ 
spin_unlock_irqrestore(&bfqd->lock,flags); 
return; 
}
bfq_clear_bfqq_wait_request ( bfqq ) ; 
if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",335,-33.89660144518469,-0.10118388491099908
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; kfree ( bfqq ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; bfq_schedule_dispatch ( bfqd ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; kfree ( bfqq ) ; }",303,-8.482729449158033,-0.0279958067628978
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq) {
  struct bfq_data *bfqd = bfqq->bfqd;
  enum bfqq_expiration reason;
  unsigned long flags;
  spin_lock_irqsave(&bfqd->lock, flags);
  bfq_clear_bfqq_wait_request(bfqq);
  if (bfqq != bfqd->in_service_queue) {
    spin_unlock_irqrestore(&bfqd->lock, flags);
    return;
  }
  if (bfq_bfqq_budget_timeout(bfqq))
    reason = BFQQE_BUDGET_TIMEOUT;
  else if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)
    reason = BFQQE_TOO_IDLE;
  else
    goto schedule_dispatch;
  bfq_bfqq_expire(bfqd, bfqq, true, reason);
  /* Add reference to bfqq after unlocking */
  bfqq->ref++;
  spin_unlock_irqrestore(&bfqd->lock, flags);
  bfq_schedule_dispatch(bfqd);
  /* Release reference */
  bfq_put_queue(bfqq);
}",335,-32.588367493454605,-0.09727870893568538
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; return ; } bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",322,-6.3244852461336185,-0.019641258528365273
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ;  schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",325,-13.431970836218124,-0.041329141034517305
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) {
 struct bfq_data * bfqd;
 enum bfqq_expiration reason ;
 unsigned long flags ;
 
 bfqd = bfqq -> bfqd ;
 spin_lock_irqsave ( & bfqd -> lock , flags ) ;
 
 // add reference count to avoid use after free vulnerability
 refcount_inc(&bfqq->ref); 
 bfq_clear_bfqq_wait_request ( bfqq ) ;
 if ( bfqq != bfqd -> in_service_queue ) {
  refcount_dec(&bfqq->ref); // decrease reference count
  spin_unlock_irqrestore ( & bfqd -> lock , flags ) ;
  return ;
 }
 if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ;
 else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ;
 else goto schedule_dispatch ;
 bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ;
 
 schedule_dispatch :
 refcount_dec(&bfqq->ref);
 spin_unlock_irqrestore ( & bfqd -> lock , flags ) ;
 bfq_schedule_dispatch ( bfqd ) ;
}",368,-55.507083862145144,-0.15083446701669875
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if ( bfqq == NULL ) return ; bfqd = bfqq -> bfqd ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",302,-5.76110223964986,-0.019076497482284304
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_clear_bfqq_wait_request ( bfqq ) ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",287,-6.076177394461034,-0.021171349806484437
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { 
struct bfq_data * bfqd = NULL ;
enum bfqq_expiration reason ; 
unsigned long flags ; 
if (!bfqq) 
return ;
bfqd = bfqq -> bfqd ; 
spin_lock_irqsave ( & bfqd -> lock , flags ) ; 
bfq_clear_bfqq_wait_request ( bfqq ) ; 
if ( bfqq != bfqd -> in_service_queue ) { 
spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; 
return ; 
} 
if ( bfq_bfqq_budget_timeout ( bfqq ) ) 
reason = BFQQE_BUDGET_TIMEOUT ; 
else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) 
reason = BFQQE_TOO_IDLE ; 
else goto schedule_dispatch ; 
if (bfqd) 
bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; 
schedule_dispatch : 
spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; 
if (bfqd) 
bfq_schedule_dispatch ( bfqd ) ; 
}",356,-27.606164759365875,-0.07754540662743223
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if ( bfqq == NULL ) { return ; } spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",299,-4.483841330732594,-0.014996124851948475
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if ( bfqq == NULL ) return ; bfqd = bfqq -> bfqd ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",302,-5.76110223964986,-0.019076497482284304
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; int refcount = 0; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; 
if (refcount == 0) { //add refcount and check it
   bfq_put_queue(bfqq);
   refcount++;
}
schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; 
if (refcount > 0) { // decrement refcount
   bfq_put_queue(bfqq);
   refcount--;
}
}",369,-52.224030869593996,-0.14152853894198913
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if ( bfqq == NULL ) return ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",297,-4.293556261508185,-0.014456418388916446
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; return ; } bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",317,-4.246725150160791,-0.013396609306500919
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",301,-5.679079776401118,-0.018867374672428966
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; 

if ( bfqq != NULL ) { 
    spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; 
} 
}",307,-15.21450935418263,-0.04955866239147436
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:"," 
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; if ( bfqq == NULL ) { return ; } spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",300,-7.433506065589427,-0.024778353551964755
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:"," 
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; 
if(bfqq == NULL) {
   return;
}
spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",305,-15.489219300366262,-0.05078432557497135
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq == NULL || bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",293,-3.7917600672496805,-0.012941160639077407
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:"," 
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq == NULL || bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",294,-7.27692892234387,-0.02475145891953697
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else if (atomic_read(&bfqq->ref) > 0) goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",301,-10.85069040044889,-0.03604880531710595
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the vulnerability.
Original Code:
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
Fixed code:","
static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) { struct bfq_data * bfqd = bfqq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; spin_lock_irqsave ( & bfqd -> lock , flags ) ; bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else { bfq_bfqq_refinc ( bfqq ) ; spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; goto schedule_dispatch ; } bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; bfq_bfqq_refdec ( bfqq ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }",340,-15.190824002763232,-0.044678894125774214
