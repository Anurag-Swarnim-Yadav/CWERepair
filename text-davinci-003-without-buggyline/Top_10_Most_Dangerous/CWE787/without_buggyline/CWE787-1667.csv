Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len > 0 && id_len < TGA_HEADER_SIZE ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",622,-6.484662846342259,-0.010425502968395913
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; if(image_w > *width) * width = ( unsigned int ) image_w ; if(image_h > *height) * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",626,-9.978125026841001,-0.01593949684798882
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:"," 
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len > 0 && id_len <= TGA_HEADER_SIZE ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; if (fseek ( fp , palette_size , SEEK_CUR ) != 0) { fprintf(stderr, ""Error: fseek failed.\n""); return 0; } } return 1 ; }",649,-17.535104045911748,-0.0270186503018671
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; if (image_w > TGA_HEADER_SIZE || image_h > TGA_HEADER_SIZE) { return 0; } * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",639,-9.435395508595558,-0.014765877165251264
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; //Added check to ensure that the values read are within the range of the array if (id_len > TGA_HEADER_SIZE || image_type > TGA_HEADER_SIZE || cmap_len > TGA_HEADER_SIZE || cmap_entry_size > TGA_HEADER_SIZE || image_w > TGA_HEADER_SIZE || image_h > TGA_HEADER_SIZE || pixel_depth > TGA_HEADER_SIZE || image_desc > TGA_HEADER_SIZE) { fprintf(stderr, ""Invalid values read from header. Out-of-bounds write detected.\\n""); return 0; } * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",757,-42.90692651463164,-0.056680219966488296
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread_s ( tga , TGA_HEADER_SIZE , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread_s ( id , id_len , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek_s ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",626,-7.166990377340131,-0.011448866417476248
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; if ( image_w > MAX_SIZE || image_h > MAX_SIZE ) { fprintf ( stderr , ""\\nError: Width/Height out of bounds.\\n"" ) ; return 0 ; } * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",655,-19.494452358385555,-0.0297625226845581
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == NULL ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } 
if ( id_len > 0 && id_len < TGA_HEADER_SIZE ) { // Validate the length of the ID before copying it to prevent out of bounds write.
  memcpy(tga, id, id_len); 
  free ( id ) ; 
} 
else {
  fprintf ( stderr , ""Error: invalid ID length.\\n"" );
  return 0; 
}
if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",702,-61.81235146939636,-0.08805178271993784
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } 
if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } 

id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; 

# if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; 

if (image_w <= 0 || image_h <= 0) { fprintf(stderr, ""Invalid image width or height\n""); return 0; }

* bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; 

if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } 

if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; 

palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",666,-32.44548429337017,-0.048716943383438696
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","

static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len > 0 && id_len <= TGA_HEADER_SIZE ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 && palette_size <= TGA_HEADER_SIZE ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",635,-9.28510164536392,-0.014622207315533731
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len > 255 ) { fprintf ( stderr , ""Error: id_len is out of bounds.\\n"" ) ; return 0 ; } if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",644,-14.314812113881892,-0.022227969120934617
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len > 0 ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( !id ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; // Added check to make sure seek does not overflow long position. if (palette_size > LONG_MAX - ftell(fp)) { fprintf(stderr, ""Error: palette size to large to seek.""); return 0; } fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",661,-51.970486132334294,-0.07862403348310786
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin =get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len > 0 && id_len < TGA_HEADER_SIZE ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 &&  palette_size < TGA_HEADER_SIZE ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",635,-22.210733906452816,-0.03497753371094932
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; if (image_w > MAX_WIDTH || image_h > MAX_HEIGHT) { fprintf(stderr,""Image size exceeds the maximum allowed size.\n""); return 0; } pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",652,-23.172238376646266,-0.035540242908966665
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread_s ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread_s ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek_s ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",614,-6.956402081417833,-0.0113296450837424
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:"," 
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; 
    cmap_len = get_ushort ( & tga [ 5 ] ) ; 
    if (cmap_len > 0) {
        cmap_entry_size = tga [ 7 ] ;
    }
# if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; if(fseek ( fp , palette_size , SEEK_CUR ) != 0) { fprintf(stderr, ""Error: Out of bounds write attempt prevented.\n""); return 0; } } return 1 ; }",660,-47.937553534176466,-0.07263265686996434
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; 
unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } 
id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 
x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; 
if (id_len > TGA_HEADER_SIZE) { //Added to prevent out-of-bounds write 
fprintf ( stderr , ""\\nError: Header length exceeds the expected.\\n"" ) ;
return 0 ;
} * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) {
unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; 
return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ;
free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; }
 return 1 ; }",678,-75.76235932671398,-0.1117438928122625
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { if ( id_len > TGA_HEADER_SIZE ) { fprintf ( stderr , ""Error: id_len is too large.\\n"" ) ; return 0 ; } unsigned char * id = ( unsigned char * ) calloc ( id_len , sizeof ( char ) ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; if ( fseek ( fp , palette_size , SEEK_CUR ) != 0 ) { fprintf ( stderr , ""\\nError: fseek failed.\\n"" ) ; return 0 ; } } return 1 ; }",684,-28.98044793393976,-0.042369075926812515
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } if (id_len > TGA_HEADER_SIZE) { //Added to fix vulnerability free ( id ) ; return 0; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",637,-17.677997480533723,-0.02775195836818481
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; if ( image_w > 0 && image_h > 0) { * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; } else { return 0; } if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",630,-10.349366260336335,-0.016427565492597357
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) || id_len > MAX_ID_LEN ) { //Check for out-of-bounds write fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",629,-20.16785290539759,-0.03206335915007566
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; 
if (id_len > 0 && id_len < TGA_HEADER_SIZE){
    unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; 
    if ( id == 0 ) { 
        fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; 
        return 0 ; 
    }
    if ( ! fread ( id , id_len , 1 , fp ) ) { 
        fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; 
        free ( id ) ; 
        return 0 ; 
    } 
    free ( id ) ; 
} 
if ( image_type > 8 ) { 
    fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; 
    return 0 ; 
} 
* flip_image = ! ( image_desc & 32 ) ; 
palette_size = cmap_len * ( cmap_entry_size / 8 ) ; 
if ( palette_size > 0 ) { 
    fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; 
    if (fseek ( fp , palette_size , SEEK_CUR ) != 0) {
      fprintf ( stderr , ""Error: Out-of-Bounds write.\\n"" ) ;
      return 0;
    }
} 
return 1 ; 
}",722,-36.71108601410612,-0.05084637952092261
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len + 1) ; //added +1 if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } id[id_len] = '\0'; //added NULL terminator free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",630,-17.78900998974723,-0.02823652379324957
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; if (pixel_depth > (8 * sizeof(*bits_per_pixel))) { fprintf(stderr, ""Pixel depth too large""); return 0; } * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",643,-20.06478108749122,-0.031204947258928802
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; 

//Ensure that the size of the header entry is not exceeded 
if (id_len > TGA_HEADER_SIZE) {
    fprintf ( stderr , ""\\nError: id_len exceeds maximum size.\\n"" ) ; 
    return 0 ;
}
if (id_len) {
    unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; 
    if ( id == 0 ) { 
        fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; 
        return 0 ; 
    } 
    if ( ! fread ( id , id_len , 1 , fp ) ) { 
        fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; 
        free ( id ) ; 
        return 0 ; 
    } 
    free ( id ) ; 
} 
if ( image_type > 8 ) { 
    fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; 
    return 0 ; 
} 
* flip_image = ! ( image_desc & 32 ) ; 
palette_size = cmap_len * ( cmap_entry_size / 8 ) ; 
if ( palette_size > 0 ) { 
    //Ensure that the size of the palette is not exceeded
    if (palette_size > TGA_HEADER_SIZE) {
        fprintf ( stderr , ""\\nError: palette_size exceeds maximum size.\\n"" ) ; 
        return 0 ;
    }
    fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; 
    fseek ( fp , palette_size , SEEK_CUR ) ; 
} 
return 1 ; 
}",806,-60.232254562666405,-0.07472984437055386
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; if ( bits_per_pixel && width && height && flip_image ) { * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; } else { fprintf ( stderr , ""Invalid parameters\\n"" ) ; return 0 ; } if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",622,-20.21707431226233,-0.032503334907174164
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { 
int palette_size ; 
unsigned char tga [ TGA_HEADER_SIZE ] ; 
unsigned char id_len , image_type ; 
unsigned char pixel_depth , image_desc ; 
unsigned short cmap_len , cmap_entry_size ; 
unsigned short image_w , image_h ; 
if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { 
   return 0 ; 
} 
if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { 
   fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; 
   return 0 ; 
} 
id_len = tga [ 0 ] ; 
image_type = tga [ 2 ] ; 
cmap_len = get_ushort ( & tga [ 5 ] ) ; 
cmap_entry_size = tga [ 7 ] ; 
# if 0 
   x_origin = get_ushort ( & tga [ 8 ] ) ; 
   y_origin = get_ushort ( & tga [ 10 ] ) ; 
# endif 
image_w = get_ushort ( & tga [ 12 ] ) ; 
image_h = get_ushort ( & tga [ 14 ] ) ; 
pixel_depth = tga [ 16 ] ; 
image_desc = tga [ 17 ] ; 
if (bits_per_pixel != NULL) {
   * bits_per_pixel = ( unsigned int ) pixel_depth ; 
}
if (width != NULL) {
   * width = ( unsigned int ) image_w ;
}
if (height != NULL) {
   * height = ( unsigned int ) image_h ;
}
if ( id_len ) { 
   unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; 
   if ( id == 0 ) { 
      fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; 
      return 0 ; 
   } 
   if ( ! fread ( id , id_len , 1 , fp ) ) { 
      fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; 
      free ( id ) ; 
      return 0 ; 
   } 
   free ( id ) ; 
} 
if ( image_type > 8 ) { 
   fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; 
   return 0 ; 
} 
if (flip_image != NULL) {
   * flip_image = ! ( image_desc & 32 ) ; 
}

palette_size = cmap_len * ( cmap_entry_size / 8 ) ; 
if ( palette_size > 0 ) { 
   fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; 
   fseek ( fp , palette_size , SEEK_CUR ) ; 
} 
return 1 ; 
}",785,-29.88250598466867,-0.038066886604673465
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; 

if ( id_len > 0 ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; 

if (cmap_len * ( cmap_entry_size / 8 ) > 0) {
    palette_size = cmap_len * ( cmap_entry_size / 8 ) ; 
    if ( palette_size > 0 ) { 
        unsigned char * palette = (unsigned char *)malloc(palette_size);
        if (palette == 0) { 
            fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ;
            return 0;
        }
        if ( ! fread ( palette , palette_size , 1 , fp ) ) { 
            fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ;
            free(palette);
            return 0 ;
        }
        free(palette);
    }
}

return 1 ; }",749,-38.74621724972889,-0.05173059712914405
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { if ( id_len > TGA_HEADER_SIZE) { fprintf ( stderr , ""\\nError: id_len is larger than TGA_HEADER_SIZE\\n"" ) ; return 0; } unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; if ( fseek ( fp , palette_size , SEEK_CUR ) != 0 ) { fprintf ( stderr , ""\\nError: fseek return a number of element different from the expected.\\n"" ) ; return 0; } } return 1 ; }",695,-27.421254337588042,-0.0394550422123569
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; if (image_w > *width || image_h > *height) { // Check for out of bounds write fprintf ( stderr , ""\\nError: Out of bounds write.\\n"" ) ; return 0 ; } * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",658,-21.42842777309271,-0.032565999655156094
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len * sizeof(unsigned char) ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len * sizeof(unsigned char), 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; 

//Validate and check that the value of palette_size is within bounds of fp
if (fseek(fp, palette_size, SEEK_CUR) == -1) { 
    fprintf(stderr, ""Error: Out of bounds write attempt on fp.\n"");
    return 0;
}
return 1 ; }",678,-60.9830319449725,-0.08994547484509219
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","

static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len + 1 ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } id[id_len] = '\0'; //ADDED FOR SECURITY free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",629,-19.29385869533174,-0.030673861200845372
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:"," 
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { if ( id_len > TGA_HEADER_SIZE ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } unsigned char id[TGA_HEADER_SIZE]; if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",601,-14.492093837200805,-0.024113300893844933
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len > 0 && id_len <= 255 ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }

The vulnerability is fixed by adding a check to ensure that the id_len is less than or equal to 255. This check ensures that the id array that is being allocated to store the id is not allocated beyond its capacity, thus preventing any out-of-bounds writes.",674,-53.92680971909898,-0.08001010344079967
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len > 0 ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; if(fseek(fp, palette_size, SEEK_CUR) < 0) { fprintf(stderr, ""Error in fseek\n""); return 0; } } return 1 ; }",633,-18.093289671189797,-0.028583396005039174
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { if ( id_len > TGA_HEADER_SIZE ) { fprintf ( stderr , ""tga_readheader: id_len is too large\\n"" ) ; return 0 ; } unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { if ( palette_size > TGA_HEADER_SIZE ) { fprintf ( stderr , ""tga_readheader: palette_size is too large\\n"" ) ; return 0 ; } fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",696,-14.479883184203008,-0.020804429862360644
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len == 0 || id_len >= TGA_HEADER_SIZE ) { fprintf ( stderr , ""\\nError: id_len is out of bounds.\\n"" ) ; return 0 ; } else { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",653,-17.661347472900886,-0.02704647392480993
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == NULL ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; if (fseek ( fp , palette_size , SEEK_CUR ) < 0 ) {  fprintf(""fseek failed"");  return 0; } } return 1 ; }",626,-31.95287287476764,-0.05104292791496428
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; 

if (id_len > TGA_HEADER_SIZE){
    fprintf(stderr, ""Error: ID length exceeds the size of the header.\n"");
    return 0;
}

* bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",658,-20.60891480017986,-0.03132053920999979
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; if (image_w > 0 && image_w < UINT_MAX) { * width = ( unsigned int ) image_w ; } else { return 0; } if (image_h > 0 && image_h < UINT_MAX) { * height = ( unsigned int ) image_h ; } else { return 0; } if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",658,-11.429901501516335,-0.017370670974948838
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; 
// Validate cmap_len is within bounds
if (cmap_len > TGA_HEADER_SIZE) {
	fprintf ( stderr , ""Error: cmap_len is out of bounds.\\n"" ) ;
	return 0 ;
}
 
 # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; 
// Validate palette_size is within bounds
if (palette_size > TGA_HEADER_SIZE) {
	fprintf ( stderr , ""Error: palette_size is out of bounds.\\n"" ) ;
	return 0 ;
}
fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",734,-39.263805451241694,-0.05349292295809495
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ;  #if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; #endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; if( image_w > INT_MAX || image_h > INT_MAX ) { printf(""Image dimensions are too large.""); return 0; } pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",641,-29.3690000157603,-0.045817472723495005
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } if (image_desc & 32) { * flip_image = 0; } else { * flip_image = 1; } palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",621,-12.881830505682133,-0.020743688414947076
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len > 0 && id_len <= TGA_HEADER_SIZE ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; if (fseek ( fp , palette_size , SEEK_CUR) != 0) { // Fix fprintf ( stderr , ""Error seeking in file.\\n"" ) ; return 0 ; } } return 1 ; }",651,-30.06532059272487,-0.0461832881608677
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; #if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; #endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; 

if (id_len > TGA_HEADER_SIZE) { 
    printf(""Error: id_len is greater than TGA_HEADER_SIZE\n""); 
    return 0; 
} 

*bits_per_pixel = (unsigned int)pixel_depth ; *width = (unsigned int)image_w ; *height = (unsigned int)image_h ; 

if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } 

if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } *flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; 

if ( palette_size > 0 ) { 
    if (palette_size > TGA_HEADER_SIZE) { 
        printf(""Error: palette_size is greater than TGA_HEADER_SIZE\n""); 
        return 0; 
    } 
    fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; 
} 

return 1 ; }",731,-39.49055534988399,-0.054022647537461
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; if ( image_w > 0 && image_h > 0 ) { * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; } else { return 0; } if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",630,-8.040996493945187,-0.012763486498325692
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; // bounds check added if (cmap_entry_size > TGA_HEADER_SIZE) { fprintf ( stderr , ""Cmap Entry Size is greater than the header size (TGA_HEADER_SIZE).\\n"" ) ; return 0 ; } # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",666,-37.722020551002544,-0.05663967049700082
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) || id_len < 0) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; if ( palette_size > 0 && palette_size < LONG_MAX ) { 
        fseek ( fp , palette_size , SEEK_CUR ) ; 
    } else { 
        return 0; 
    } 
 } return 1 ; }",652,-29.991002453117584,-0.045998470020118996
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; if ( id_len > 0 ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { if ( palette_size > id_len ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } else { fprintf ( stderr , ""Error: Out-of-Bounds Write\\n"" ) ; return 0 ; } } return 1 ; }",650,-21.96356468044425,-0.03379009950837577
"The Original Code is vulnerable to CWE-787: Out-of-Bounds Write. Fix the vulnerability.
Original Code:
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
Fixed code:","
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len > 0 ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader: memory out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError: fread return a number of element different from the expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry, compressed tga files are not currently supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File contains a palette - not yet supported."" ) ; if (fseek(fp,palette_size,SEEK_CUR) != 0) { fprintf(stderr, ""Error: fseek failed\n""); return 0; } } return 1 ; }",635,-19.3652251621207,-0.030496417578142837
