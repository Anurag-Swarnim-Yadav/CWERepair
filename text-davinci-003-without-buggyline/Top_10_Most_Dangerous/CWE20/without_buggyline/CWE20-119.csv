Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; 

//Validate the input
if ( host_irq == 0 || guest_irq == 0 || ! kvm || ! set ) { return -EINVAL; }

if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; 

//Validate the input
if ( guest_irq >= irq_rt -> nr_rt_entries ) { srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return -EINVAL; }

hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",757,-24.195880943008937,-0.03196285461427865
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq > irq_rt -> nr_rt_entries ) return - EINVAL ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",677,-7.686063104047279,-0.011353121276288448
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 

// Added input validation 
if(guest_irq >= irq_rt->nr_rt_entries) {
  printk(KERN_INFO ""Invalid guest_irq: %d\n"", guest_irq);
  return -EINVAL;
}

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",743,-20.792097640646674,-0.027983980673817865
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; // Validate user input if (guest_irq < 0 || guest_irq > irq_rt->nr_rt_entries) { printk(KERN_INFO ""Invalid input\n""); return -EINVAL; } idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",728,-22.654545906806746,-0.031118881740119158
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq > UINT32_MAX || set > 1 ) { return -EINVAL; } 

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",703,-22.667487171837497,-0.032243936233054764
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:"," 

static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; // Validate the input if ( guest_irq > KVM_MAX_IRQ_ROUTING_ENTRIES || host_irq > KVM_MAX_IRQS) return -EINVAL; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",725,-24.39405117008659,-0.03364696713115392
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) return 0; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",674,-7.941696979613811,-0.011782933204174794
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) return -EINVAL; // Added input validation 

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",708,-11.020684408984623,-0.015565938430769241
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 

//Input validation added 
if(guest_irq > irq_rt->nr_rt_entries) {
  return -EINVAL;
}

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; 

//Input validation removed
//BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ;

hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",727,-26.35061325208515,-0.03624568535362469
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; //Add input validation if(!kvm || host_irq < 0 || guest_irq < 0) { return -EINVAL; } idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",707,-15.546536768195507,-0.021989443802256727
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","

static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) {return - EINVAL; }  idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",681,-16.190999781210877,-0.023775330075199524
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 

if (guest_irq >= irq_rt->nr_rt_entries) {
  ret = -EINVAL;
  goto out;
} 

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",718,-14.14831823329361,-0.019705178597901964
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 
if ( guest_irq >= irq_rt -> nr_rt_entries ) {
    printk(KERN_INFO ""Invalid guest IRQ: %u\\n"", guest_irq);
    return -EINVAL;
}
idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ;

BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",735,-19.38076684166784,-0.02636839026077257
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 

//Added input validation
if ( guest_irq > irq_rt -> nr_rt_entries ) return -EINVAL;

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",711,-13.695453718097056,-0.01926224151631091
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","

static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq, uint32_t guest_irq, bool set) {
    struct kvm_kernel_irq_routing_entry *e;
    struct kvm_irq_routing_table *irq_rt;
    struct kvm_lapic_irq irq;
    struct kvm_vcpu *vcpu;
    struct vcpu_data vcpu_info;
    int idx, ret = -EINVAL;
    
    if (!kvm_arch_has_assigned_device(kvm) || !irq_remapping_cap(IRQ_POSTING_CAP) ||
        !kvm_vcpu_apicv_active(kvm->vcpus[0]) || guest_irq >= irq_rt->nr_rt_entries) 
        return 0;
    
    idx = srcu_read_lock(&kvm->irq_srcu);
    irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
    BUG_ON(guest_irq >= irq_rt->nr_rt_entries);
    hlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {
        if (e->type != KVM_IRQ_ROUTING_MSI) continue;
        kvm_set_msi_irq(kvm, e, &irq);
        if (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) {
            ret = irq_set_vcpu_affinity(host_irq, NULL);
            if (ret < 0) {
                printk(KERN_INFO ""failed to back to remapped mode, irq: %u\\n"", host_irq);
                goto out;
            }
            continue;
        }
        vcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));
        vcpu_info.vector = irq.vector;
        trace_kvm_pi_irte_update(vcpu->vcpu_id, host_irq, e->gsi, vcpu_info.vector, vcpu_info.pi_desc_addr, set);
        if (set)
            ret = irq_set_vcpu_affinity(host_irq, &vcpu_info);
        else {
            pi_set_sn(vcpu_to_pi_desc(vcpu));
            ret = irq_set_vcpu_affinity(host_irq, NULL);
            pi_clear_sn(vcpu_to_pi_desc(vcpu));
        }
        if (ret < 0) {
            printk(KERN_INFO ""%s: failed to update PI IRTE\\n"", __func__);
            goto out;
        }
    }
    ret = 0;
    
out:
    srcu_read_unlock(&kvm->irq_srcu, idx);
    return ret;
}",759,-22.277066194892736,-0.02935054834636724
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) { ret = -EINVAL; goto out; } idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",683,-6.7224610837891925,-0.009842549170994426
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 
//Validate if the guest_irq is within the range of nr_rt_entries. 
if ( guest_irq >= irq_rt -> nr_rt_entries ) return -EINVAL;

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",705,-26.53883661922039,-0.03764373988541899
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; //Validate input if (host_irq <= 0 || guest_irq > irq_rt->nr_rt_entries || !e || !irq_rt) { printk(KERN_INFO ""%s: Invalid input\\n"" , __func__) ; return -EINVAL; } idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",719,-36.54615493240697,-0.050829144551330974
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) { return -EINVAL; } //Validate input idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",683,-14.178876637832973,-0.02075970225158561
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) return -EINVAL; 
idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",679,-7.6867859860711025,-0.011320745193035497
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; 

//Validate input
if ( guest_irq >= irq_rt -> nr_rt_entries ) 
    return 0;
    
if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) 
    return 0 ; 


idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",718,-25.156045577730215,-0.03503627517789724
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; // Add input validation to check if guest_irq is valid if ( guest_irq >= irq_rt -> nr_rt_entries ) { return -EINVAL; } idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",716,-16.127491387809123,-0.022524429312582573
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 

if (guest_irq >= irq_rt->nr_rt_entries)
{
    ret = -EINVAL;
    goto out;
}

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; 

hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",697,-13.206929933855827,-0.01894824954642156
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) return -EINVAL; // Added input validation idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",705,-9.020963464901344,-0.012795692858016091
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; 

//Add input validation
if ( host_irq < 0 || guest_irq < 0 ) return 0 ;

if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ;

//Add input validation
if(irq_rt->nr_rt_entries < guest_irq) return 0;

hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",711,-27.426301817724784,-0.038574264159950473
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq < 0 || guest_irq >= irq_rt -> nr_rt_entries ) { ret = - EINVAL ; goto out ; } idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",714,-10.940210567634217,-0.015322423764193582
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if(guest_irq >= irq_rt -> nr_rt_entries) { return -EINVAL; } idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",680,-8.243792102645928,-0.012123223680361658
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 
// Validate input 
if(host_irq == 0 || guest_irq >= irq_rt->nr_rt_entries) return -EINVAL; 
idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",717,-20.39855468562023,-0.028449867065021242
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; // Added: Validate that the guest_irq is within the range of the irq routing table if ( guest_irq >= irq_rt -> nr_rt_entries ) return -EINVAL; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",722,-23.44879910348614,-0.03247756108516086
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) return - EINVAL; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",677,-7.304512257156701,-0.010789530660497343
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) 
{
        printk(KERN_INFO ""Invalid guest_irq number: %d\n"", guest_irq);
        return -EINVAL;
} 
idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",713,-26.005101678950425,-0.036472793378612096
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; // Validate guest_irq if ( guest_irq < 0 || guest_irq >= irq_rt -> nr_rt_entries ) return -EINVAL ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",691,-13.56456163055842,-0.01963033521064894
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; 

// Validate input
if (kvm == NULL || host_irq == 0 || guest_irq == 0) return 0;

if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",709,-16.145091933008697,-0.022771638833580674
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if( guest_irq >= irq_rt -> nr_rt_entries ) return -EINVAL; 

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",680,-13.888969103506195,-0.0204249545639797
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) return 0; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",698,-8.1667327284147,-0.011700190155321921
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; 
if ( ! kvm || guest_irq > KVM_MAX_IRQ_ROUTES || ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 
idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; if ( guest_irq >= irq_rt -> nr_rt_entries ) { srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return - EINVAL ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",726,-22.07883091334015,-0.030411612828292214
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; // Validate input before using it if ( guest_irq >= irq_rt -> nr_rt_entries ) { printk ( KERN_INFO ""Invalid guest_irq value\\n"" ) ; return - EINVAL ; } if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",705,-21.41166982132197,-0.03037116286712336
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( ! is_valid_guest_irq ( guest_irq ) ) return - EINVAL ; 
idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",702,-13.933127606763001,-0.01984776012359402
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { 
struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 
 
//Validate the guest_irq
if (guest_irq < 0 || guest_irq > 255) {
  printk(KERN_INFO ""Invalid guest_irq: %u\\n"", guest_irq);
  return -EINVAL;
}
 
idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",747,-34.64853555418153,-0.04638358173250539
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","

static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) { //Added validation of guest_irq return -EINVAL; } idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",688,-16.347218209996864,-0.023760491584297768
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; //Validate guest_irq to make sure it is within range of the routing table if ( guest_irq >= irq_rt -> nr_rt_entries ) { printk ( KERN_INFO ""%s: Invalid guest_irq %d specified.\\n"" , __func__ , guest_irq ) ; return - EINVAL ; } idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",730,-33.11862118634057,-0.045367974227863796
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) {
 struct kvm_kernel_irq_routing_entry * e ; 
 struct kvm_irq_routing_table * irq_rt ; 
 struct kvm_lapic_irq irq ; 
 struct kvm_vcpu * vcpu ; 
 struct vcpu_data vcpu_info ; 
 int idx , ret = - EINVAL ; 
 
 if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 
 
 // perform input validation
 if (guest_irq >= irq_rt -> nr_rt_entries) {
	printk(KERN_INFO ""Error: Invalid input value for guest_irq!\n"");
	return -EINVAL;
 }
 
 idx = srcu_read_lock ( & kvm -> irq_srcu ) ; 
 irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; 
 BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; 
 hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { 
	if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; 
	kvm_set_msi_irq ( kvm , e , & irq ) ; 
	if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { 
		ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; 
		if ( ret < 0 ) { 
			printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; 
			goto out ; 
		} 
		continue ; 
	} 
	vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; 
	vcpu_info . vector = irq . vector ; 
	trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; 
	if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; 
	else { 
		pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; 
		ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; 
		pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; 
	} 
	if ( ret < 0 ) { 
		printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; 
		goto out ; 
	} 
 } 
 ret = 0 ; 
 out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; 
 return ret ; 
}",858,-43.14793121541668,-0.05028896412053226
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; // Validate Input if (host_irq < 0 || guest_irq < 0) return 0; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",698,-15.677409741223133,-0.022460472408629133
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; 

if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; 

if ( guest_irq >= irq_rt -> nr_rt_entries ) {
    return ret;
}

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; 

hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",690,-13.031827396002182,-0.018886706371017654
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; //Added input validation if ( host_irq < 0 || host_irq > MAX_HOST_IRQS || guest_irq < 0 || guest_irq > MAX_GUEST_IRQS ) return - EINVAL ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",729,-18.017620664400248,-0.024715529032099105
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ;

if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ;

// Validate input
if (guest_irq >= irq_rt->nr_rt_entries || host_irq < 0) {
    printk(KERN_INFO ""Invalid input to vmx_update_pi_irte\n"");
    return -EINVAL;
}

idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ;

hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",727,-30.40839839361735,-0.04182723300360021
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq, uint32_t guest_irq, bool set) {
	struct kvm_kernel_irq_routing_entry *e;
	struct kvm_irq_routing_table *irq_rt;
	struct kvm_lapic_irq irq;
	struct kvm_vcpu *vcpu;
	struct vcpu_data vcpu_info;
	int idx, ret = -EINVAL;

	if(!kvm_arch_has_assigned_device(kvm) || !irq_remapping_cap(IRQ_POSTING_CAP) || !kvm_vcpu_apicv_active(kvm->vcpus[0]))
		return 0;
	
	if(guest_irq >= irq_rt->nr_rt_entries) {
		printk(KERN_INFO ""%s: guest_irq is out of range\\n"", __func__);
		return -EINVAL;
	}
	
	idx = srcu_read_lock(&kvm->irq_srcu);
	irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
	
	BUG_ON(guest_irq >= irq_rt->nr_rt_entries);
	
	hlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {
		if(e->type != KVM_IRQ_ROUTING_MSI)
			continue;
	
		kvm_set_msi_irq(kvm, e, &irq);
		
		if(!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) {
			ret = irq_set_vcpu_affinity(host_irq, NULL);
			if(ret < 0) {
				printk(KERN_INFO ""failed to back to remapped mode, irq: %u\\n"", host_irq);
				goto out;
			}
			continue;
		}
		
		vcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));
		vcpu_info.vector = irq.vector;
		
		trace_kvm_pi_irte_update(vcpu->vcpu_id, host_irq, e->gsi, vcpu_info.vector, vcpu_info.pi_desc_addr, set);
		
		if(set)
			ret = irq_set_vcpu_affinity(host_irq, &vcpu_info);
		else {
			pi_set_sn(vcpu_to_pi_desc(vcpu));
			ret = irq_set_vcpu_affinity(host_irq, NULL);
			pi_clear_sn(vcpu_to_pi_desc(vcpu));
		}
		
		if(ret < 0) {
			printk(KERN_INFO ""%s: failed to update PI IRTE\\n"", __func__);
			goto out;
		}
	}
	
	ret = 0;
	
	out:
		srcu_read_unlock(&kvm->irq_srcu, idx);
		
		return ret;
}",876,-47.16804946859436,-0.05384480532944562
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; if ( guest_irq >= irq_rt -> nr_rt_entries ) { ret = -EINVAL; return ret; } idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",683,-7.264561212562195,-0.010636253605508338
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { 
  struct kvm_kernel_irq_routing_entry * e ; 
  struct kvm_irq_routing_table * irq_rt ; 
  struct kvm_lapic_irq irq ; 
  struct kvm_vcpu * vcpu ; 
  struct vcpu_data vcpu_info ; 
  int idx , ret = - EINVAL ; 
  
  // Validate the input
  if ( ! kvm || ! host_irq || ! guest_irq )
    return ret ;
  
  if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) )
    return 0 ; 
  
  idx = srcu_read_lock ( & kvm -> irq_srcu ) ; 
  irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; 
  BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; 
  hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { 
    if ( e -> type != KVM_IRQ_ROUTING_MSI ) 
      continue ; 
    kvm_set_msi_irq ( kvm , e , & irq ) ; 
    if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { 
      ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; 
      if ( ret < 0 ) { 
        printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; 
        goto out ; 
      } 
      continue ; 
    } 
    vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; 
    vcpu_info . vector = irq . vector ; 
    trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; 
    if ( set ) 
      ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; 
    else { 
      pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; 
      ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; 
      pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; 
    } 
    if ( ret < 0 ) { 
      printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; 
      goto out ; 
    } 
  } 
  ret = 0 ; 
  out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; 
  return ret ; 
}",837,-27.442108226457965,-0.03278627028250653
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
Fixed code:","
static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; 

if ( guest_irq > MAX_GSI ) {
  return -EINVAL;
}

if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed to back to remapped mode, irq: %u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s: failed to update PI IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }",703,-16.172513471892458,-0.023004997826305062
