Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; int seglen_check = 0; int used_check = 0; int used_check_min = 0; 
lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ;
 
//Validate seglen
if(seglen < 0 || seglen > SIZE_MAX) {
        seglen_check = 1;
        err = -EINVAL;
        goto unlock;
}
while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } 

//Validate used
if(used < 0 || used > SIZE_MAX) {
        used_check = 1;
        err = -EINVAL;
        goto unlock;
}

used_check_min = min_t ( unsigned long , used , seglen ) ;

//Validate used_check_min
if(used_check_min < 0 || used_check_min > SIZE_MAX) {
        err = -EINVAL;
        goto unlock;
}

used = used_check_min;

used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",808,-65.90513616981443,-0.081565762586404
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; 

//Validate input parameters 
if (msg == NULL)
    return -EINVAL;

lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",639,-19.414837073704184,-0.030383156609865705
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; //Validate all inputs if ( ! sk || ! msg || ! ctx ) return -EINVAL; //Ensure all fields in msghdr are valid if ( msg -> msg_namelen < 0 || msg -> msg_iovlen < 0 ) return -EINVAL; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",674,-42.09480362210855,-0.06245519825238657
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; //Validate user input. if(iovlen <= 0 || iovlen > __UIO_MAXIOV || iov == NULL) return -EINVAL; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",649,-30.33569015087051,-0.04674220362229662
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; if (used > seglen) { err = -EINVAL; goto unlock; } used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",633,-10.254638609260244,-0.016200060994092012
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; if ( seglen == 0 ) { err = -EINVAL; goto unlock; } while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",633,-8.49719258387567,-0.01342368496662823
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { //Validation to check that seglen is within expected range to avoid buffer overflow if (seglen < bs){ err = -EINVAL; break; } sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",649,-39.06139477969049,-0.06018704896716562
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; // Added input validation check if (msg == NULL || (msg->msg_iovlen == 0 && msg->msg_iov == NULL)) { return -EINVAL; } lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",650,-18.7129362522121,-0.02878913269571092
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; if ( seglen <= 0 || seglen > INT_MAX ) { err = - EINVAL ; goto unlock ; } while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",641,-10.188780193312754,-0.01589513290688417
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen , limit ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; limit = ctx -> used ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { if ( seglen > limit ) seglen = limit ; sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; limit -= used ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",640,-24.061646484242114,-0.03759632263162831
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:"," 

static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; if (iovlen < 0) { return -EINVAL; } lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",630,-17.067329090406037,-0.02709099855620006
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { //Check for valid user input if(from == NULL || seglen < 0) { err = -EINVAL; goto unlock; } sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",643,-17.6776244460414,-0.02749241748995552
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { 
        //added validation to check for seglen > 0
        if(seglen <= 0){
            break;
        }
        sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",646,-31.06372476823354,-0.04808626125113551
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock, struct msghdr *msg, size_t ignored, int flags) {
    struct sock *sk = sock->sk;
    struct alg_sock *ask = alg_sk(sk);
    struct skcipher_ctx *ctx = ask->private;
    unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(&ctx->req));
    struct skcipher_sg_list *sgl;
    struct scatterlist *sg;
    unsigned long iovlen;
    struct iovec *iov;
    int err = -EAGAIN;
    int used;
    long copied = 0;

    lock_sock(sk);
    msg->msg_namelen = 0;

    if (!ctx || ctx->used == 0) {
        err = skcipher_wait_for_data(sk, flags);
        if (err)
            goto unlock;
    }

    for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0; iovlen--, iov++) {
        unsigned long seglen = iov->iov_len;
        char __user *from = iov->iov_base;

        while (seglen) {
            sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list, list);
            sg = sgl->sg;
            while (!sg->length) sg++;
            used = min_t(long, ctx->used, seglen);
            used = used ? af_alg_make_sg(&ctx->rsgl, from, used, 1) : 0;
            err = used;
            if (err < 0)
                goto unlock;

            if (ctx->more || used < ctx->used)
                used -= used % bs;
            err = -EINVAL;
            if (!used)
                goto free;

            ablkcipher_request_set_crypt(&ctx->req, sg, ctx->rsgl.sg, used, ctx->iv);
            err = af_alg_wait_for_completion(
                ctx->enc ? crypto_ablkcipher_encrypt(&ctx->req)
                         : crypto_ablkcipher_decrypt(&ctx->req),
                &ctx->completion);
        free:
            af_alg_free_sg(&ctx->rsgl);
            if (err)
                goto unlock;
            copied += used;
            from += used;
            seglen -= used;
            skcipher_pull_sgl(sk, used);
        }
    }
    err = 0;

unlock:
    skcipher_wmem_wakeup(sk);
    release_sock(sk);
    return copied ? : err;
}
The vulnerability is fixed by adding an input validation check at the beginning of the function to ensure that ctx is not null and ctx->used is not 0 before continuing with the function. This ensures that the function will not continue if there is an invalid value in the ctx variable.",750,-98.27439152955216,-0.13103252203940288
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","

static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock, struct msghdr *msg, size_t ignored, int flags) {
    struct sock *sk = sock->sk;
    struct alg_sock *ask = alg_sk(sk);
    struct skcipher_ctx *ctx = ask->private;
    unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(&ctx->req));
    struct skcipher_sg_list *sgl;
    struct scatterlist *sg;
    unsigned long iovlen;
    struct iovec *iov;
    int err = -EAGAIN;
    int used;
    long copied = 0;
    lock_sock(sk);
    msg->msg_namelen = 0;

    if (msg->msg_iovlen > 0) {
        for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0; iovlen--, iov++) {
            unsigned long seglen = iov->iov_len;
            char __user *from = iov->iov_base;
            while (seglen) {
                sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list, list);
                sg = sgl->sg;
                while (!sg->length)
                    sg++;
                used = ctx->used;
                if (!used) {
                    err = skcipher_wait_for_data(sk, flags);
                    if (err)
                        goto unlock;
                }
                used = min_t(unsigned long, used, seglen);
                //Validate user input
                if (from == NULL || used > seglen || used % bs) {
                    err = -EINVAL;
                    goto unlock;
                }
                used = af_alg_make_sg(&ctx->rsgl, from, used, 1);
                err = used;
                if (err < 0)
                    goto unlock;
                if (ctx->more || used < ctx->used)
                    used -= used % bs;
                if (!used)
                    goto free;
                ablkcipher_request_set_crypt(&ctx->req, sg, ctx->rsgl.sg, used, ctx->iv);
                err = af_alg_wait_for_completion(ctx->enc ? crypto_ablkcipher_encrypt(&ctx->req) : crypto_ablkcipher_decrypt(&ctx->req), &ctx->completion);
            free:
                af_alg_free_sg(&ctx->rsgl);
                if (err)
                    goto unlock;
                copied += used;
                from += used;
                seglen -= used;
                skcipher_pull_sgl(sk, used);
            }
        }
    }
    err = 0;
unlock:
    skcipher_wmem_wakeup(sk);
    release_sock(sk);
    return copied ? : err;
}",733,-34.687179328706534,-0.047322209179681496
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; 

for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; 

//Added input sanitization
if (seglen > INT_MAX) {
  err = -EINVAL;
  goto unlock;
}

while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",655,-29.522296504543508,-0.04507220840388322
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; 

//Check if the length of the msg_iov is valid
if (msg->msg_iovlen > 0) {
  lock_sock ( sk ) ;
  msg -> msg_namelen = 0 ;
  for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) {
    unsigned long seglen = iov -> iov_len ;
    char __user * from = iov -> iov_base ;
    while ( seglen ) {
      sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ;
      sg = sgl -> sg ;
      while ( ! sg -> length ) sg ++ ;
      used = ctx -> used ;
      if ( ! used ) {
        err = skcipher_wait_for_data ( sk , flags ) ;
        if ( err ) goto unlock ;
      }
      used = min_t ( unsigned long , used , seglen ) ;
      used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ;
      err = used ;
      if ( err < 0 ) goto unlock ;
      if ( ctx -> more || used < ctx -> used ) used -= used % bs ;
      err = - EINVAL ;
      if ( ! used ) goto free ;
      ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ;
      err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ;
      free : af_alg_free_sg ( & ctx -> rsgl ) ;
      if ( err ) goto unlock ;
      copied += used ;
      from += used ;
      seglen -= used ;
      skcipher_pull_sgl ( sk , used ) ;
    }
  }
  err = 0 ;
  unlock : skcipher_wmem_wakeup ( sk ) ;
  release_sock ( sk ) ;
  return copied ? : err ; 
}
//If the length of the msg_iov is invalid, return an error
else {
  return -EINVAL;
}
}",744,-38.48510693194418,-0.051727294263365836
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; //Added null check if (! from) {err = -EINVAL; goto unlock;} while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",632,-25.077344285448632,-0.03967934222381113
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; //Check for valid input if (msg == NULL || msg->msg_iov == NULL)  return -EINVAL; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",639,-19.468573153419793,-0.03046725063132988
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { // Validate the input before processing sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; if (sgl == NULL) { err = -EINVAL; goto unlock; } sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; if (sg == NULL) { err = -EINVAL; goto unlock; } used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",657,-20.377160809428112,-0.0310154654633609
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; 

//Add input validation
if (msg == NULL || msg->msg_iov == NULL || msg->msg_iovlen < 0) {
    return -EINVAL;
}

lock_sock ( sk ) ; 

msg -> msg_namelen = 0 ; 
for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { 
    unsigned long seglen = iov -> iov_len ; 
    char __user * from = iov -> iov_base ; 
    while ( seglen ) { 
        sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; 
        sg = sgl -> sg ; 
        while ( ! sg -> length ) sg ++ ; 
        used = ctx -> used ; 
        if ( ! used ) { 
            err = skcipher_wait_for_data ( sk , flags ) ; 
            if ( err ) goto unlock ; 
        } 
        used = min_t ( unsigned long , used , seglen ) ; 
        used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; 
        err = used ; 
        if ( err < 0 ) goto unlock ; 
        if ( ctx -> more || used < ctx -> used ) used -= used % bs ; 
        err = - EINVAL ; 
        if ( ! used ) goto free ; 
        ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; 
        err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; 
        free : af_alg_free_sg ( & ctx -> rsgl ) ; 
        if ( err ) goto unlock ; 
        copied += used ; 
        from += used ; 
        seglen -= used ; 
        skcipher_pull_sgl ( sk , used ) ; 
    } 
} 
err = 0 ; 
unlock : skcipher_wmem_wakeup ( sk ) ; 
release_sock ( sk ) ; 
return copied ? : err ; 
}",756,-25.344025922436497,-0.03352384381274669
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; int valid_length = 0; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { valid_length = min_t(unsigned long, seglen, valid_length); sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , valid_length ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
In the fixed code, a new variable valid_length is added and the value of valid_length is set to the minimum of seglen and valid_length. This ensures that the user's input is validated before it is sent to the abklcipher_request_set_crypt().",700,-66.42727623077018,-0.09489610890110026
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { 
  struct sock * sk = sock -> sk ; 
  struct alg_sock * ask = alg_sk ( sk ) ; 
  struct skcipher_ctx * ctx = ask -> private ; 
  unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; 
  struct skcipher_sg_list * sgl ; 
  struct scatterlist * sg ; 
  unsigned long iovlen ; 
  struct iovec * iov ; 
  int err = - EAGAIN ; 
  int used ; 
  long copied = 0 ; 
 
  //Validate input
  if (!iov || !iovlen || !msg) {
    err = -EINVAL;
    goto unlock;
  }
  
  lock_sock ( sk ) ; 
  msg -> msg_namelen = 0 ; 
  for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { 
    unsigned long seglen = iov -> iov_len ; 
    char __user * from = iov -> iov_base ; 
    while ( seglen ) { 
      sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; 
      sg = sgl -> sg ; 
      while ( ! sg -> length ) sg ++ ; 
      used = ctx -> used ; 
      if ( ! used ) { 
        err = skcipher_wait_for_data ( sk , flags ) ; 
        if ( err ) goto unlock ; 
      } 
      used = min_t ( unsigned long , used , seglen ) ; 
      used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; 
      err = used ; 
      if ( err < 0 ) goto unlock ; 
      if ( ctx -> more || used < ctx -> used ) used -= used % bs ; 
      err = - EINVAL ; 
      if ( ! used ) goto free ; 
      ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; 
      err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; 
      free : af_alg_free_sg ( & ctx -> rsgl ) ; 
      if ( err ) goto unlock ; 
      copied += used ; 
      from += used ; 
      seglen -= used ; 
      skcipher_pull_sgl ( sk , used ) ; 
    } 
  } 
  err = 0 ; 
unlock : skcipher_wmem_wakeup ( sk ) ; 
  release_sock ( sk ) ; 
  return copied ? : err ; 
}",794,-31.05372166736596,-0.03911048068937778
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; if(iovlen > 0 && iov->iov_len > 0 && iov->iov_base != NULL){ //Added constriction to validate input  lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; 
}
else
{
  return -EINVAL;
}
}",664,-47.27726976181096,-0.07120070747260687
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; //Validate input if (!msg || !ctx || !sk) return -EINVAL; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",633,-15.655522965814118,-0.024732263769058637
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; if ( msg -> msg_namelen > 0 ) msg -> msg_namelen = 0 ; //Added input validation check to ensure msg_namelen is not greater than 0 lock_sock ( sk ) ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",642,-29.263490956140117,-0.045581761613925416
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; //Validate input size to prevent buffer overflow if(msg->msg_iovlen > MSG_IOVLEN_MAX) { return -EINVAL; } lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",648,-21.995770015091992,-0.03394408952946295
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; if ( ! msg || ! msg -> msg_iov ) { err = - EINVAL ; goto unlock ; } lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; if ( used > seglen ) { err = - EINVAL ; goto unlock ; } used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",657,-15.418142539015903,-0.02346749244903486
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { 

struct sock * sk = sock -> sk ; 
struct alg_sock * ask = alg_sk ( sk ) ; 
struct skcipher_ctx * ctx = ask -> private ; 
unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; 
struct skcipher_sg_list * sgl ; 
struct scatterlist * sg ; 
unsigned long iovlen ; 
struct iovec * iov ; 
int err = - EAGAIN ; 
int used ; 
long copied = 0 ;

// added input validation
if (msg == NULL) {
  return -EINVAL;
}

lock_sock ( sk ) ; 
msg -> msg_namelen = 0 ; 
for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { 
    unsigned long seglen = iov -> iov_len ; 
    char __user * from = iov -> iov_base ; 
    while ( seglen ) { 
        sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; 
        sg = sgl -> sg ; 
        while ( ! sg -> length ) sg ++ ; 
        used = ctx -> used ; 
        if ( ! used ) { 
            err = skcipher_wait_for_data ( sk , flags ) ; 
            if ( err ) goto unlock ; 
        } 
        used = min_t ( unsigned long , used , seglen ) ; 
        used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; 
        err = used ; 
        if ( err < 0 ) goto unlock ; 
        if ( ctx -> more || used < ctx -> used ) used -= used % bs ; 
        err = - EINVAL ; 
        if ( ! used ) goto free ; 
        ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; 
        err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; 
    free : 
        af_alg_free_sg ( & ctx -> rsgl ) ; 
        if ( err ) goto unlock ; 
        copied += used ; 
        from += used ; 
        seglen -= used ; 
        skcipher_pull_sgl ( sk , used ) ; 
    } 
} 
err = 0 ; 
unlock : 
skcipher_wmem_wakeup ( sk ) ; 
release_sock ( sk ) ; 
return copied ? : err ; 
}",765,-28.191100045003303,-0.03685111116993896
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; if ( seglen > MSG_MAX_SIZE ) seglen = MSG_MAX_SIZE ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",635,-13.095319729295161,-0.020622550754795528
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; 

// Input validation added
if (msg == NULL) {
    return -EINVAL;
}

lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",640,-13.673410643909401,-0.02136470413110844
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; // Add input validation to ensure data integrity if (iov->iov_len < 0 || iov->iov_base == NULL) { err = -EINVAL; goto unlock; } while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",652,-26.382149582682306,-0.04046341960534096
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; if ( used < seglen ) { err = - EINVAL ; goto unlock ; } used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }

The vulnerability in the original code was that it did not check for user input validation when using the “used” variable to determine the length of the segment. In the fixed code, the “used” variable is checked against the “seglen” variable before any cryptographic operations are performed, ensuring that the user input is valid.",707,-62.75796719361263,-0.08876657311684955
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","

static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { 
    struct sock * sk = sock -> sk ; 
    struct alg_sock * ask = alg_sk ( sk ) ; 
    struct skcipher_ctx * ctx = ask -> private ; 
    unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; 
    struct skcipher_sg_list * sgl ; 
    struct scatterlist * sg ; 
    unsigned long iovlen ; 
    struct iovec * iov ; 
    int err = - EAGAIN ; 
    int used ; 
    long copied = 0 ; 
    lock_sock ( sk ) ; 

    // Check for valid message name length
    if (msg->msg_namelen < 0) {
        err = -EINVAL;
        goto unlock;
    }

    msg -> msg_namelen = 0 ; 
    for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { 
        unsigned long seglen = iov -> iov_len ; 
        char __user * from = iov -> iov_base ; 
        while ( seglen ) { 
            sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; 
            sg = sgl -> sg ; 
            while ( ! sg -> length ) sg ++ ; 
            used = ctx -> used ; 
            if ( ! used ) { 
                err = skcipher_wait_for_data ( sk , flags ) ; 
                if ( err ) goto unlock ; 
            } 
            used = min_t ( unsigned long , used , seglen ) ; 
            used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; 
            err = used ; 
            if ( err < 0 ) goto unlock ; 
            if ( ctx -> more || used < ctx -> used ) used -= used % bs ; 
            err = - EINVAL ; 
            if ( ! used ) goto free ; 
            ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; 
            err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; 
            free : af_alg_free_sg ( & ctx -> rsgl ) ; 
            if ( err ) goto unlock ; 
            copied += used ; 
            from += used ; 
            seglen -= used ; 
            skcipher_pull_sgl ( sk , used ) ; 
        } 
    } 
    err = 0 ; 
    unlock : skcipher_wmem_wakeup ( sk ) ; 
    release_sock ( sk ) ; 
    return copied ? : err ; 
}",795,-24.00339718984689,-0.03019295244005898
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; 

//Added input validation to check for valid msg and msg_iovlen
if (msg == NULL || msg->msg_iovlen == 0) {
    return -EINVAL;
}

lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; 

//Added input validation to check for valid used value
if (used == 0) {
    err = -EINVAL;
    goto unlock;
}

if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",698,-27.168967692541706,-0.03892402248215144
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; if ( seglen > 0 ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } else { err = - EINVAL ; goto unlock ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",628,-9.440637518169327,-0.015032862290078546
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; 

//Added input validation 
if (msg == NULL || sock == NULL || sk == NULL || ask == NULL || ctx == NULL) { 
     return -EINVAL; 
} 

lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",661,-20.762280236102203,-0.03141040882920152
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; 
if (msg->msg_iovlen >= 0 && msg->msg_iovlen <= UIO_MAXIOV) {
    for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; 
} 
else { 
    err = -EINVAL; 
} 
return copied ? : err ; 
}",673,-28.83350007936833,-0.042843239345272406
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { 
// Check that seglen is within the valid range
if (seglen > bs) {
    sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } else {
    err = -EINVAL;
    goto unlock;
  }
 } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",660,-33.874998803487976,-0.05132575576286057
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; int valid_input = 0; 

lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; if (seglen > 0 && from != NULL) { valid_input = 1; } }

if (valid_input) {
 while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } else { err = -EINVAL; }

err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",666,-27.84747886158349,-0.041813031323698936
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; //Check for valid input if(used > 0 && from) { used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } else { err = -EINVAL; goto unlock; } } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",641,-23.845670545878793,-0.037200734080934154
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) {
  struct sock * sk = sock -> sk ;
  struct alg_sock * ask = alg_sk ( sk ) ;
  struct skcipher_ctx * ctx = ask -> private ;
  unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ;
  struct skcipher_sg_list * sgl ;
  struct scatterlist * sg ;
  unsigned long iovlen ;
  struct iovec * iov ;
  int err = - EAGAIN ;
  int used ;
  long copied = 0 ;
  lock_sock ( sk ) ;
  msg -> msg_namelen = 0 ;
  for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) {
    unsigned long seglen = iov -> iov_len ;
    char __user * from = iov -> iov_base ;
    if ( seglen > SSIZE_MAX ) {
      err = - EINVAL;
      goto unlock;
    }
    while ( seglen ) {
      sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ;
      sg = sgl -> sg ;
      while ( ! sg -> length ) sg ++ ;
      used = ctx -> used ;
      if ( ! used ) {
        err = skcipher_wait_for_data ( sk , flags ) ;
        if ( err ) goto unlock ;
      }
      used = min_t ( unsigned long , used , seglen ) ;
      used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ;
      err = used ;
      if ( err < 0 ) goto unlock ;
      if ( ctx -> more || used < ctx -> used ) used -= used % bs ;
      err = - EINVAL ;
      if ( ! used ) goto free ;
      ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ;
      err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ;
      free : af_alg_free_sg ( & ctx -> rsgl ) ;
      if ( err ) goto unlock ;
      copied += used ;
      from += used ;
      seglen -= used ;
      skcipher_pull_sgl ( sk , used ) ;
    }
  }
  err = 0 ; 
  unlock : skcipher_wmem_wakeup ( sk ) ; 
  release_sock ( sk ) ; 
  return copied ? : err ; 
}",741,-26.377620379690498,-0.035597328447625504
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; if (msg->msg_iovlen < 0 || msg->msg_iovlen > UIO_MAXIOV) { return -EINVAL; } 

lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",649,-12.872687373983613,-0.019834649266538693
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; int max_recv_size = 1024; // add max_recv_size variable 

lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; // add input validation if ( used > max_recv_size ) { err = -EINVAL; goto unlock; } used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",662,-37.853409752877766,-0.0571803772702081
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","

static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; // Check for input validation if(from == NULL) { err = -EINVAL; goto unlock; } while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",637,-19.23763205287063,-0.030200364290220768
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; if ( ! validate_msg_parameters ( msg , & iovlen , & iov ) ) { return - EINVAL ; } lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }

// Added function to validate parameters
bool validate_msg_parameters(struct msghdr *msg, unsigned long *iovlen, struct iovec **iov) {
    if (msg == nullptr || iovlen == nullptr || iov == nullptr) {
        return false;
    }
    else {
        *iovlen = msg->msg_iovlen;
        *iov = msg->msg_iov;
        return true;
    }
}",750,-41.73125436612538,-0.05564167248816717
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; //Check if the input data is valid if( !msg || !msg->msg_iov || !msg->msg_iovlen ) { return -EINVAL; } lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",649,-23.5321274567755,-0.0362590561737681
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; 

if(msg->msg_iovlen > 0){
	lock_sock ( sk ) ;
	msg -> msg_namelen = 0 ; 
	for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { 
		unsigned long seglen = iov -> iov_len ; 
		char __user * from = iov -> iov_base ; 
		while ( seglen ) { 
			sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; 
			sg = sgl -> sg ; 
			while ( ! sg -> length ) sg ++ ; 
			used = ctx -> used ; 
			if ( ! used ) { 
				err = skcipher_wait_for_data ( sk , flags ) ; 
				if ( err ) goto unlock ; 
			} 
			used = min_t ( unsigned long , used , seglen ) ; 
			used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; 
			err = used ; 
			if ( err < 0 ) goto unlock ; 
			if ( ctx -> more || used < ctx -> used ) used -= used % bs ; 
			if ( used > 0 ) { 
				err = - EINVAL ; 
				ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; 
				err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; 
			}
			free : af_alg_free_sg ( & ctx -> rsgl ) ; 
			if ( err ) goto unlock ; 
			copied += used ; 
			from += used ; 
			seglen -= used ; 
			skcipher_pull_sgl ( sk , used ) ; 
		} 
	} 
	err = 0 ; 
	unlock : skcipher_wmem_wakeup ( sk ) ; 
	release_sock ( sk ) ; 
	return copied ? : err ; 
}
else {
	return -EINVAL;
}
}",807,-28.372214124653624,-0.035157638320512545
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","

static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; 

// Add input validation check
if ( msg == NULL || msg->msg_iov == NULL ) {
 return -EINVAL;
}

lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",649,-22.30197780778695,-0.03436360216916325
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
Fixed code:","
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; lock_sock ( sk ) ; if ( msg -> msg_namelen < 0 ) { err = - EINVAL; goto unlock; } msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",637,-10.967541414243861,-0.017217490446222703
