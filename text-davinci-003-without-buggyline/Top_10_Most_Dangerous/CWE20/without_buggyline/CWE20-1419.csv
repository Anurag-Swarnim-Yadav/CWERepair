Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) {
    struct snd_timer * timer = NULL ;
    struct snd_timer_instance * slave , * tmp ;
    
    if ( timeri == NULL || timeri->flags == NULL ) {
        return -ENXIO;
    }

    snd_timer_stop ( timeri ) ;

    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) {
        spin_lock_irq ( & slave_active_lock ) ;
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
            spin_unlock_irq ( & slave_active_lock ) ;
            udelay ( 10 ) ;
            spin_lock_irq ( & slave_active_lock ) ;
        }
        spin_unlock_irq ( & slave_active_lock ) ;

        mutex_lock ( & register_mutex ) ;
        list_del ( & timeri -> open_list ) ;
        mutex_unlock ( & register_mutex ) ;
    } else {
        timer = timeri -> timer ;

        if ( timer == NULL ) {
            goto out ;
        }

        spin_lock_irq ( & timer -> lock ) ;
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
            spin_unlock_irq ( & timer -> lock ) ;
            udelay ( 10 ) ;
            spin_lock_irq ( & timer -> lock ) ;
        }
        spin_unlock_irq ( & timer -> lock ) ;

        mutex_lock ( & register_mutex ) ;
        list_del ( & timeri -> open_list ) ;
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) {
            timer -> hw . close ( timer ) ;
        }
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {
            spin_lock_irq ( & slave_active_lock ) ;
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ;
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ;
            slave -> master = NULL ;
            slave -> timer = NULL ;
            spin_unlock_irq ( & slave_active_lock ) ;
        }
        mutex_unlock ( & register_mutex ) ;
    }

out:
    if ( timeri -> private_free ) {
        timeri -> private_free ( timeri ) ;
    }
    kfree ( timeri -> owner ) ;
    kfree ( timeri ) ;
    if ( timer ) {
        module_put ( timer -> module ) ;
    }
    return 0 ;
}",709,-28.086275297729326,-0.03961392848762951
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",599,-5.109355665205125,-0.008529809123881677
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
    struct snd_timer * timer = NULL ; 
    struct snd_timer_instance * slave , * tmp ; 
    //Checking for NULL pointer
    if ( ! timeri || snd_BUG_ON ( ! timeri ) ) 
        return - ENXIO ; 
    snd_timer_stop ( timeri ) ; 
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & slave_active_lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & slave_active_lock ) ; 
        } 
        spin_unlock_irq ( & slave_active_lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        mutex_unlock ( & register_mutex ) ; 
    } else { 
        timer = timeri -> timer ; 
        if ( ! timer || snd_BUG_ON ( ! timer ) ) 
            goto out ; 
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & timer -> lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
            timer -> hw . close ( timer ) ; 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
            spin_lock_irq ( & slave_active_lock ) ; 
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
            slave -> master = NULL ; 
            slave -> timer = NULL ; 
            spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
    } 
out : 
    if ( timeri -> private_free ) 
        timeri -> private_free ( timeri ) ; 
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) 
        module_put ( timer -> module ) ; 
    return 0 ; 
}",758,-21.223238680117237,-0.027998995620207436
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if  ( !timeri ) return - ENXIO ; 

if (timeri -> flags & SNDRV_TIMER_IFLG_SLAVE) {
    
    spin_lock_irq(&slave_active_lock);
    bool valid = false;
    
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
        if (timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK) {
            valid = true;
        }
        spin_unlock_irq(&slave_active_lock);
        udelay(10);
        spin_lock_irq(&slave_active_lock);
    }
    spin_unlock_irq(&slave_active_lock);
    if (!valid) {
        return -ENXIO;
    }
    mutex_lock(&register_mutex);
    list_del(&timeri -> open_list);
    mutex_unlock(&register_mutex);
    
} else {
    timer = timeri -> timer;
    if ( snd_BUG_ON ( ! timer ) ) goto out ; 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
        bool valid = false;
        if (timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK) {
            valid = true;
        }
        spin_unlock_irq ( & timer -> lock ) ;
        udelay ( 10 ) ; 
        spin_lock_irq ( & timer -> lock ) ; 
    }
    spin_unlock_irq ( & timer -> lock ) ; 
    if (!valid) {
        return -ENXIO;
    }
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
        list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
        slave -> master = NULL ; 
        slave -> timer = NULL ; 
        spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
} 
out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) module_put ( timer -> module ) ; 
return 0 ; 
}",784,-83.2182848467769,-0.10614577148823584
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( timeri == NULL ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( timer == NULL ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",581,-4.808211981663597,-0.00827575211990292
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
    struct snd_timer * timer = NULL ; 
    struct snd_timer_instance * slave , * tmp ; 
    if (timeri == NULL) return -ENXIO;
    if(!snd_timer_stop(timeri)) return -ENXIO;
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & slave_active_lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & slave_active_lock ) ; 
        } 
        spin_unlock_irq ( & slave_active_lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        mutex_unlock ( & register_mutex ) ; 
    } else { 
        timer = timeri -> timer ; 
        if ( timer == NULL ) goto out ; 
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & timer -> lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
            spin_lock_irq ( & slave_active_lock ) ; 
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
            slave -> master = NULL ; 
            slave -> timer = NULL ; 
            spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
    } 
out : 
    if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) module_put ( timer -> module ) ; 
    return 0 ; 
}",720,-24.352723426456198,-0.03382322698118916
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) {
    struct snd_timer * timer = NULL ;
    struct snd_timer_instance * slave , * tmp ;
    
    // Check for invalid input
    if ( timeri == NULL || snd_BUG_ON ( ! timeri ) ) 
        return - ENXIO ;
    
    snd_timer_stop ( timeri ) ; 
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & slave_active_lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & slave_active_lock ) ; 
        } 
        spin_unlock_irq ( & slave_active_lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        mutex_unlock ( & register_mutex ) ; 
    } else { 
        timer = timeri -> timer ;
        if ( snd_BUG_ON ( ! timer ) ) 
            goto out ; 
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & timer -> lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
            timer -> hw . close ( timer ) ; 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
            spin_lock_irq ( & slave_active_lock ) ; 
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
            slave -> master = NULL ; 
            slave -> timer = NULL ; 
            spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
    } 
    
out:
    if ( timeri -> private_free ) 
        timeri -> private_free ( timeri ) ; 
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) 
        module_put ( timer -> module ) ; 
    return 0 ; 
}",755,-30.703263763048923,-0.0406665745205946
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
if ( timeri == NULL ) 
    return -ENXIO; 
if ( !strcmp(timeri,""SNDRV_TIMER_IFLG_SLAVE"") ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & slave_active_lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
} else { 
    timer = timeri -> timer ; 
    if (timer == NULL) 
        goto out ; 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & timer -> lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
        timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
        list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
        slave -> master = NULL ; 
        slave -> timer = NULL ; 
        spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
} 
out : if ( timeri -> private_free ) 
    timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) 
    module_put ( timer -> module ) ; 
return 0 ; 
}",701,-37.928010334576214,-0.05410557822336122
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
struct snd_timer * timer = NULL ; 
struct snd_timer_instance * slave , * tmp ; 

// Validate that the input is not NULL
if ( timeri == NULL ) return - ENXIO ;

snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
spin_lock_irq ( & slave_active_lock ) ; 
while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
spin_unlock_irq ( & slave_active_lock ) ; 
udelay ( 10 ) ; 
spin_lock_irq ( & slave_active_lock ) ; 
} 
spin_unlock_irq ( & slave_active_lock ) ; 
mutex_lock ( & register_mutex ) ; 
list_del ( & timeri -> open_list ) ; 
mutex_unlock ( & register_mutex ) ; 
} else { 
timer = timeri -> timer ; 
// Validate that the timer is not NULL
if ( timer == NULL ) goto out ; 
spin_lock_irq ( & timer -> lock ) ; 
while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
spin_unlock_irq ( & timer -> lock ) ; 
udelay ( 10 ) ; 
spin_lock_irq ( & timer -> lock ) ; 
} 
spin_unlock_irq ( & timer -> lock ) ; 
mutex_lock ( & register_mutex ) ; 
list_del ( & timeri -> open_list ) ; 
if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
spin_lock_irq ( & slave_active_lock ) ; 
_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
slave -> master = NULL ; 
slave -> timer = NULL ; 
spin_unlock_irq ( & slave_active_lock ) ; 
} 
mutex_unlock ( & register_mutex ) ; 
} 
out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) module_put ( timer -> module ) ; 
return 0 ; 
}",692,-25.408719862436296,-0.036717803269416614
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
    struct snd_timer * timer = NULL ; 
    struct snd_timer_instance * slave , * tmp ; 
    
    if ( timeri == NULL ) return - ENXIO ; 
    snd_timer_stop ( timeri ) ; 
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & slave_active_lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & slave_active_lock ) ; 
        } 
        spin_unlock_irq ( & slave_active_lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        mutex_unlock ( & register_mutex ) ; 
    } else { 
        timer = timeri -> timer ; 
        if ( timer == NULL ) goto out ; 
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & timer -> lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
            spin_lock_irq ( & slave_active_lock ) ; 
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
            slave -> master = NULL ; 
            slave -> timer = NULL ; 
            spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
    } 
out : 
    if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) module_put ( timer -> module ) ; 
    return 0 ; 
}",716,-12.764331291079008,-0.017827278339495822
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) { /* Added input validation */ if (timer->module) { module_put ( timer -> module ) } } return 0 ; }",613,-20.752313509548127,-0.03385369251149776
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
//Validate input
if ( timeri == NULL || snd_BUG_ON(timeri) != 0 ) {
    return - ENXIO ; 
}

snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & slave_active_lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
} 
else { 
    timer = timeri -> timer ; 
    //Validate the timer
    if ( snd_BUG_ON ( ! timer ) != 0 ) { 
        goto out ; 
    } 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & timer -> lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
        list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
        slave -> master = NULL ; 
        slave -> timer = NULL ; 
        spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
} 
out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) module_put ( timer -> module ) ; 
return 0 ; 
}",746,-39.09482339389198,-0.05240592948242893
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; 
mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ;
mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 

kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",607,-24.01181467375242,-0.0395581790341885
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; if (!timeri->timer) { return -ENXIO; } mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",610,-14.56797666346343,-0.023881928956497427
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
//Validate input
if ( !timeri || snd_BUG_ON ( !timeri ) ) {
	return -ENXIO;
}

snd_timer_stop ( timeri ) ; 

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
	spin_lock_irq ( & slave_active_lock ) ; 
	while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
		spin_unlock_irq ( & slave_active_lock ) ; 
		udelay ( 10 ) ; 
		spin_lock_irq ( & slave_active_lock ) ; 
	} 
	spin_unlock_irq ( & slave_active_lock ) ; 
	mutex_lock ( & register_mutex ) ; 
	list_del ( & timeri -> open_list ) ; 
	mutex_unlock ( & register_mutex ) ; 
} else { 
	timer = timeri -> timer ; 
	if ( snd_BUG_ON ( ! timer ) ) goto out ; 
	spin_lock_irq ( & timer -> lock ) ; 
	while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
		spin_unlock_irq ( & timer -> lock ) ; 
		udelay ( 10 ) ; 
		spin_lock_irq ( & timer -> lock ) ; 
	} 
	spin_unlock_irq ( & timer -> lock ) ; 
	mutex_lock ( & register_mutex ) ; 
	list_del ( & timeri -> open_list ) ; 
	if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
	list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
		spin_lock_irq ( & slave_active_lock ) ; 
		_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
		list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
		slave -> master = NULL ; 
		slave -> timer = NULL ; 
		spin_unlock_irq ( & slave_active_lock ) ; 
	} 
	mutex_unlock ( & register_mutex ) ; 
} 
out : 
if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) module_put ( timer -> module ) ; 
return 0 ; 
}",741,-30.262070202871953,-0.040839500948545146
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( timeri == NULL ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( timer == NULL ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",581,-4.8490697630214425,-0.00834607532361694
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
if ( timeri == NULL ) 
return - ENXIO ;

if ( ! ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) ) {
	if ( ! timeri -> timer ) {
		goto out ;
	} else {
		timer = timeri -> timer ;
	}
}

snd_timer_stop ( timeri ) ; 

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) {
	spin_lock_irq ( & slave_active_lock ) ; 
	while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
		spin_unlock_irq ( & slave_active_lock ) ; 
		udelay ( 10 ) ; 
		spin_lock_irq ( & slave_active_lock ) ; 
	} 
	spin_unlock_irq ( & slave_active_lock ) ; 
	mutex_lock ( & register_mutex ) ; 
	list_del ( & timeri -> open_list ) ; 
	mutex_unlock ( & register_mutex ) ; 
} else {
	spin_lock_irq ( & timer -> lock ) ; 
	while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
		spin_unlock_irq ( & timer -> lock ) ; 
		udelay ( 10 ) ; 
		spin_lock_irq ( & timer -> lock ) ; 
	} 
	spin_unlock_irq ( & timer -> lock ) ; 
	mutex_lock ( & register_mutex ) ; 
	list_del ( & timeri -> open_list ) ; 
	if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
		timer -> hw . close ( timer ) ; 
	list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
		spin_lock_irq ( & slave_active_lock ) ; 
		_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
		list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
		slave -> master = NULL ; 
		slave -> timer = NULL ; 
		spin_unlock_irq ( & slave_active_lock ) ; 
	} 
	mutex_unlock ( & register_mutex ) ; 
} 
out : 
if ( timeri -> private_free ) 
	timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) 
	module_put ( timer -> module ) ; 
return 0 ; 
}",768,-41.48045771528478,-0.054011012650110386
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 

if (!timeri || snd_BUG_ON(timeri->flags & SNDRV_TIMER_IFLG_SLAVE)) {
 return -ENXIO; 
}

snd_timer_stop ( timeri ) ; 

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
 spin_lock_irq ( & slave_active_lock ) ; 
 while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
  spin_unlock_irq ( & slave_active_lock ) ; 
  udelay ( 10 ) ; 
  spin_lock_irq ( & slave_active_lock ) ; 
 } 
 spin_unlock_irq ( & slave_active_lock ) ; 
 mutex_lock ( & register_mutex ) ; 
 list_del ( & timeri -> open_list ) ; 
 mutex_unlock ( & register_mutex ) ; 
} 
else { 
 timer = timeri -> timer ; 
 if ( snd_BUG_ON ( ! timer ) ) goto out ; 
 spin_lock_irq ( & timer -> lock ) ; 
 while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
  spin_unlock_irq ( & timer -> lock ) ; 
  udelay ( 10 ) ; 
  spin_lock_irq ( & timer -> lock ) ; 
 } 
 spin_unlock_irq ( & timer -> lock ) ; 
 mutex_lock ( & register_mutex ) ; 
 list_del ( & timeri -> open_list ) ; 
 if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
 list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
  spin_lock_irq ( & slave_active_lock ) ; 
  _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
  list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
  slave -> master = NULL ; 
  slave -> timer = NULL ; 
  spin_unlock_irq ( & slave_active_lock ) ; 
 } 
 mutex_unlock ( & register_mutex ) ; 
} 
out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
 kfree ( timeri -> owner ) ; 
 kfree ( timeri ) ; 
 if ( timer ) module_put ( timer -> module ) ; 
 return 0 ; 
}",719,-26.11472544619338,-0.03632089769985171
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
    struct snd_timer * timer = NULL ; 
    struct snd_timer_instance * slave , * tmp ; 
    //check if timeri is not NULL
    if ( timeri == NULL ) return - ENXIO ;
    //check if timeri is not NULL
    if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; 
    snd_timer_stop ( timeri ) ; 
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & slave_active_lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & slave_active_lock ) ; 
        } 
        spin_unlock_irq ( & slave_active_lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        mutex_unlock ( & register_mutex ) ; 
    } else { 
        timer = timeri -> timer ; 
        //check if timer is not NULL
        if ( timer == NULL ) goto out ; 
        if ( snd_BUG_ON ( ! timer ) ) goto out ; 
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
            spin_unlock_irq ( & timer -> lock ) ; 
            udelay ( 10 ) ; 
            spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
            spin_lock_irq ( & slave_active_lock ) ; 
            _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
            list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
            slave -> master = NULL ; 
            slave -> timer = NULL ; 
            spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
    } 
    out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) 
        module_put ( timer -> module ) ; 
    return 0 ; 
}",785,-36.926904480876104,-0.04704064265079758
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
struct snd_timer * timer = NULL ; 
struct snd_timer_instance * slave , * tmp ; 
int retval = 0;

if ( timeri == NULL ) 
	return -ENXIO ; 

if( snd_BUG_ON(! timeri) ) 
	retval = -ENXIO;

snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
	spin_lock_irq ( & slave_active_lock ) ; 
	while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
		spin_unlock_irq ( & slave_active_lock ) ; 
		udelay ( 10 ) ; 
		spin_lock_irq ( & slave_active_lock ) ; 
	} 
	spin_unlock_irq ( & slave_active_lock ) ; 
	mutex_lock ( & register_mutex ) ; 
	list_del ( & timeri -> open_list ) ; 
	mutex_unlock ( & register_mutex ) ; 
} 
else { 
	timer = timeri -> timer ; 
	if ( snd_BUG_ON ( ! timer ) ) 
		retval = -ENXIO;
	
	spin_lock_irq ( & timer -> lock ) ; 
	while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
		spin_unlock_irq ( & timer -> lock ) ; 
		udelay ( 10 ) ; 
		spin_lock_irq ( & timer -> lock ) ; 
	} 
	spin_unlock_irq ( & timer -> lock ) ; 
	mutex_lock ( & register_mutex ) ; 
	list_del ( & timeri -> open_list ) ; 
	if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
		timer -> hw . close ( timer ) ; 
	list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
		spin_lock_irq ( & slave_active_lock ) ; 
		_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
		list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
		slave -> master = NULL ; 
		slave -> timer = NULL ; 
		spin_unlock_irq ( & slave_active_lock ) ; 
	} 
	mutex_unlock ( & register_mutex ) ; 
} 

if ( timeri -> private_free ) 
	timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) 
	module_put ( timer -> module ) ; 

return retval;
}",782,-45.50813241686675,-0.058194542732566176
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri || !timeri->timer ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }

The vulnerability was fixed by adding an additional check to the beginning of the function to verify that the timeri argument is not NULL and that the timeri->timer pointer is not NULL before attempting to use it. This ensures that any malicious user input will be properly validated and that the function will not proceed with invalid data.",651,-62.27046178263287,-0.09565355112539611
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","

int snd_timer_close(struct snd_timer_instance *timeri) {
  struct snd_timer *timer = NULL;
  struct snd_timer_instance *slave, *tmp;

  if (timeri == NULL) {
    return -ENXIO;
  }

  snd_timer_stop(timeri);

  if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
    spin_lock_irq(&slave_active_lock);
    while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
      spin_unlock_irq(&slave_active_lock);
      udelay(10);
      spin_lock_irq(&slave_active_lock);
    }
    spin_unlock_irq(&slave_active_lock);
    mutex_lock(&register_mutex);
    list_del(&timeri->open_list);
    mutex_unlock(&register_mutex);
  } else {
    timer = timeri->timer;
    if (timer == NULL) {
      goto out;
    }
    spin_lock_irq(&timer->lock);
    while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
      spin_unlock_irq(&timer->lock);
      udelay(10);
      spin_lock_irq(&timer->lock);
    }
    spin_unlock_irq(&timer->lock);
    mutex_lock(&register_mutex);
    list_del(&timeri->open_list);
    if (timer && list_empty(&timer->open_list_head) && timer->hw.close) {
      timer->hw.close(timer);
    }
    list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head, open_list) {
      spin_lock_irq(&slave_active_lock);
      _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
      list_move_tail(&slave->open_list, &snd_timer_slave_list);
      slave->master = NULL;
      slave->timer = NULL;
      spin_unlock_irq(&slave_active_lock);
    }
    mutex_unlock(&register_mutex);
  }

out:
  if (timeri->private_free) {
    timeri->private_free(timeri);
  }
  kfree(timeri->owner);
  kfree(timeri);
  if (timer) {
    module_put(timer->module);
  }
  return 0;
}",655,-16.179657143103434,-0.024701766630692266
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 

// Validate the input
if ( snd_BUG_ON ( ! timeri ) || !timeri->timer || !timeri->private_free ) return - ENXIO ;

snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } 

// Call the private_free function only if it is valid
if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 

kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",621,-29.16486153026775,-0.046964350290286234
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 

if (timeri == NULL || snd_BUG_ON ( ! timeri )) {
	return -ENXIO;
}

snd_timer_stop ( timeri ) ; 

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
	spin_lock_irq ( & slave_active_lock ) ; 
	
	while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
		spin_unlock_irq ( & slave_active_lock ) ; 
		udelay ( 10 ) ; 
		spin_lock_irq ( & slave_active_lock ) ; 
	} 
	
	spin_unlock_irq ( & slave_active_lock ) ; 
	mutex_lock ( & register_mutex ) ; 
	list_del ( & timeri -> open_list ) ; 
	mutex_unlock ( & register_mutex ) ; 
} 

else { 
	timer = timeri -> timer ; 
	
	if ( snd_BUG_ON ( ! timer ) ) {
		goto out;	
	}
	
	spin_lock_irq ( & timer -> lock ) ; 
	
	while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
		spin_unlock_irq ( & timer -> lock ) ; 
		udelay ( 10 ) ; 
		spin_lock_irq ( & timer -> lock ) ; 
	} 
	
	spin_unlock_irq ( & timer -> lock ) ; 
	mutex_lock ( & register_mutex ) ; 
	list_del ( & timeri -> open_list ) ; 
	
	if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) {
		timer -> hw . close ( timer ) ; 
	}
	
	list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
		spin_lock_irq ( & slave_active_lock ) ; 
		_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
		list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
		slave -> master = NULL ; 
		slave -> timer = NULL ; 
		spin_unlock_irq ( & slave_active_lock ) ; 
	} 
	
	mutex_unlock ( & register_mutex ) ; 
} 

out : 
if ( timeri -> private_free ) {
	timeri -> private_free ( timeri ) ; 
}

kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 

if ( timer ) {
	module_put ( timer -> module ) ;
}

return 0 ; 
}",786,-31.099502499077985,-0.0395667970726183
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) {
    struct snd_timer * timer = NULL ;
    struct snd_timer_instance * slave , * tmp ;
    if ( ! timeri || timeri -> flags & SNDRV_TIMER_IFLG_SLAVE )
        return - ENXIO ;
    snd_timer_stop ( timeri ) ;
    timer = timeri -> timer ;
    if ( ! timer )
        goto out ;
    spin_lock_irq ( & timer -> lock ) ;
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
        spin_unlock_irq ( & timer -> lock ) ;
        udelay ( 10 ) ;
        spin_lock_irq ( & timer -> lock ) ;
    }
    spin_unlock_irq ( & timer -> lock ) ;
    mutex_lock ( & register_mutex ) ;
    list_del ( & timeri -> open_list ) ;
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) {
        // Perform input validation
        if(validate_input(timer)) {
            timer -> hw . close ( timer ) ;
        }
    }
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {
        spin_lock_irq ( & slave_active_lock ) ;
        _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ;
        list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ;
        slave -> master = NULL ;
        slave -> timer = NULL ;
        spin_unlock_irq ( & slave_active_lock ) ;
    }
    mutex_unlock ( & register_mutex ) ;
    out : if ( timeri -> private_free )
        timeri -> private_free ( timeri ) ;
    kfree ( timeri -> owner ) ;
    kfree ( timeri ) ;
    if ( timer )
        module_put ( timer -> module ) ;
    return 0 ;
}",537,-34.53923979895075,-0.06431888230717087
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri ) return - ENXIO ; 

if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) { spin_lock_irq( &slave_active_lock);

while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) { spin_unlock_irq(&slave_active_lock); udelay(10); spin_lock_irq(&slave_active_lock); } spin_unlock_irq(&slave_active_lock);

mutex_lock(&register_mutex); list_del(&timeri->open_list);

//Validate input here
if(timeri->open_list != NULL && timeri->timer != NULL) {
    timer = timeri->timer;
    spin_lock_irq(&timer->lock);
    while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) { spin_unlock_irq(&timer->lock); udelay(10); spin_lock_irq(&timer->lock); } spin_unlock_irq(&timer->lock);
    mutex_lock(&register_mutex); list_del(&timeri->open_list);
    if (timer && list_empty(&timer->open_list_head) && timer->hw.close) timer->hw.close(timer);
    list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head, open_list) { spin_lock_irq(&slave_active_lock); _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION); list_move_tail(&slave->open_list, &snd_timer_slave_list); slave->master = NULL; slave->timer = NULL; spin_unlock_irq(&slave_active_lock); }
    mutex_unlock(&register_mutex);
}

if (timeri->private_free) timeri->private_free(timeri); kfree(timeri->owner); kfree(timeri); if (timer) module_put(timer->module); return 0; }",551,-59.0873094449922,-0.10723649627040327
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
struct snd_timer * timer = NULL ; 
struct snd_timer_instance * slave , * tmp ; 
if ( ! timeri ) return -ENXIO ;

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
	spin_lock_irq ( & slave_active_lock ) ; 
	while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
		spin_unlock_irq ( & slave_active_lock ) ; 
		udelay ( 10 ) ; 
		spin_lock_irq ( & slave_active_lock ) ; 
	} 
	spin_unlock_irq ( & slave_active_lock ) ; 
	mutex_lock ( & register_mutex ) ; 
	list_del ( & timeri -> open_list ) ; 
	mutex_unlock ( & register_mutex ) ; 
} else { 
	timer = timeri -> timer ; 
	if ( ! timer ) goto out ; 
	spin_lock_irq ( & timer -> lock ) ; 
	while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
		spin_unlock_irq ( & timer -> lock ) ; 
		udelay ( 10 ) ; 
		spin_lock_irq ( & timer -> lock ) ; 
	} 
	spin_unlock_irq ( & timer -> lock ) ; 
	mutex_lock ( & register_mutex ) ; 
	list_del ( & timeri -> open_list ) ; 
	if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
	list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
		spin_lock_irq ( & slave_active_lock ) ; 
		_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
		list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
		slave -> master = NULL ; 
		slave -> timer = NULL ; 
		spin_unlock_irq ( & slave_active_lock ) ; 
	} 
	mutex_unlock ( & register_mutex ) ; 
} 
out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
	kfree ( timeri -> owner ) ; 
	kfree ( timeri ) ; 
	if ( timer ) module_put ( timer -> module ) ; 
	return 0 ; 
}",703,-24.71185124578283,-0.035151993237244425
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
//Validate user input
if (! timeri || ( snd_BUG_ON(! timeri) != 0 )) 
    return - ENXIO ; 

snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; 
//Validate user input
if (!timer || ( snd_BUG_ON(! timer) != 0 )) 
    goto out ; 

spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } 
out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; 
}",640,-47.185052058254634,-0.07372664384102287
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",599,-4.8757777798459765,-0.00813986273763936
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
//Add this code for validation
if ( ! timeri || timeri -> flags & SNDRV_TIMER_IFLG_SLAVE || ! timeri -> timer || ! snd_BUG_ON ( ! timeri ) ) return - ENXIO ; 
snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",624,-37.829744719135974,-0.06062459089605124
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
  struct snd_timer * timer = NULL ; 
  struct snd_timer_instance * slave , * tmp ; 
  //Check for valid input
  if (! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; 
  snd_timer_stop ( timeri ) ; 
  if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & slave_active_lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
  } else { 
    timer = timeri -> timer ; 
    if ( snd_BUG_ON ( ! timer ) ) goto out ; 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
      spin_unlock_irq ( & timer -> lock ) ; 
      udelay ( 10 ) ; 
      spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
      spin_lock_irq ( & slave_active_lock ) ; 
      _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
      list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
      slave -> master = NULL ; 
      slave -> timer = NULL ; 
      spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
  } 
out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
  kfree ( timeri -> owner ) ; 
  kfree ( timeri ) ; 
  if ( timer ) module_put ( timer -> module ) ; 
  return 0 ; 
}",735,-21.28698664367055,-0.028961886590027956
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
//Validate the input before proceeding
if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",611,-18.45651978336463,-0.03020707002187337
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
if ( timeri == NULL ) return - ENXIO ; 
snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & slave_active_lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & slave_active_lock ) ; 
    } 
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
} else { 
    timer = timeri -> timer ; 
    if ( timer == NULL ) goto out ; 
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & timer -> lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; 
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
        list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
        slave -> master = NULL ; 
        slave -> timer = NULL ; 
        spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
} 
out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) module_put ( timer -> module ) ; 
return 0 ; 
}",696,-12.426466498982135,-0.01785411853302031
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
  struct snd_timer * timer = NULL ; 
  struct snd_timer_instance * slave , * tmp ; 
  
  //Verify that the input is not NULL
  if ( timeri && !snd_BUG_ON ( ! timeri ) )
  {
    snd_timer_stop ( timeri ) ; 
    if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
      spin_lock_irq ( & slave_active_lock ) ; 
      while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & slave_active_lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & slave_active_lock ) ; 
      } 
      spin_unlock_irq ( & slave_active_lock ) ; 
      mutex_lock ( & register_mutex ) ; 
      list_del ( & timeri -> open_list ) ; 
      mutex_unlock ( & register_mutex ) ; 
    } else { 
      timer = timeri -> timer ; 
      if ( ! snd_BUG_ON ( ! timer ) )
      {
        spin_lock_irq ( & timer -> lock ) ; 
        while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
          spin_unlock_irq ( & timer -> lock ) ; 
          udelay ( 10 ) ; 
          spin_lock_irq ( & timer -> lock ) ; 
        } 
        spin_unlock_irq ( & timer -> lock ) ; 
        mutex_lock ( & register_mutex ) ; 
        list_del ( & timeri -> open_list ) ; 
        if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
          timer -> hw . close ( timer ) ; 
        list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
          spin_lock_irq ( & slave_active_lock ) ; 
          _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
          list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
          slave -> master = NULL ; 
          slave -> timer = NULL ; 
          spin_unlock_irq ( & slave_active_lock ) ; 
        } 
        mutex_unlock ( & register_mutex ) ; 
      }
    } 
    if ( timeri -> private_free ) 
      timeri -> private_free ( timeri ) ; 
    kfree ( timeri -> owner ) ; 
    kfree ( timeri ) ; 
    if ( timer ) 
      module_put ( timer -> module ) ; 
    return 0 ; 
  }
  return - ENXIO ;
}",760,-41.84790418324835,-0.05506303182006362
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; 

//Added input validation
if(timeri->flags != SNDRV_TIMER_IFLG_SLAVE && timeri->flags != SNDRV_TIMER_IFLG_CALLBACK)
	return -EINVAL;

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",657,-19.06408833571088,-0.029016877223304233
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
struct snd_timer * timer = NULL ; 
struct snd_timer_instance * slave , * tmp ; 

// Check for invalid input
if ( snd_BUG_ON ( ! timeri ) || !timeri->timer || !timeri->owner ) 
    return - ENXIO ; 

snd_timer_stop ( timeri ) ; 

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
    spin_lock_irq ( & slave_active_lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & slave_active_lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & slave_active_lock ) ; 
    } 
    
    spin_unlock_irq ( & slave_active_lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    mutex_unlock ( & register_mutex ) ; 
} else { 
    timer = timeri -> timer ; 
    if ( snd_BUG_ON ( ! timer ) ) 
        goto out ; 
    
    spin_lock_irq ( & timer -> lock ) ; 
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
        spin_unlock_irq ( & timer -> lock ) ; 
        udelay ( 10 ) ; 
        spin_lock_irq ( & timer -> lock ) ; 
    } 
    spin_unlock_irq ( & timer -> lock ) ; 
    mutex_lock ( & register_mutex ) ; 
    list_del ( & timeri -> open_list ) ; 
    
    //Added input validation code
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close && timer->hw.close != NULL) 
        timer -> hw . close ( timer ) ; 
    
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
        spin_lock_irq ( & slave_active_lock ) ; 
        _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
        list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
        slave -> master = NULL ; 
        slave -> timer = NULL ; 
        spin_unlock_irq ( & slave_active_lock ) ; 
    } 
    mutex_unlock ( & register_mutex ) ; 
} 
out : 
if ( timeri -> private_free ) 
    timeri -> private_free ( timeri ) ; 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) 
    module_put ( timer -> module ) ; 
    
return 0 ; 
}",777,-57.06118931179973,-0.07343782408211033
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( timeri == NULL ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( timer == NULL ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",581,-4.827995240795476,-0.008309802479854519
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri ) return - ENXIO ; 

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( ! timer ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }

The vulnerability has been fixed by removing the snd_BUG_ON() statement at the beginning of the function, which was causing the function to always return -ENXIO when it was passed an invalid timeri argument. The function now checks for a valid timeri argument before continuing.",631,-49.60410547377758,-0.0786118945701705
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( timeri == NULL || !timeri->flags ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( timer == NULL ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",587,-11.1167486933809,-0.018938243089234925
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if (! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( ! timer || snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",601,-9.088528085196277,-0.01512234290382076
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri ) return - ENXIO ; if ( ! timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { timer = timeri -> timer ; if ( ! timer || snd_BUG_ON ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) ) { return - EINVAL ; } } snd_timer_stop ( timeri ) ; spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",486,-21.58891925679906,-0.044421644561314935
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; // Added proper input validation 
snd_timer_stop ( timeri ) ; 
if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { 
spin_lock_irq ( & slave_active_lock ) ; 
while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
spin_unlock_irq ( & slave_active_lock ) ; 
udelay ( 10 ) ; 
spin_lock_irq ( & slave_active_lock ) ; 
} 
spin_unlock_irq ( & slave_active_lock ) ; 
mutex_lock ( & register_mutex ) ; 
list_del ( & timeri -> open_list ) ; 
mutex_unlock ( & register_mutex ) ; 
} 
else { 
timer = timeri -> timer ; 
if ( snd_BUG_ON ( ! timer ) ) goto out ; 
spin_lock_irq ( & timer -> lock ) ; 
while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { 
spin_unlock_irq ( & timer -> lock ) ; 
udelay ( 10 ) ; 
spin_lock_irq ( & timer -> lock ) ; 
} 
spin_unlock_irq ( & timer -> lock ) ; 
mutex_lock ( & register_mutex ) ; 
list_del ( & timeri -> open_list ) ; 
if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) { 
if ( timeri -> hw . close ) { // Added proper input validation 
timeri -> hw . close ( timer ) ; 
} 
} 
list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { 
spin_lock_irq ( & slave_active_lock ) ; 
_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; 
list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; 
slave -> master = NULL ; 
slave -> timer = NULL ; 
spin_unlock_irq ( & slave_active_lock ) ; 
} 
mutex_unlock ( & register_mutex ) ; 
} 
out : 
if ( timeri -> private_free ) { 
if ( timeri -> private_free ) { // Added proper input validation 
timeri -> private_free ( timeri ) ; 
} 
} 
kfree ( timeri -> owner ) ; 
kfree ( timeri ) ; 
if ( timer ) { 
if ( timer ) { // Added proper input validation 
module_put ( timer -> module ) ; 
} 
} 
return 0 ; 
}",769,-40.18113293653569,-0.05225114816194498
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( ! timeri ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( ! timer ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; if(timeri) kfree ( timeri ) ; // added else statement if ( timer ) module_put ( timer -> module ) ; return 0 ; }",588,-26.964392984478884,-0.04585781119809334
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 

if (timeri == NULL) return -ENXIO; 

//Validate the fields of timeri 
if (timeri->flags == NULL || timeri->timer == NULL || timeri->owner == NULL || timeri->private_free == NULL) return -EINVAL; 

snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; 

//Validate the fields of timer 
if (timer->hw.close == NULL) return -EINVAL; 

spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",660,-35.3959689624365,-0.053630256003691666
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { 
  struct snd_timer * timer = NULL ;
  struct snd_timer_instance * slave , * tmp ;
  
  if ( ! timeri || snd_BUG_ON ( ! timeri ) ) return - ENXIO ; // added !timeri check
  
  snd_timer_stop ( timeri ) ;
  if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) {
    spin_lock_irq ( & slave_active_lock ) ;
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
      spin_unlock_irq ( & slave_active_lock ) ;
      udelay ( 10 ) ;
      spin_lock_irq ( & slave_active_lock ) ;
    }
    spin_unlock_irq ( & slave_active_lock ) ;
    mutex_lock ( & register_mutex ) ;
    list_del ( & timeri -> open_list ) ;
    mutex_unlock ( & register_mutex ) ;
  } else {
    timer = timeri -> timer ;
    if ( snd_BUG_ON ( ! timer ) ) goto out ;
    spin_lock_irq ( & timer -> lock ) ;
    while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) {
      spin_unlock_irq ( & timer -> lock ) ;
      udelay ( 10 ) ;
      spin_lock_irq ( & timer -> lock ) ;
    }
    spin_unlock_irq ( & timer -> lock ) ;
    mutex_lock ( & register_mutex ) ;
    list_del ( & timeri -> open_list ) ;
    if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) {
      timer -> hw . close ( timer ) ;
    } // added curly brace
    list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {
      spin_lock_irq ( & slave_active_lock ) ;
      _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ;
      list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ;
      slave -> master = NULL ;
      slave -> timer = NULL ;
      spin_unlock_irq ( & slave_active_lock ) ;
    }
    mutex_unlock ( & register_mutex ) ;
  }
out:
  if ( timeri -> private_free ) { 
    timeri -> private_free ( timeri ) ; // added curly brace
  } 
  kfree ( timeri -> owner ) ;
  kfree ( timeri ) ;
  if ( timer ) module_put ( timer -> module ) ;
  return 0 ;
}",720,-46.349099184690964,-0.06437374886762634
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) || snd_BUG_ON (! timeri->timer)) return - ENXIO ; 

snd_timer_stop ( timeri ) ; 

if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; 

mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if (timeri->timer && timeri->timer->hw.close) timeri->timer->hw.close(timeri); mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",644,-31.822212253419377,-0.0494133730643158
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
//Validation of timeri 
if ( snd_BUG_ON ( ! timeri ) || snd_BUG_ON ( timeri->flags > SNDRV_TIMER_IFLG_SLAVE)) return - ENXIO ;

snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",635,-28.932575088223437,-0.04556311037515502
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; 
if ( timeri == NULL ) return -ENXIO;
if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
    spin_lock_irq( & slave_active_lock );
    while ( timeri->flags & SNDRV_TIMER_IFLG_CALLBACK ) {
        spin_unlock_irq(&slave_active_lock);
        udelay(10);
        spin_lock_irq(&slave_active_lock);
    }
    spin_unlock_irq(&slave_active_lock);
    mutex_lock(&register_mutex);
    list_del(&timeri->open_list);
    mutex_unlock(&register_mutex);
} else {
    timer = timeri->timer;
    if (timer == NULL) goto out;
    spin_lock_irq(&timer->lock);
    while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
        spin_unlock_irq(&timer->lock);
        udelay(10);
        spin_lock_irq(&timer->lock);
    }
    spin_unlock_irq(&timer->lock);
    mutex_lock(&register_mutex);
    list_del(&timeri->open_list);
    if ( timer && list_empty(&timer->open_list_head) && timer->hw.close) {
        timer->hw.close(timer);
    }
    list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head, open_list) {
        spin_lock_irq(&slave_active_lock);
        _snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
        list_move_tail(&slave->open_list, &snd_timer_slave_list);
        slave->master = NULL;
        slave->timer = NULL;
        spin_unlock_irq(&slave_active_lock);
    }
    mutex_unlock(&register_mutex);
}
out:
if (timeri->private_free) timeri->private_free(timeri);
kfree(timeri->owner);
kfree(timeri);
if (timer) module_put(timer->module);
return 0;
}",606,-33.19883070233922,-0.05478354901376109
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) {
 struct snd_timer * timer = NULL ;
 struct snd_timer_instance * slave , * tmp ;
 
 // Validate pointer
 if ( timeri == NULL ) return - ENXIO ;
 
 // Validate pointer
 if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ;
 
 snd_timer_stop ( timeri ) ;
 
 if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) {
  spin_lock_irq ( & slave_active_lock ) ;
  
  // Validate pointer
  while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK && timeri != NULL ) { 
   spin_unlock_irq ( & slave_active_lock ) ;
   udelay ( 10 ) ;
   spin_lock_irq ( & slave_active_lock ) ;
  } 
  
  spin_unlock_irq ( & slave_active_lock ) ;
  mutex_lock ( & register_mutex ) ;
  
  // Validate pointer
  list_del ( & timeri -> open_list ) && timeri != NULL ; 
  
  mutex_unlock ( & register_mutex ) ;
 } 
 else {
  timer = timeri -> timer ;
  
  // Validate pointer
  if ( snd_BUG_ON ( ! timer ) && timer != NULL) goto out ;
  
  spin_lock_irq ( & timer -> lock ) ;
  
  // Validate pointer
  while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK && timeri != NULL ) { 
   spin_unlock_irq ( & timer -> lock ) ;
   udelay ( 10 ) ;
   spin_lock_irq ( & timer -> lock ) ;
  }
  
  spin_unlock_irq ( & timer -> lock ) ;
  mutex_lock ( & register_mutex ) ;
  
  // Validate pointer
  list_del ( & timeri -> open_list ) && timeri != NULL ;
  
  if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) 
   timer -> hw . close ( timer ) ;
  
  list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {
   spin_lock_irq ( & slave_active_lock ) ;
   
   // Validate pointer
   _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) && slave != NULL ;
   list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ;
   slave -> master = NULL ;
   slave -> timer = NULL ;
   spin_unlock_irq ( & slave_active_lock ) ;
  } 
  
  mutex_unlock ( & register_mutex ) ;
 } 
 
 out : 
 
 // Validate pointer
 if ( timeri -> private_free ) timeri -> private_free ( timeri ) && timeri != NULL ;
 
 kfree ( timeri -> owner ) ;
 kfree ( timeri ) ;
 
 if ( timer ) module_put ( timer -> module ) ;
 return 0 ;
}",823,-69.34077413933784,-0.0842536745313947
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
Fixed code:","
int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( timeri == NULL || !snd_timer_instance_is_valid(timeri)) { return -ENXIO; } snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( timer == NULL || !snd_timer_is_valid(timer) ) { goto out ; } spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }",613,-17.41342651568486,-0.028406894805358664
