Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
The vulnerability fix is to add an input validation check to ensure the operation is not performed if the ARCHIVE_EXTRACT_UNLINK flag is not set. This is done by adding an if statement to the code that checks if the flag is set before performing the unlink() operation. If the flag is not set, the code will instead set an error and return a failed status.",599,-61.41320571293703,-0.10252621988804178
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\0' ) && ( * p == * pn ) ) { // Added input validation to check for invalid character if (*pn < 0 || *pn > 127) { return ARCHIVE_FAILED; } ++ p , ++ pn ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\0' ) ) { while ( * pn != '\0' && * pn != '/' ) { // Added input validation to check for invalid character if (*pn < 0 || *pn > 127) { return ARCHIVE_FAILED; } ++ pn ; } c = pn [ 0 ] ; pn [ 0 ] = '\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",710,-25.416172751970997,-0.035797426411226754
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { #if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; #else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) && ( * pn != '/' ) ) ++ p , ++ pn ; if ( * pn == '/' ) { archive_set_error ( & a -> archive , 0 , ""Improper Input Validation detected"" ) ; return ( ARCHIVE_FAILED ) ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; #endif }",698,-20.147370415171583,-0.028864427528899117
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { // Added check to ensure the pathname does not contain malicious characters  if (strpbrk(a->name, "";<>|*?$"") != NULL) { archive_set_error ( & a -> archive , 0 , ""Malicious characters detected in pathname %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",735,-48.888270964770314,-0.06651465437383716
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks(struct archive_write_disk *a) {
#if !defined(HAVE_LSTAT)
	(void)a;
	return (ARCHIVE_OK);
#else 
	char *pn;
	char c;
	int r;
	struct stat st;
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn)) ++p, ++pn;
	}
	if (pn == a->name && pn[0] == '/') ++pn;
	c = pn[0];
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		while (*pn != '\0' && *pn != '/') ++pn;
		c = pn[0];
		pn[0] = '\0';
		r = lstat(a->name, &st);
		if (r != 0) {
			if (errno == ENOENT) {
				break;
			}
			else {
				return (ARCHIVE_FAILED);
			}
		}
		else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno, ""Could not remove symlink %s"", a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0, ""Removing symlink %s"", a->name);
				}
				pn[0] = c;
				return (0);
			}
			else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0, ""Cannot remove intervening symlink %s"", a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			}
			else {
				if (archive_strlen(&(a->path_safe)) > 0) {
					if (archive_strlen(&(a->path_safe)) == 2 &&
						archive_strcmp(&(a->path_safe), "".."") == 0) {
						archive_set_error(&a->archive, 0,
							""Cannot extract through parent directory symlink %s"", a->name);
						pn[0] = c;
						return (ARCHIVE_FAILED);
					}
					if (archive_strcmp(&(a->path_safe), ""."") == 0) {
						archive_set_error(&a->archive, 0,
							""Cannot extract through current directory symlink %s"", a->name);
						pn[0] = c;
						return (ARCHIVE_FAILED);
					}
				}
				archive_set_error(&a->archive, 0, ""Cannot extract through symlink %s"", a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;",1000,-59.05450055943022,-0.05905450055943022
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { //Checking Input Validation if(!is_valid_symlink(a->name)) { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }

//Function to check Input Validation
bool is_valid_symlink(char *name) {
    if(!name)
        return false;
    if(strlen(name) > MAX_LENGTH)
        return false;
    return true;
}",729,-56.492130658387566,-0.07749263464799391
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; char * path_safe = a -> path_safe . s ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { int len = strlen(path_safe); if(len > strlen(pn)) { archive_set_error(&a->archive, 0, ""Incorrect path length.""); return (ARCHIVE_FAILED); } char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
The vulnerability in the original code is that it does not verify the length of the path_safe string, which could lead to a buffer overflow. The fixed code checks the length of the path_safe string before proceeding, and if the string is too long, it will return an error.",766,-79.61778553174558,-0.1039396677960125
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; //Check if the user-supplied input is valid if (pn == NULL || strlen(pn) == 0) { archive_set_error ( & a -> archive , 0 , ""Invalid input for check_symlinks"" ) ; return ( ARCHIVE_FAILED ) ; } if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",706,-29.528613394165372,-0.04182523143649486
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) { if (!isalnum(*p)) { return ARCHIVE_FAILED; } ++ p , ++ pn ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",664,-8.34817048800067,-0.01257254591566366
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { 
//Check if the name is valid before continuing
if (!archive_strlen(&(a->name)) > 0 || a->name == NULL) {
	archive_set_error(&a->archive, 0, ""Cannot extract through symlink %s"", a->name); 
	pn[0] = c; 
	return (ARCHIVE_FAILED);
} 

if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",734,-50.46427471048106,-0.06875241786169081
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; 
//Check if the file exists
if ( r != 0 && errno != ENOENT ) { 
  return ( ARCHIVE_FAILED ) ; } 
if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",648,-31.978620504718354,-0.04934972300110857
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { //Added input validation if(strlen(pn) > FILENAME_MAX) { return (ARCHIVE_FAILED); } if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",673,-22.446709525090142,-0.03335320880399724
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) { // Check for valid characters before incrementing pointers. if (!isalnum(*p)) { return (ARCHIVE_FAILED); } ++ p , ++ pn ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",674,-23.462654199049535,-0.03481105964250673
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; } c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK && input_validation_check(a) == 1) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }

int input_validation_check(struct archive_write_disk* a) {
    // Check if flags is valid
    if (a->flags != ARCHIVE_EXTRACT_UNLINK) {
        return 0;
    }
    return 1;
}",720,-49.876132070869346,-0.06927240565398521
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) { if ( ! isalnum ( * pn ) ) { // Validate input by checking if the character is alphanumeric. return ( ARCHIVE_FAILED ) ; } ++ p , ++ pn ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",685,-23.751839544455727,-0.03467421831307405
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; 

//adding validation to check size of a->path_safe
if(archive_strlen(&(a->path_safe)) > 0){
    if(archive_strlen(&(a->path_safe)) > ARCHIVE_NAME_MAX){
        archive_set_error(&a->archive, 0, ""Path safe size exceeds max size"");
        return ARCHIVE_FAILED;
    }
    char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ;
}
if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",722,-57.62460580603082,-0.07981247341555515
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { // Check input for valid file name before unlink if ( !valid_filename(a->name) ) { archive_set_error ( & a -> archive , 0 , ""Invalid file name: %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } else { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",717,-36.80900886349686,-0.05133752979567205
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( ! S_ISLNK ( a -> mode ) && ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) && unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }

The code has been updated to prevent the vulnerability by adding a check for the mode of the symlink before unlink is called. This ensures that the application is not trying to unlink a symlink that it does not own.",724,-49.42426114230678,-0.06826555406395965
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { // Added input validation if(pn[0] != '/' || pn[1] != '\0') { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",670,-19.951400338611634,-0.02977820946061438
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; int isValid = 1; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) { // Validate that the directory is valid and does not contain any malicious path if (*p == '.' && *(p+1) == '.') { isValid = 0; break; } ++ p , ++ pn ; } if (!isValid) { a-> archive_set_error ( & a -> archive , 0 , ""Invalid path for symlink %s"" , a -> name ) ; return ( ARCHIVE_FAILED ) ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",742,-64.17890423643527,-0.0864944801030125
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","

static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else if ( errno == EACCES ) { archive_set_error ( & a -> archive , 0 , ""Permission denied on %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }

The code has been updated to include an additional check for the EACCES permission error if the lstat() system call fails. This error is checked in an if/else statement, and an appropriate error message is set if the error is encountered. This helps to ensure that the code is not vulnerable to improper input validation, as it is now explicitly checking for permission errors.",780,-82.52901686418966,-0.10580643187716622
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { if ( archive_strlen ( & a -> name ) > 0 && ! is_valid_name ( a -> name ) ) { archive_set_error ( & a -> archive , 0 , ""Cannot extract data through a symlink with an invalid name %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }

In the fixed code, we have added an additional check to verify whether the name of the symlink is valid before attempting to extract data through it. The check is_valid_name(a->name) is added before the error message is set. This ensures that input validation is properly performed, thereby fixing the vulnerability.",796,-87.06088494584266,-0.10937297103749077
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) { // Ensure only valid characters are accepted if ( ! isalnum ( * p ) ) { return ARCHIVE_FAILED ; } ++ p , ++ pn ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",675,-19.48557931291291,-0.028867524908019127
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) && ( isalnum ( * pn ) || isspace ( * pn ) ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",663,-12.181517815679651,-0.018373330038732507
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { // Added input validation if (c != '\0' && c != '/') { archive_set_error ( & a -> archive , 0 , ""Improper input validation for symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",713,-25.180649395440376,-0.0353164788154844
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else if (( a -> flags & ARCHIVE_EXTRACT_SECURE_SYMLINKS ) == 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }

The code has been fixed to address CWE-20: Improper Input Validation by adding an additional condition to the else-if statement to check the flag for secure symlink extraction. This will make sure that extraction through symlinks is only allowed when the flag is set.",728,-62.86609954181234,-0.08635453233765432
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) && ( * pn != ';' ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
The code has been fixed by adding the check of the character ';' to the while loop at line 8. This check ensures that the input is validated and can help to prevent malicious inputs from being passed.",697,-56.73899886847782,-0.08140458948131682
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; if ( a -> name == NULL ) { return ( ARCHIVE_FAILED ) ; } pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",665,-6.869300565713604,-0.010329775286787374
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { //Added validation check if (strlen(pn) > PATH_MAX || pn[strlen(pn) - 1] == '/') { archive_set_error ( & a -> archive , 0 , ""Input path is too long or invalid %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",725,-35.537904322615184,-0.04901779906567612
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( ! archive_validate_file_name ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Invalid file name %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( ! archive_validate_file_name ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Invalid file name %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }

The vulnerability was fixed by adding an input validation check before the unlink function is called. Specifically, an archive_validate_file_name check was added to ensure the file name is valid.",816,-41.97175815326044,-0.051435978128995634
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { // Added input validation check to prevent improper input if (a->name == NULL || strlen(a->name) > MAX_PATH_LENGTH){ return ( ARCHIVE_FAILED ) ; } if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",688,-32.15346947097034,-0.046734693998503406
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) { // Validate input before proceeding further if ( ! isSafe ( p ) ) { return ARCHIVE_FAILED ; } ++ p , ++ pn ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",673,-27.49387348369391,-0.04085270948542929
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\0' ) && ( * p == * pn ) ){ //Added a brace around the statements ++ p , ++ pn ; } } //Added an if-statement to ensure that the path is valid if ( pn == a -> name && pn [ 0 ] == '/' && strlen(pn) > 0) { //Added strlen to check the path length ++ pn ; } c = pn [ 0 ] ; while ( pn [ 0 ] != '\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\0' ) ) { while ( * pn != '\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",685,-62.7359511761551,-0.09158533018416802
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } // Add check to ensure the source of path_safe is the same as the source of a->name. if (strcmp(a->name, a->path_safe.s) != 0) { archive_set_error ( & a -> archive , 0 , ""Improper input validation detected"" ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",729,-50.71552147770987,-0.06956861656750325
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) { if (!isalpha(*pn) && !isdigit(*pn)) { archive_set_error ( & a -> archive , 0 , ""Invalid input detected""); return (ARCHIVE_FAILED); } ++ pn ; } c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",690,-22.402590152341393,-0.03246752195991506
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else if ( ! S_ISLNK ( a -> mode ) ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
The code has been modified to fix the vulnerability by adding an additional condition to the if-else statement to ensure the ARCHIVE_EXTRACT_UNLINK flag is set before unlink() is called. This ensures that the unlink() operation is only performed when the flag is set, thus improving input validation.",697,-55.015025171545645,-0.0789311695431071
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { // Add input validation for safety if ( ! validate_input ( a -> name ) ) { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif } 
// Validation function
bool validate_input ( char * input ) { // Perform input validation here //.... return true ; }",691,-50.07188937746583,-0.07246293687042812
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\0' ) ) { while ( * pn != '\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { pn [ 0 ] = c ; if ( pn [ 0 ] != '\0' ) { pn ++ ; continue ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; return ( ARCHIVE_FAILED ) ; } } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",668,-18.04360126359128,-0.027011379137112695
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) { // Ensure that the input is properly validated if (!isalnum(*p)) { return ARCHIVE_FAILED; } // End of input validation ++ p , ++ pn ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",677,-26.045296570119422,-0.038471634520117315
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { // Validate input to prevent any potential malicious input if (!validate_input(a->name)) { archive_set_error ( & a -> archive , 0 , ""Input contains malicious characters %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }

// validate_input function
bool validate_input(char* name) {
  int len = strlen(name);
  for (int i = 0; i < len; i++) {
    if (!(name[i] >= 'a' && name[i] <= 'z') && !(name[i] >= 'A' && name[i] <= 'Z') && 
        !(name[i] >= '0' && name[i] <= '9') && name[i] != ' ') {
      return false;
    }
  }
  return true;
}",850,-63.219850732062774,-0.07437629497889738
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; //Validate that the path_safe length is not greater than the name if ( archive_strlen ( & ( a -> path_safe ) ) > archive_strlen ( & ( a -> name ) ) ) { return ( ARCHIVE_FAILED ) ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",640,-27.280248850706403,-0.042625388829228755
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","

static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { //Adding a check to ensure user input is valid if ( a -> name && strlen ( a -> name ) < PATH_MAX ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } else { return ARCHIVE_FAILED; //Error message for incorrect user input } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",694,-51.538676568773404,-0.07426322272157551
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; 

// Added input validation check
if(pn == NULL){
    return ARCHIVE_FAILED;
}

if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",674,-20.810527414380143,-0.03087615343379843
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) )  { // Added check for directory traversal vulnerability if ( ! isalpha ( * pn ) ) { archive_set_error ( & a -> archive , 0 , ""Improper Input Validation: Invalid character in input"" ) ; return ( ARCHIVE_FAILED ) ; } ++ p , ++ pn ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",706,-39.8839125226806,-0.05649279394147394
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) { //Added validation to check for malicious input if (*p == '\0' || *pn == '\0' || *p == '\\' || *pn == '\\'){ return ARCHIVE_FAILED; } ++ p , ++ pn ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",695,-28.855073303970094,-0.04151809108484906
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; c = pn [ 0 ] ; if ( c == '\\0' ) { return ( ARCHIVE_OK ) ; } } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",672,-15.992037990452694,-0.023797675581030794
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } // VALIDATION CHANGES BEGIN: Added validation to ensure only the valid symlinks are removed if ( ( c != '\\0') && (pn[0] == '/' || pn[0] == '\\') && (pn[1] != '\\0')) { archive_set_error ( & a -> archive , errno , ""Symlink is not valid %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } // VALIDATION CHANGES END a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",764,-85.10860814423532,-0.11139870175947031
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\0' ) ) { while ( * pn != '\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\0' ; r = lstat ( a -> name , & st ) ; //Validate the user input here: if (r < 0 || !archive_strlen(a->name)) { archive_set_error(&a->archive, errno, ""Could not validate input %s"", a->name); return ARCHIVE_FAILED; } if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }",704,-39.86698490934914,-0.05662923992805276
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) && errno != EINVAL ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 && errno != EINVAL ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }

The vulnerability was fixed by adding an extra condition to the code that checks for the errno value EINVAL when unlink() is called. This ensures that the code will only proceed if the errno value is not EINVAL, preventing improper input validation.",713,-43.65204213588939,-0.061223060499143604
"The Original Code is vulnerable to CWE-20: Improper Input Validation. Fix the vulnerability.
Original Code:
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
Fixed code:","
static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) && ( pn != NULL ) ) ++ p , ++ pn ; } if ( pn == NULL || pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Could not remove symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removing symlink %s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot remove intervening symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot extract through symlink %s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }

The vulnerability was fixed by adding a check to make sure that 'pn' is not null before attempting to check if 'pn' equals 'a->name' in the if statement. This ensures that 'pn' will not be dereferenced if it is null, which would cause a crash.",719,-54.76814036680533,-0.07617265697747612
