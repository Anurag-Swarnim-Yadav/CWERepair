Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
    
    char path[1024];
    char *page;
    
    if ( func != NULL && * func != '\\0' ) {
        if ( ! strcmp ( func , ""page/get"" ) ) {
            page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            if ( page ) {
                // Create absolute path for the requested page
                snprintf(path, sizeof(path), ""./pages/%s"", page); 
                if ( access ( path , R_OK ) == 0 ) {
                    http_response_printf ( res , ""%s"" , file_read ( path ) ) ; // Use absolute path
                    http_response_send ( res ) ;
                    return ;
                }
            }
        } else if ( ! strcmp ( func , ""page/set"" ) ) {
            char * wikitext = NULL ;
            page = http_request_param_get ( req , ""page"" ) ;
            if ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL && page != NULL ) {
                // Create absolute path for the requested page
                snprintf(path, sizeof(path), ""./pages/%s"", page); 
                file_write ( path , wikitext ) ; // Use absolute path
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/delete"" ) ) {
            page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            if ( page ) {
                // Create absolute path for the requested page
                snprintf(path, sizeof(path), ""./pages/%s"", page); 
                if ( unlink ( path ) > 0 ) {  // Use absolute path
                    http_response_printf ( res , ""success"" ) ;
                    http_response_send ( res ) ;
                    return ;
                }
            }
        } else if ( ! strcmp ( func , ""page/exists"" ) ) {
            page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            if ( page ) {
                // Create absolute path for the requested page
                snprintf(path, sizeof(path), ""./pages/%s"", page); 
                if ( access ( path , R_OK ) == 0 ) {  // Use absolute path
                    http_response_printf ( res , ""success"" ) ;
                    http_response_send ( res ) ;
                    return ;
                }
            }
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
            WikiPageList * * pages = NULL ;
            int n_pages , i ;
            char * expr = http_request_param_get ( req , ""expr"" ) ;
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
            pages = wiki_get_pages ( & n_pages , expr ) ;
            if ( pages ) {
                for ( i = 0 ; i < n_pages ; i ++ ) {
                    struct tm * pTm ;
                    char datebuf [ 64 ] ;
                    pTm = localtime ( & pages [ i ] -> mtime ) ;
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
                }
                http_response_send ( res ) ;
                return ;
            }
        }
    }
    
    http_response_set_status ( res , 500 , ""Error"" ) ;
    http_response_printf ( res , ""<html><body>Failed",1000,-62.07598627063543,-0.06207598627063543
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char pagePath[PATH_MAX + 1]; realpath(page, pagePath); if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char pagePath[PATH_MAX + 1]; realpath(page, pagePath); file_write ( pagePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char pagePath[PATH_MAX + 1]; realpath(page, pagePath); if ( page && ( unlink ( pagePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char pagePath[PATH_MAX + 1]; realpath(page, pagePath); if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",825,-13.154438820509196,-0.015944774327889932
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char full_path[256]; snprintf(full_path, sizeof(full_path), ""/restricted_dir/%s"", page) ; if ( page && ( access ( full_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char full_path[256]; snprintf(full_path, sizeof(full_path), ""/restricted_dir/%s"", page) ; file_write ( full_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char full_path[256]; snprintf(full_path, sizeof(full_path), ""/restricted_dir/%s"", page) ; if ( page && ( unlink ( full_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char full_path[256]; snprintf(full_path, sizeof(full_path), ""/restricted_dir/%s"", page) ; if ( page && ( access ( full_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; char full_path[256]; snprintf(full_path, sizeof(full_path), ""/restricted_dir/%s"", expr) ; pages = wiki_get_pages ( & n_pages , full_path ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",915,-26.194220858153447,-0.028627563779402673
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char validPage[50]; snprintf(validPage, sizeof(validPage), ""./pages/%s"", page); if ( page && ( access ( validPage , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( validPage ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char validPage[50]; snprintf(validPage, sizeof(validPage), ""./pages/%s"", page); file_write ( validPage , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char validPage[50]; snprintf(validPage, sizeof(validPage), ""./pages/%s"", page); if ( page && ( unlink ( validPage ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char validPage[50]; snprintf(validPage, sizeof(validPage), ""./pages/%s"", page); if ( page && ( access ( validPage , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",857,-21.776457335899703,-0.025410101908867798
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
  if ( func != NULL && * func != '\\0' ) {
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      const char * dir = ""pages"";
      char fullPath[1024];
      snprintf(fullPath, sizeof(fullPath), ""%s/%s"", dir, page);
      if ( page && ( access ( fullPath , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""%s"" , file_read ( fullPath ) ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        const char * dir = ""pages"";
        char fullPath[1024];
        snprintf(fullPath, sizeof(fullPath), ""%s/%s"", dir, page);
        file_write ( fullPath , wikitext ) ;
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      const char * dir = ""pages"";
      char fullPath[1024];
      snprintf(fullPath, sizeof(fullPath), ""%s/%s"", dir, page);
      if ( page && ( unlink ( fullPath ) > 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      const char * dir = ""pages"";
      char fullPath[1024];
      snprintf(fullPath, sizeof(fullPath), ""%s/%s"", dir, page);
      if ( page && ( access ( fullPath , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
      pages = wiki_get_pages ( & n_pages , expr ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
          const char * dir = ""pages"";
          char fullPath[1024];
          snprintf(fullPath, sizeof(fullPath), ""%s/%s"", dir, pages [ i ] -> name);
          http_response_printf ( res , ""%s\\t%s\\n"" , fullPath , datebuf ) ;
        }
        http_response_send ( res ) ;
        return ;",1000,-28.904741064114955,-0.028904741064114954
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            char filepath[PATH_MAX] = """";
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page && ( strlen(page) + strlen(ALLOWED_DIRECTORY) <= PATH_MAX ) { 
		strcat(filepath, ALLOWED_DIRECTORY);
		strcat(filepath, page);
                if ( access ( filepath , R_OK ) == 0 ) { 
                    http_response_printf ( res , ""%s"" , file_read ( filepath ) ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            } 
        } else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            char filepath[PATH_MAX] = """";
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) && ( strlen(page) + strlen(ALLOWED_DIRECTORY) <= PATH_MAX ) ) { 
		strcat(filepath, ALLOWED_DIRECTORY);
		strcat(filepath, page);
                file_write ( filepath , wikitext ) ; 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            char filepath[PATH_MAX] = """";
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page && ( strlen(page) + strlen(ALLOWED_DIRECTORY) <= PATH_MAX ) { 
		strcat(filepath, ALLOWED_DIRECTORY);
		strcat(filepath, page);
                if ( unlink ( filepath ) > 0 ) { 
                    http_response_printf ( res , ""success"" ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            } 
        } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            char filepath[PATH_MAX] = """";
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            if ( page && ( strlen(page) + strlen(ALLOWED_DIRECTORY) <= PATH_MAX ) { 
		strcat(filepath, ALLOWED_DIRECTORY);
		strcat(filepath, page);
                if ( access ( filepath , R_OK ) == 0 ) { 
                    http_response_printf ( res , ""success"" ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                } 
            } 
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct t",1000,-51.70026465976819,-0.05170026465976819
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char safePath[PATH_MAX]; realpath( page, safePath); if ( page && ( access ( safePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( safePath ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char safePath[PATH_MAX]; realpath( page, safePath); file_write ( safePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char safePath[PATH_MAX]; realpath( page, safePath); if ( page && ( unlink ( safePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char safePath[PATH_MAX]; realpath( page, safePath); if ( page && ( access ( safePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",817,-18.167265658153433,-0.022236555273137615
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
if ( func != NULL && * func != '\\0' ) {
if ( ! strcmp ( func , ""page/get"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
char page_path[256] = {0};
snprintf(page_path, sizeof(page_path), ""pages/%s"", page);
if ( page && ( access ( page_path , R_OK ) == 0 ) ) {
http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""page/set"" ) ) {
char * wikitext = NULL , * page = NULL ;
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
char page_path[256] = {0};
snprintf(page_path, sizeof(page_path), ""pages/%s"", page);
file_write ( page_path , wikitext ) ;
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""page/delete"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
char page_path[256] = {0};
snprintf(page_path, sizeof(page_path), ""pages/%s"", page);
if ( page && ( unlink ( page_path ) > 0 ) ) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""page/exists"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
char page_path[256] = {0};
snprintf(page_path, sizeof(page_path), ""pages/%s"", page);
if ( page && ( access ( page_path , R_OK ) == 0 ) ) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
WikiPageList * * pages = NULL ;
int n_pages , i ;
char * expr = http_request_param_get ( req , ""expr"" ) ;
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
pages = wiki_get_pages ( & n_pages , expr ) ;
if ( pages ) {
for ( i = 0 ; i < n_pages ; i ++ ) {
struct tm * pTm ;
char datebuf [ 64 ] ;
pTm = localtime ( & pages [ i ] -> mtime ) ;
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
}
http_response_send ( res ) ;
return ;
}
}
}
http_response_set_status ( res , 500 , ""Error"" ) ;
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
http_response_send ( res ) ;
return ;
}",951,-18.259131662294234,-0.019199928141213705
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * pagePath = NULL ; pagePath = validate_file_path(page); if ( pagePath && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * pagePath = NULL ; pagePath = validate_file_path(page); if (pagePath) { file_write ( pagePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * pagePath = NULL ; pagePath = validate_file_path(page); if ( pagePath && ( unlink ( pagePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * pagePath = NULL ; pagePath = validate_file_path(page); if ( pagePath && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; char * pagePath = NULL ; pagePath = validate_file_path(pages[i]->name); pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pagePath, datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

// New function
char * validate_file_path (char * path) {
    char * basePath = ""/var/www/html/wiki"";
    char fullPath[1024];
    strcpy(fullPath, basePath);
    strcat(fullPath, path);
    return fullPath;
}",927,-68.09086642602409,-0.07345293034091056
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[256]; snprintf(page_path,256,""pages/%s"",page); if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char page_path[256]; snprintf(page_path,256,""pages/%s"",page); file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[256]; snprintf(page_path,256,""pages/%s"",page); if ( page && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char page_path[256]; snprintf(page_path,256,""pages/%s"",page); if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",850,-16.140605533295684,-0.018988947686230218
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char * page_path = malloc(strlen(PAGE_ROOT_DIR)+strlen(page)+2);
            sprintf(page_path, ""%s/%s"", PAGE_ROOT_DIR, page);
            if ( page && ( access ( page_path , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; 
                http_response_send ( res ) ; 
                free(page_path);
                return ; 
            } 
            free(page_path);
        } else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
                char * page_path = malloc(strlen(PAGE_ROOT_DIR)+strlen(page)+2);
                sprintf(page_path, ""%s/%s"", PAGE_ROOT_DIR, page);
                file_write ( page_path , wikitext ) ; 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                free(page_path);
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char * page_path = malloc(strlen(PAGE_ROOT_DIR)+strlen(page)+2);
            sprintf(page_path, ""%s/%s"", PAGE_ROOT_DIR, page);
            if ( page && ( unlink ( page_path ) > 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                free(page_path);
                return ; 
            } 
            free(page_path);
        } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char * page_path = malloc(strlen(PAGE_ROOT_DIR)+strlen(page)+2);
            sprintf(page_path, ""%s/%s"", PAGE_ROOT_DIR, page);
            if ( page && ( access ( page_path , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                free(page_path);
                return ; 
            } 
            free(page_path);
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct tm * pTm ; 
",1000,-26.53087743492158,-0.026530877434921583
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
char absPath[MAX_PATH];
realpath(page, absPath);
if ( page && ( access ( absPath , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( absPath ) ) ; http_response_send ( res ) ; return ; }
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) 
&& ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
char absPath[MAX_PATH];
realpath(page, absPath);
file_write ( absPath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ;
} } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
char absPath[MAX_PATH];
realpath(page, absPath);
if ( page && ( unlink ( absPath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; }
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
char absPath[MAX_PATH];
realpath(page, absPath);
if ( page && ( access ( absPath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; }
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_send ( res ) ; return ; }
}
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
http_response_send ( res ) ; return ; }",891,-55.08351511818945,-0.061822126956441584
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
if ( func != NULL && * func != '\\0' ) {
if ( ! strcmp ( func , ""page/get"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page && ( access ( page , R_OK ) == 0 ) ) {
//Check if path is within the restricted directory
if (strstr(page, ""/var/www/pages/"") != NULL) {
http_response_printf ( res , ""%s"" , file_read ( page ) ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""page/set"" ) ) {
char * wikitext = NULL , * page = NULL ;
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
//Check if path is within the restricted directory
if (strstr(page, ""/var/www/pages/"") != NULL) {
file_write ( page , wikitext ) ;
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""page/delete"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page && ( unlink ( page ) > 0 ) ) {
//Check if path is within the restricted directory
if (strstr(page, ""/var/www/pages/"") != NULL) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""page/exists"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page && ( access ( page , R_OK ) == 0 ) ) {
//Check if path is within the restricted directory
if (strstr(page, ""/var/www/pages/"") != NULL) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
WikiPageList * * pages = NULL ;
int n_pages , i ;
char * expr = http_request_param_get ( req , ""expr"" ) ;
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
pages = wiki_get_pages ( & n_pages , expr ) ;
if ( pages ) {
for ( i = 0 ; i < n_pages ; i ++ ) {
struct tm * pTm ;
char datebuf [ 64 ] ;
pTm = localtime ( & pages [ i ] -> mtime ) ;
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
//Check if path is within the restricted directory
if (strstr(pages[i]->name, ""/var/www/pages/"") != NULL) {
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
}
http_response_send ( res ) ;
return ;
}
}
}
}
http_response_set_status ( res , 500 , ""Error"" ) ;
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
http_response_send ( res ) ;
return ;
}",970,-34.30027610612676,-0.03536110938775955
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char * basePath = ""/pages/"" ; char * fullPath = malloc ( strlen ( basePath ) + strlen ( page ) + 1 ) ; strcpy ( fullPath , basePath ) ; strcat ( fullPath , page ) ; if ( ! strcmp ( func , ""page/get"" ) ) { if ( access ( fullPath , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( fullPath ) ) ; http_response_send ( res ) ; free ( fullPath ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL ; if ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) { file_write ( fullPath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( fullPath ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { if ( unlink ( fullPath ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( fullPath ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { if ( access ( fullPath , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( fullPath ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; free ( fullPath ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; free ( fullPath ) ; return ; }",720,-28.281093779434453,-0.03927929691588118
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char full_path[MAX_PATH_LENGTH] if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

if ( page && ( realpath(page, full_path) != NULL ) && ( access ( full_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; 

if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL) ) { char full_path[MAX_PATH_LENGTH] if (realpath(page, full_path) != NULL) { file_write ( full_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char full_path[MAX_PATH_LENGTH] if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( realpath(page, full_path) != NULL) && ( unlink ( full_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; char full_path[MAX_PATH_LENGTH] if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && (realpath(page, full_path) != NULL) && ( access ( full_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",870,-45.28422957278423,-0.05205083858940716
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char * path = ""path/to/wiki/data/"";
if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char page_path[1024];
char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; strcpy(page_path, path);
strcat(page_path, page);
if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char page_path[1024];
strcpy(page_path, path);
strcat(page_path, page);
file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char page_path[1024];
char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; strcpy(page_path, path);
strcat(page_path, page);
if ( page && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char page_path[1024];
char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; strcpy(page_path, path);
strcat(page_path, page);
if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { char page_path[1024];
strcpy(page_path, path);
strcat(page_path, pages[i]->name);
struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , page_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",920,-38.797455747459,-0.042171147551585866
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[256]; sprintf(path, ""/path/to/wiki/pages/%s"", page); if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[256]; sprintf(path, ""/path/to/wiki/pages/%s"", page); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[256]; sprintf(path, ""/path/to/wiki/pages/%s"", page); if ( unlink ( path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char path[256]; sprintf(path, ""/path/to/wiki/pages/%s"", page); if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { char path[256]; sprintf(path, ""/path/to/wiki/pages/%s"", pages[i]->name); struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",879,-22.6729805064228,-0.02579406200958225
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
    if ( func != NULL && * func != '\\0' ) {
        if ( ! strcmp ( func , ""page/get"" ) ) {
            char * page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            if ( page && ( access ( page , R_OK ) == 0 ) ) {
                char full_page_path[PATH_MAX] = """";
                strcat(full_page_path, ""/restricted_directory/"");
                strcat(full_page_path, page);
                if ( access ( full_page_path , R_OK ) == 0 ) {
                    http_response_printf ( res , ""%s"" , file_read ( full_page_path ) ) ;
                    http_response_send ( res ) ;
                    return ;
                }
            }
        } else if ( ! strcmp ( func , ""page/set"" ) ) {
            char * wikitext = NULL , * page = NULL ;
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
                char full_page_path[PATH_MAX] = """";
                strcat(full_page_path, ""/restricted_directory/"");
                strcat(full_page_path, page);
                file_write ( full_page_path , wikitext ) ;
                http_response_printf ( res , ""success"" ) ;
                http_response_send ( res ) ;
                return ;
            }
        } else if ( ! strcmp ( func , ""page/delete"" ) ) {
            char * page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            if ( page ) {
                char full_page_path[PATH_MAX] = """";
                strcat(full_page_path, ""/restricted_directory/"");
                strcat(full_page_path, page);
                if ( unlink ( full_page_path ) > 0 ) {
                    http_response_printf ( res , ""success"" ) ;
                    http_response_send ( res ) ;
                    return ;
                }
            }
        } else if ( ! strcmp ( func , ""page/exists"" ) ) {
            char * page = http_request_param_get ( req , ""page"" ) ;
            if ( page == NULL ) page = http_request_get_query_string ( req ) ;
            if ( page ) {
                char full_page_path[PATH_MAX] = """";
                strcat(full_page_path, ""/restricted_directory/"");
                strcat(full_page_path, page);
                if ( access ( full_page_path , R_OK ) == 0 ) {
                    http_response_printf ( res , ""success"" ) ;
                    http_response_send ( res ) ;
                    return ;
                }
            }
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
            WikiPageList * * pages = NULL ;
            int n_pages , i ;
            char * expr = http_request_param_get ( req , ""expr"" ) ;
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
            pages = wiki_get_pages ( & n_pages , expr ) ;
            if ( pages ) {
                for ( i = 0 ; i < n_pages ; i ++ ) {
                    struct tm * pTm ;
                    char datebuf [ 64 ] ;
                    pTm = localtime ( & pages [ i ] -> mtime ) ;
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ]",1000,-33.07807270279932,-0.03307807270279932
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char path[PATH_MAX]; char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && realpath ( page , path ) && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char path[PATH_MAX]; char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { if ( realpath ( page , path ) ) { file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char path[PATH_MAX]; char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && realpath ( page , path ) && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char path[PATH_MAX]; char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && realpath ( page , path ) && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",812,-17.960028284488192,-0.02211826143409876
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char sanitized_page[strlen(page) + 1]; strncpy(sanitized_page, page, sizeof(sanitized_page)); sanitized_page[strlen(page)] = 0; if ( page && ( access ( sanitized_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( sanitized_page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char sanitized_page[strlen(page) + 1]; strncpy(sanitized_page, page, sizeof(sanitized_page)); sanitized_page[strlen(page)] = 0; file_write ( sanitized_page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char sanitized_page[strlen(page) + 1]; strncpy(sanitized_page, page, sizeof(sanitized_page)); sanitized_page[strlen(page)] = 0; if ( page && ( unlink ( sanitized_page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char sanitized_page[strlen(page) + 1]; strncpy(sanitized_page, page, sizeof(sanitized_page)); sanitized_page[strlen(page)] = 0; if ( page && ( access ( sanitized_page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",943,-19.983474032609845,-0.02119138285536569
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { page = realpath(page, NULL); http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; free(page); return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { page = realpath(page, NULL); file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(page); return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { page = realpath(page, NULL); http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(page); return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { page = realpath(page, NULL); http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free(page); return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",800,-11.771306890224952,-0.014714133612781191
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
  if ( func != NULL && * func != '\\0' ) {
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      page = realpath(page, NULL);
      if ( page && ( access ( page , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""%s"" , file_read ( page ) ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        page = realpath(page, NULL);
        file_write ( page , wikitext ) ;
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      page = realpath(page, NULL);
      if ( page && ( unlink ( page ) > 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      page = realpath(page, NULL);
      if ( page && ( access ( page , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
      pages = wiki_get_pages ( & n_pages , expr ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
        }
        http_response_send ( res ) ;
        return ;
      }
    }
  }
  http_response_set_status ( res , 500 , ""Error"" ) ;
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
  http_response_send ( res ) ;
  return ;
}",905,-11.18344843875279,-0.01235740158978209
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\\0' ) { 
    if ( ! strcmp ( func , ""page/get"" ) ) { 
        char * page = http_request_param_get ( req , ""page"" ) ; 
        char pagePath[PATH_MAX];

        if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
        realpath(page, pagePath);

        if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { 
            http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ; 
            http_response_send ( res ) ; 
            return ; 
        } 
    } else if ( ! strcmp ( func , ""page/set"" ) ) { 
        char * wikitext = NULL , * page = NULL ; 
        char pagePath[PATH_MAX];

        if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
            realpath(page, pagePath);
            file_write ( pagePath , wikitext ) ; 
            http_response_printf ( res , ""success"" ) ; 
            http_response_send ( res ) ; 
            return ; 
        } 
    } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
        char * page = http_request_param_get ( req , ""page"" ) ; 
        char pagePath[PATH_MAX];

        if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
        realpath(page, pagePath);

        if ( page && ( unlink ( pagePath ) > 0 ) ) { 
            http_response_printf ( res , ""success"" ) ; 
            http_response_send ( res ) ; 
            return ; 
        } 
    } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
        char * page = http_request_param_get ( req , ""page"" ) ; 
        char pagePath[PATH_MAX];

        if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
        realpath(page, pagePath);

        if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { 
            http_response_printf ( res , ""success"" ) ; 
            http_response_send ( res ) ; 
            return ; 
        } 
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
        WikiPageList * * pages = NULL ; 
        int n_pages , i ; 
        char * expr = http_request_param_get ( req , ""expr"" ) ; 
        char exprPath[PATH_MAX];

        if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
        realpath(expr, exprPath);

        pages = wiki_get_pages ( & n_pages , exprPath ) ; 
        if ( pages ) { 
            for ( i = 0 ; i < n_pages ; i ++ ) { 
                struct tm * pTm ; 
                char datebuf [ 64 ] ; 
                pTm = localtime ( & pages [ i ] -> mtime ) ; 
                strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
                http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
            } 
            http_response_send ( res ) ; 
            return ; 
        } 
    } 
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;",1000,-24.443806284196004,-0.024443806284196005
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char path[256]; if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( snprintf(path, sizeof(path)-1, ""%s/%s"", getcwd(NULL, 0), page) >= 0 ) { if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { if ( snprintf(path, sizeof(path)-1, ""%s/%s"", getcwd(NULL, 0), page) >= 0 ) { file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( snprintf(path, sizeof(path)-1, ""%s/%s"", getcwd(NULL, 0), page) >= 0 ) { if ( unlink ( path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( snprintf(path, sizeof(path)-1, ""%s/%s"", getcwd(NULL, 0), page) >= 0 ) { if ( access ( path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
In this code, the getcwd() function is used to get the absolute path of the directory and the snprintf() is used to concatenate it with the page variable, making sure that the path is limited to the restricted directory.",927,-67.04721287718426,-0.07232709048239942
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
if ( func != NULL && * func != '\\0' ) {
if ( ! strcmp ( func , ""page/get"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page ) {
char path[1024];
snprintf(path, 1024, ""./pages/%s"", page);
if ( access ( path , R_OK ) == 0 ) {
http_response_printf ( res , ""%s"" , file_read ( path ) ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""page/set"" ) ) {
char * wikitext = NULL , * page = NULL ;
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
char path[1024];
snprintf(path, 1024, ""./pages/%s"", page);
file_write ( path , wikitext ) ;
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
} else if ( ! strcmp ( func , ""page/delete"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page ) {
char path[1024];
snprintf(path, 1024, ""./pages/%s"", page);
if ( unlink ( path ) > 0 ) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""page/exists"" ) ) {
char * page = http_request_param_get ( req , ""page"" ) ;
if ( page == NULL ) page = http_request_get_query_string ( req ) ;
if ( page ) {
char path[1024];
snprintf(path, 1024, ""./pages/%s"", page);
if ( access ( path , R_OK ) == 0 ) {
http_response_printf ( res , ""success"" ) ;
http_response_send ( res ) ;
return ;
}
}
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
WikiPageList * * pages = NULL ;
int n_pages , i ;
char * expr = http_request_param_get ( req , ""expr"" ) ;
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
pages = wiki_get_pages ( & n_pages , expr ) ;
if ( pages ) {
for ( i = 0 ; i < n_pages ; i ++ ) {
struct tm * pTm ;
char datebuf [ 64 ] ;
pTm = localtime ( & pages [ i ] -> mtime ) ;
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
}
http_response_send ( res ) ;
return ;
}
}
}
http_response_set_status ( res , 500 , ""Error"" ) ;
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
http_response_send ( res ) ;
return ;
}",909,-15.858830160962606,-0.01744645782284115
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 

if ( func != NULL && * func != '\\0' ) { 

if ( ! strcmp ( func , ""page/get"" ) ) { 

char * page = http_request_param_get ( req , ""page"" ) ; 

if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

char pagepath[PATH_MAX];

if ( realpath(page, pagepath) && ( access ( pagepath , R_OK ) == 0 ) ) { 

http_response_printf ( res , ""%s"" , file_read ( pagepath ) ) ; 

http_response_send ( res ) ; 

return ; 

} 

} else if ( ! strcmp ( func , ""page/set"" ) ) { 

char * wikitext = NULL , * page = NULL ; 

if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 

char pagepath[PATH_MAX] ; 

realpath(page, pagepath);

file_write ( pagepath , wikitext ) ; 

http_response_printf ( res , ""success"" ) ; 

http_response_send ( res ) ; 

return ; 

} 

} else if ( ! strcmp ( func , ""page/delete"" ) ) { 

char * page = http_request_param_get ( req , ""page"" ) ; 

if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

char pagepath[PATH_MAX] ; 

realpath(page, pagepath);

if ( pagepath && ( unlink ( pagepath ) > 0 ) ) { 

http_response_printf ( res , ""success"" ) ; 

http_response_send ( res ) ; 

return ; 

} 

} else if ( ! strcmp ( func , ""page/exists"" ) ) { 

char * page = http_request_param_get ( req , ""page"" ) ; 

if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

char pagepath[PATH_MAX] ;

realpath(page, pagepath);

if ( pagepath && ( access ( pagepath , R_OK ) == 0 ) ) { 

http_response_printf ( res , ""success"" ) ; 

http_response_send ( res ) ; 

return ; 

} 

} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 

WikiPageList * * pages = NULL ; 

int n_pages , i ; 

char * expr = http_request_param_get ( req , ""expr"" ) ; 

if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 

pages = wiki_get_pages ( & n_pages , expr ) ; 

if ( pages ) { 

for ( i = 0 ; i < n_pages ; i ++ ) { 

struct tm * pTm ; 

char datebuf [ 64 ] ; 

pTm = localtime ( & pages [ i ] -> mtime ) ; 

strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 

http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 

} 

http_response_send ( res ) ; 

return ; 

} 

} 

} 

http_response_set_status ( res , 500 , ""Error"" ) ; 

http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 

http_response_send ( res ) ; ",1000,-40.25162922590527,-0.04025162922590527
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page ) {
char absolute_page_path[PATH_MAX];
realpath(page, absolute_page_path);
if ( access ( absolute_page_path , R_OK ) == 0 ) { 
http_response_printf ( res , ""%s"" , file_read ( absolute_page_path ) ) ; 
http_response_send ( res ) ; return ; 
} 
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
char absolute_page_path[PATH_MAX];
realpath(page, absolute_page_path);
file_write ( absolute_page_path , wikitext ) ; 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; return ; 
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page ) {
char absolute_page_path[PATH_MAX];
realpath(page, absolute_page_path);
if ( unlink ( absolute_page_path ) > 0 ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; return ; 
} 
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page ) {
char absolute_page_path[PATH_MAX];
realpath(page, absolute_page_path);
if ( access ( absolute_page_path , R_OK ) == 0 ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; return ; 
} 
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\t%s\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_send ( res ) ; return ; 
} 
} 
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\n"" ) ; 
http_response_send ( res ) ; return ; 
}",974,-31.884270854395126,-0.03273539102093955
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
  if ( func != NULL && * func != '\\0' ) {
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      
      // Check if the page path is inside the expected directory 
      if ( page && starts_with(page, ""/expected/directory/"") && ( access ( page , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""%s"" , file_read ( page ) ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        // Check if the page path is inside the expected directory 
        if (starts_with(page, ""/expected/directory/"")) {
          file_write ( page , wikitext ) ;
          http_response_printf ( res , ""success"" ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      // Check if the page path is inside the expected directory 
      if ( page && starts_with(page, ""/expected/directory/"") && ( unlink ( page ) > 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      // Check if the page path is inside the expected directory 
      if ( page && starts_with(page, ""/expected/directory/"") && ( access ( page , R_OK ) == 0 ) ) {
        http_response_printf ( res , ""success"" ) ;
        http_response_send ( res ) ;
        return ;
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
      pages = wiki_get_pages ( & n_pages , expr ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
        }
        http_response_send ( res ) ;
        return ;
      }
    }
  }
  http_response_set_status ( res , 500 , ""Error"" ) ;
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ;
  http_response_send ( res ) ;
  return ;
}",979,-41.63054044795901,-0.04252353467615833
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char filepath[400] = ""/var/www/path/to/wiki/pages/"";
            strcat(filepath, page);
            if ( page && ( access ( filepath , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""%s"" , file_read ( filepath ) ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
                char filepath[400] = ""/var/www/path/to/wiki/pages/"";
                strcat(filepath, page);
                file_write ( filepath , wikitext ) ; 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char filepath[400] = ""/var/www/path/to/wiki/pages/"";
            strcat(filepath, page);
            if ( page && ( unlink ( filepath ) > 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char filepath[400] = ""/var/www/path/to/wiki/pages/"";
            strcat(filepath, page);
            if ( page && ( access ( filepath , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct tm * pTm ; 
                    char datebuf [ 64 ] ; 
                    pTm = localtime ( & pages [ i ] -> mtime ) ; 
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
                } 
                http_response_send ( res ) ; 
                return ; 
            } 
        } 
    } 
    http_response_set_status ( res ,",1000,-33.791634551309244,-0.03379163455130924
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { 

if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

//Check if the page is within the allowed directory 
char allowed_dir[256] = ""/var/www/wiki/"";
if(strncmp(allowed_dir, page, strlen(allowed_dir)) == 0){
if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; }
}

 } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 

//Check if the page is within the allowed directory 
char allowed_dir[256] = ""/var/www/wiki/"";
if(strncmp(allowed_dir, page, strlen(allowed_dir)) == 0){
file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ;
}

 } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

//Check if the page is within the allowed directory 
char allowed_dir[256] = ""/var/www/wiki/"";
if(strncmp(allowed_dir, page, strlen(allowed_dir)) == 0){
if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; 
}
}

 } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; 

//Check if the page is within the allowed directory 
char allowed_dir[256] = ""/var/www/wiki/"";
if(strncmp(allowed_dir, page, strlen(allowed_dir)) == 0){
if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; 
}
}

 } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",986,-48.4709274884187,-0.04915915566776745
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char pagePath[MAX_PATH_LENGTH]; snprintf(pagePath, MAX_PATH_LENGTH, ""%s/%s"", RESTRICTED_DIRECTORY, page); if ( access ( pagePath , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char pagePath[MAX_PATH_LENGTH]; snprintf(pagePath, MAX_PATH_LENGTH, ""%s/%s"", RESTRICTED_DIRECTORY, page); file_write ( pagePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char pagePath[MAX_PATH_LENGTH]; snprintf(pagePath, MAX_PATH_LENGTH, ""%s/%s"", RESTRICTED_DIRECTORY, page); if ( page && ( unlink ( pagePath ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char pagePath[MAX_PATH_LENGTH]; snprintf(pagePath, MAX_PATH_LENGTH, ""%s/%s"", RESTRICTED_DIRECTORY, page); if ( page && ( access ( pagePath , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char pagePath[MAX_PATH_LENGTH]; snprintf(pagePath, MAX_PATH_LENGTH, ""%s/%s"", RESTRICTED_DIRECTORY, pages[i]->name); http_response_printf ( res , ""%s\\t%s\\n"" , pagePath , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",973,-21.624617485430118,-0.02222468395213784
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) {
  if ( func != NULL && * func != '\\0' ) {
    if ( ! strcmp ( func , ""page/get"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      if ( page ) {
        // Below line checks that the requested file is in the allowed directory
        if ( strstr(page, ""allowed_directory"") != NULL && ( access ( page , R_OK ) == 0 ) ) {
          http_response_printf ( res , ""%s"" , file_read ( page ) ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""page/set"" ) ) {
      char * wikitext = NULL , * page = NULL ;
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
        // Below line ensures that the file is written in the allowed directory
        if ( strstr(page, ""allowed_directory"") != NULL ) {
          file_write ( page , wikitext ) ;
          http_response_printf ( res , ""success"" ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""page/delete"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      if ( page ) {
        // Below line ensures that the file is deleted from the allowed directory
        if ( strstr(page, ""allowed_directory"") != NULL && ( unlink ( page ) > 0 ) ) {
          http_response_printf ( res , ""success"" ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""page/exists"" ) ) {
      char * page = http_request_param_get ( req , ""page"" ) ;
      if ( page == NULL ) page = http_request_get_query_string ( req ) ;
      if ( page ) {
        // Below line checks that the requested file is in the allowed directory
        if ( strstr(page, ""allowed_directory"") != NULL && ( access ( page , R_OK ) == 0 ) ) {
          http_response_printf ( res , ""success"" ) ;
          http_response_send ( res ) ;
          return ;
        }
      }
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) {
      WikiPageList * * pages = NULL ;
      int n_pages , i ;
      char * expr = http_request_param_get ( req , ""expr"" ) ;
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ;
      pages = wiki_get_pages ( & n_pages , expr ) ;
      if ( pages ) {
        for ( i = 0 ; i < n_pages ; i ++ ) {
          struct tm * pTm ;
          char datebuf [ 64 ] ;
          pTm = localtime ( & pages [ i ] -> mtime ) ;
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ;

          // Below line ensures that the file is in the allowed directory
          if ( strstr(page, ""allowed_directory"") != NULL ) {
            http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ;
          }
        }
        http_response_send ( res ) ;
        return ;
      }
    }
  }
  http_response_set_status ( res , 500 , ""Error"" ) ;
  http_",1000,-68.95122865238157,-0.06895122865238157
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { char filepath[PATH_MAX]; realpath(page, filepath); if(strncmp(filepath, ""/wiki"", 5) == 0) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char filepath[PATH_MAX]; realpath(page, filepath); if(strncmp(filepath, ""/wiki"", 5) == 0) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filepath[PATH_MAX]; realpath(page, filepath); if(strncmp(filepath, ""/wiki"", 5) == 0) { if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char filepath[PATH_MAX]; realpath(page, filepath); if(strncmp(filepath, ""/wiki"", 5) == 0) { if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char filepath[PATH_MAX]; realpath(pages[i]->name, filepath); if(strncmp(filepath, ""/wiki"", 5) == 0) { http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",928,-22.427677379018146,-0.02416775579635576
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
char * fullpath = malloc(strlen(page) + strlen(""path/to/dir/"") + 1);
strcpy(fullpath, ""path/to/dir/"");
strcat(fullpath, page);
if ( fullpath && ( access ( fullpath , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""%s"" , file_read ( fullpath ) ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
char * fullpath = malloc(strlen(page) + strlen(""path/to/dir/"") + 1);
strcpy(fullpath, ""path/to/dir/"");
strcat(fullpath, page);
file_write ( fullpath , wikitext ) ; 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
char * fullpath = malloc(strlen(page) + strlen(""path/to/dir/"") + 1);
strcpy(fullpath, ""path/to/dir/"");
strcat(fullpath, page);
if ( fullpath && ( unlink ( fullpath ) > 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
char * fullpath = malloc(strlen(page) + strlen(""path/to/dir/"") + 1);
strcpy(fullpath, ""path/to/dir/"");
strcat(fullpath, page);
if ( fullpath && ( access ( fullpath , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_",1000,-30.16661973964548,-0.03016661973964548
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:"," 
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { char page_path [ 256 ] ; if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { snprintf ( page_path , sizeof ( page_path ) , ""%s/%s"" , PAGES_DIR , page ) ; if ( access ( page_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { snprintf ( page_path , sizeof ( page_path ) , ""%s/%s"" , PAGES_DIR , page ) ; file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { snprintf ( page_path , sizeof ( page_path ) , ""%s/%s"" , PAGES_DIR , page ) ; if ( unlink ( page_path ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { snprintf ( page_path , sizeof ( page_path ) , ""%s/%s"" , PAGES_DIR , page ) ; if ( access ( page_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; snprintf ( page_path , sizeof ( page_path ) , ""%s/%s"" , PAGES_DIR , pages [ i ] -> name ) ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",923,-22.25567598983711,-0.024112325016074874
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
    if ( func != NULL && * func != '\\0' ) { 
        if ( ! strcmp ( func , ""page/get"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char path[1024];
            if ( page && ( realpath(page, path) != NULL ) && ( access ( path , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""%s"" , file_read ( path ) ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } 
        else if ( ! strcmp ( func , ""page/set"" ) ) { 
            char * wikitext = NULL , * page = NULL ; 
            if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
                char path[1024];
                if(realpath(page, path) != NULL){
                    file_write ( path , wikitext ) ; 
                    http_response_printf ( res , ""success"" ) ; 
                    http_response_send ( res ) ; 
                    return ; 
                }
            } 
        } 
        else if ( ! strcmp ( func , ""page/delete"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char path[1024];
            if ( page && ( realpath(page, path) != NULL ) && ( unlink ( path ) > 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } 
        else if ( ! strcmp ( func , ""page/exists"" ) ) { 
            char * page = http_request_param_get ( req , ""page"" ) ; 
            if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
            char path[1024];
            if ( page && ( realpath(page, path) != NULL ) && ( access ( path , R_OK ) == 0 ) ) { 
                http_response_printf ( res , ""success"" ) ; 
                http_response_send ( res ) ; 
                return ; 
            } 
        } 
        else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
            WikiPageList * * pages = NULL ; 
            int n_pages , i ; 
            char * expr = http_request_param_get ( req , ""expr"" ) ; 
            if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
            pages = wiki_get_pages ( & n_pages , expr ) ; 
            if ( pages ) { 
                for ( i = 0 ; i < n_pages ; i ++ ) { 
                    struct tm * pTm ; 
                    char datebuf [ 64 ] ; 
                    pTm = localtime ( & pages [ i ] -> mtime ) ; 
                    strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
                    http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
                } 
                http_response_send ( res ) ; 
                return ; 
            } 
        } 
    } 
    http_response_set_status ( res , 500 , ""Error"" ) ; 
    http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
    http_response_send (",1000,-24.062869696125013,-0.024062869696125012
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[PATH_MAX]; snprintf(path, sizeof(path), ""./%s"", page); if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char path[PATH_MAX]; snprintf(path, sizeof(path), ""./%s"", page); file_write ( path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[PATH_MAX]; snprintf(path, sizeof(path), ""./%s"", page); if ( page && ( unlink ( path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char path[PATH_MAX]; snprintf(path, sizeof(path), ""./%s"", page); if ( page && ( access ( path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The code has been fixed by adding the 'path' variable and using snprintf to create a properly restricted pathname. The 'path' variable is then used in the access, unlink, and file_write functions instead of the original 'page' variable. This ensures that the pathname is properly restricted so that users cannot traverse outside of the intended directory.",914,-62.70588227462039,-0.06860599811227613
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char file_path[PATH_MAX] = ""./wikipages/""; strcat(file_path, page); if ( page && ( access ( file_path, R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( file_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char file_path[PATH_MAX] = ""./wikipages/""; strcat(file_path, page); file_write ( file_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char file_path[PATH_MAX] = ""./wikipages/""; strcat(file_path, page); if ( page && ( unlink ( file_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char file_path[PATH_MAX] = ""./wikipages/""; strcat(file_path, page); if ( page && ( access ( file_path, R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
In the fixed code, the directory to which the pathname is limited was changed from the root directory to a dedicated directory for wikipages, which is the directory recommended for web applications. The code was also modified to ensure that any page references were preceded by the path to the wikipages directory. This prevents any possible path traversal attack by an attacker trying to access restricted files outside of the wikipages directory.",948,-125.35372256963697,-0.1322296651578449
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char * page = http_request_param_get ( req , ""page"" ) ; if (!page) page = http_request_get_query_string ( req ) ; char * wiki_pages_path = ""/data/wiki/pages/"" ; char * full_path = malloc ( sizeof ( wiki_pages_path ) + sizeof ( page ) ) ; strcpy ( full_path , wiki_pages_path ) ; strcat ( full_path , page ) ; if ( ! strcmp ( func , ""page/get"" ) ) { if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( full_path ) ) ; http_response_send ( res ) ; free ( full_path ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) ) { file_write ( full_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( full_path ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { if ( ( unlink ( full_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( full_path ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { if ( access ( full_path , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; free ( full_path ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; free ( full_path ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; free ( full_path ) ; return ; }",745,-44.596093854543874,-0.05986052866381728
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char fullPath[256]; snprintf(fullPath, sizeof(fullPath), ""%s/%s"", RESTRICTED_DIR, page); if ( access ( fullPath , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( fullPath ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char fullPath[256]; snprintf(fullPath, sizeof(fullPath), ""%s/%s"", RESTRICTED_DIR, page); file_write ( fullPath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char fullPath[256]; snprintf(fullPath, sizeof(fullPath), ""%s/%s"", RESTRICTED_DIR, page); if ( unlink ( fullPath ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char fullPath[256]; snprintf(fullPath, sizeof(fullPath), ""%s/%s"", RESTRICTED_DIR, page); if ( access ( fullPath , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",887,-17.674895495299946,-0.01992660146031561
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 

// added line
char path_prefix[256] = ""/var/www/wiki"";
char page[256] = """";
strcpy(page, path_prefix);
strcat(page, http_request_param_get ( req , ""page"" ) );
if ( access ( page , R_OK ) == 0 ) { 
http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 

// added line
char path_prefix[256] = ""/var/www/wiki"";
char page[256] = """";
strcpy(page, path_prefix);
strcat(page, http_request_param_get ( req , ""page"" ) );

char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( page != NULL ) ) { 
file_write ( page , wikitext ) ; 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 

// added line
char path_prefix[256] = ""/var/www/wiki"";
char page[256] = """";
strcpy(page, path_prefix);
strcat(page, http_request_param_get ( req , ""page"" ) );

if ( page && ( unlink ( page ) > 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 

// added line
char path_prefix[256] = ""/var/www/wiki"";
char page[256] = """";
strcpy(page, path_prefix);
strcat(page, http_request_param_get ( req , ""page"" ) );

if ( page && ( access ( page , R_OK ) == 0 ) ) { 
http_response_printf ( res , ""success"" ) ; 
http_response_send ( res ) ; 
return ; 
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http_response_send ( res ) ; 
return ; 
} 
} 
} 
http_response_set_status ( res , 500 , ""Error"" ) ; 
http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; 
http_response_send ( res ) ; 
return ; 
}",960,-53.10831652552828,-0.05532116304742529
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { char * page , *wikitext; char * rootDir = ""wiki-data""; char pagePath[MAX_PATH]; if ( ! strcmp ( func , ""page/get"" ) ) { page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { snprintf(pagePath, MAX_PATH, ""%s/%s"", rootDir, page); if ( access ( pagePath , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( pagePath ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { snprintf(pagePath, MAX_PATH, ""%s/%s"", rootDir, page); file_write ( pagePath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { snprintf(pagePath, MAX_PATH, ""%s/%s"", rootDir, page); if ( unlink ( pagePath ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { snprintf(pagePath, MAX_PATH, ""%s/%s"", rootDir, page); if ( access ( pagePath , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; snprintf(pagePath, MAX_PATH, ""%s/%s"", rootDir, pages[i]->name); http_response_printf ( res , ""%s\\t%s\\n"" , pagePath , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",873,-40.85596999243919,-0.0467995074369292
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
  char path[PATH_MAX];
  if ( func != NULL && * func != '\\0' ) { 
    if ( ! strcmp ( func , ""page/get"" ) ) { 
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      // Create absolute path to prevent path traversal
      if (realpath(page, path) != NULL) {
        if ( access ( path , R_OK ) == 0 ) { 
          http_response_printf ( res , ""%s"" , file_read ( path ) ) ;
          http_response_send ( res ) ; 
          return ; 
        } 
      } 
    } else if ( ! strcmp ( func , ""page/set"" ) ) { 
      char * wikitext = NULL , * page = NULL ;
       if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {
       // Create absolute path to prevent path traversal
        if (realpath(page, path) != NULL) {
          file_write ( path , wikitext ) ;
          http_response_printf ( res , ""success"" ) ; 
          http_response_send ( res ) ; 
          return ; 
        } 
      } 
    } else if ( ! strcmp ( func , ""page/delete"" ) ) { 
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      // Create absolute path to prevent path traversal
      if (realpath(page, path) != NULL) {
        if ( unlink ( path ) > 0 ) { 
          http_response_printf ( res , ""success"" ) ; 
          http_response_send ( res ) ; 
          return ; 
        } 
      } 
    } else if ( ! strcmp ( func , ""page/exists"" ) ) { 
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      // Create absolute path to prevent path traversal
      if (realpath(page, path) != NULL) {
        if ( access ( path , R_OK ) == 0 ) { 
          http_response_printf ( res , ""success"" ) ; 
          http_response_send ( res ) ; 
          return ; 
        } 
      } 
    } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
      WikiPageList * * pages = NULL ; 
      int n_pages , i ; 
      char * expr = http_request_param_get ( req , ""expr"" ) ; 
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
      pages = wiki_get_pages ( & n_pages , expr ) ; 
      if ( pages ) { 
        for ( i = 0 ; i < n_pages ; i ++ ) { 
          struct tm * pTm ; 
          char datebuf [ 64 ] ; 
          pTm = localtime ( & pages [ i ] -> mtime ) ; 
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
        } 
        http_response_send ( res ) ; 
        return ; 
      } 
    } 
  } 
  http_response_set_status ( res , 500 , ""Error"" ) ; 
  http_response_printf ( res , ""<html><body>F",1000,-57.29965035479121,-0.05729965035479121
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char abs_path[PATH_MAX]; realpath(page, abs_path); if ( page && ( access ( abs_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( abs_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char abs_path[PATH_MAX]; realpath(page, abs_path); file_write ( abs_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char abs_path[PATH_MAX]; realpath(page, abs_path); if ( page && ( unlink ( abs_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char abs_path[PATH_MAX]; realpath(page, abs_path); if ( page && ( access ( abs_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",830,-10.776820154712205,-0.012984120668327957
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char absolute_path[PATH_MAX]; realpath(page, absolute_path); if ( page && ( access ( absolute_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( absolute_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char absolute_path[PATH_MAX]; realpath(page, absolute_path); file_write ( absolute_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char absolute_path[PATH_MAX]; realpath(page, absolute_path); if ( page && ( unlink ( absolute_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; char absolute_path[PATH_MAX]; realpath(page, absolute_path); if ( page && ( access ( absolute_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
The vulnerability has been fixed by replacing the use of the user-supplied argument page with an absolute path created using the realpath() function. This ensures that the supplied path is confined to the directory structure the program is allowed to access.",879,-53.42306058644093,-0.060777088266713235
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * allowedPath = get_allowed_path ( page ) ; if ( access ( allowedPath , R_OK ) == 0 ) { http_response_printf ( res , ""%s"" , file_read ( allowedPath ) ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char * allowedPath = get_allowed_path ( page ) ; file_write ( allowedPath , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * allowedPath = get_allowed_path ( page ) ; if ( unlink ( allowedPath ) > 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page ) { char * allowedPath = get_allowed_path ( page ) ; if ( access ( allowedPath , R_OK ) == 0 ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; char * allowedPath = get_allowed_path ( pages[i]->name ) ; http_response_printf ( res , ""%s\\t%s\\n"" , allowedPath , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

char *get_allowed_path(char *path) {
  char *allowedPath;
  // Allocate a buffer to store the allowed path
  allowedPath = malloc(strlen(path) + 1);
  // Validate and sanitize the input path
  if (realpath(path, allowedPath)) {
    // Return the allowed path
    return allowedPath;
  }
  // Return NULL if the path is not valid
  return NULL;
}",939,-61.44637877561796,-0.06543810306242594
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) 
{ 
  if ( func != NULL && * func != '\\0' ) { 
    if ( ! strcmp ( func , ""page/get"" ) ) { 
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      char page_name[1024];
      realpath(page, page_name);
      if ( page && ( access ( page_name , R_OK ) == 0 ) ) { 
        http_response_printf ( res , ""%s"" , file_read ( page_name ) ) ; 
        http_response_send ( res ) ; 
        return ; 
      } 
    } 
    else if ( ! strcmp ( func , ""page/set"" ) ) { 
      char * wikitext = NULL , * page = NULL ; 
      if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
        char page_name[1024];
        realpath(page, page_name);
        file_write ( page_name , wikitext ) ; 
        http_response_printf ( res , ""success"" ) ; 
        http_response_send ( res ) ; 
        return ; 
      } 
    } 
    else if ( ! strcmp ( func , ""page/delete"" ) ) { 
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      char page_name[1024];
      realpath(page, page_name);
      if ( page && ( unlink ( page_name ) > 0 ) ) { 
        http_response_printf ( res , ""success"" ) ; 
        http_response_send ( res ) ; 
        return ; 
      } 
    } 
    else if ( ! strcmp ( func , ""page/exists"" ) ) { 
      char * page = http_request_param_get ( req , ""page"" ) ; 
      if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
      char page_name[1024];
      realpath(page, page_name);
      if ( page && ( access ( page_name , R_OK ) == 0 ) ) { 
        http_response_printf ( res , ""success"" ) ; 
        http_response_send ( res ) ; 
        return ; 
      } 
    } 
    else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
      WikiPageList * * pages = NULL ; 
      int n_pages , i ; 
      char * expr = http_request_param_get ( req , ""expr"" ) ; 
      if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
      pages = wiki_get_pages ( & n_pages , expr ) ; 
      if ( pages ) { 
        for ( i = 0 ; i < n_pages ; i ++ ) { 
          struct tm * pTm ; 
          char datebuf [ 64 ] ; 
          pTm = localtime ( & pages [ i ] -> mtime ) ; 
          strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
          http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
        } 
        http_response_send ( res ) ; 
        return ; 
      } 
    } 
  } 
  http_response_set_status ( res , 500 , ""Error"" ) ; 
  http_response_printf ( res , ""<html><body>Failed</body></html>\\n""",1000,-25.05058018595655,-0.02505058018595655
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char page_path[256]; char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //concatenate the page path with the base directory strcpy(page_path, ""pages/""); strcat(page_path, page); if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page_path ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { char page_path[256]; //concatenate the page path with the base directory strcpy(page_path, ""pages/""); strcat(page_path, page); file_write ( page_path , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char page_path[256]; char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //concatenate the page path with the base directory strcpy(page_path, ""pages/""); strcat(page_path, page); if ( page && ( unlink ( page_path ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char page_path[256]; char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //concatenate the page path with the base directory strcpy(page_path, ""pages/""); strcat(page_path, page); if ( page && ( access ( page_path , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; char page_path[256]; //concatenate the page path with the base directory strcpy(page_path, ""pages/""); strcat(page_path, pages[i]->name); pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , page_path , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }",960,-35.0958572449483,-0.03655818463015448
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Check if page exists in the allowed directory if ( page && ( access ( page , R_OK ) == 0 ) && is_valid_path(page) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { //Check if page exists in the allowed directory if( is_valid_path(page) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Check if page exists in the allowed directory if ( page && ( unlink ( page ) > 0 ) && is_valid_path(page) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; //Check if page exists in the allowed directory if ( page && ( access ( page , R_OK ) == 0 ) && is_valid_path(page) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }

//Function to check if the given path is valid
int is_valid_path(char* path){
  char allowed_path[1024] = ""/var/www/wiki/pages"";
  if (strncmp(path, allowed_path, strlen(allowed_path)) == 0) {
    return 1;
  }
  return 0;
}",907,-57.92910775837064,-0.06386891704340754
"The Original Code is vulnerable to CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'). Fix the vulnerability.
Original Code:
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
Fixed code:","
void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { 
if ( func != NULL && * func != '\\0' ) { 
if ( ! strcmp ( func , ""page/get"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page && ( access ( page , R_OK ) == 0 ) ) { 
char path[PATH_MAX];
char * fullpath = realpath(page, path);
if (fullpath && check_path_in_directory(fullpath, ""wiki/pages"") == 0) {
	http_response_printf ( res , ""%s"" , file_read ( page ) ) ; 
	http_response_send ( res ) ; 
	return ; 
}
} 
} else if ( ! strcmp ( func , ""page/set"" ) ) { 
char * wikitext = NULL , * page = NULL ; 
if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { 
char path[PATH_MAX];
char * fullpath = realpath(page, path);
if (fullpath && check_path_in_directory(fullpath, ""wiki/pages"") == 0) {
	file_write ( page , wikitext ) ; 
	http_response_printf ( res , ""success"" ) ; 
	http_response_send ( res ) ; 
	return ; 
}
} 
} else if ( ! strcmp ( func , ""page/delete"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page ) {
	char path[PATH_MAX];
	char * fullpath = realpath(page, path);
	if (fullpath && check_path_in_directory(fullpath, ""wiki/pages"") == 0 && ( unlink ( page ) > 0 ) ) { 
		http_response_printf ( res , ""success"" ) ; 
		http_response_send ( res ) ; 
		return ; 
	}
} 
} else if ( ! strcmp ( func , ""page/exists"" ) ) { 
char * page = http_request_param_get ( req , ""page"" ) ; 
if ( page == NULL ) page = http_request_get_query_string ( req ) ; 
if ( page ) {
	char path[PATH_MAX];
	char * fullpath = realpath(page, path);
	if (fullpath && check_path_in_directory(fullpath, ""wiki/pages"") == 0 && ( access ( page , R_OK ) == 0 ) ) { 
		http_response_printf ( res , ""success"" ) ; 
		http_response_send ( res ) ; 
		return ; 
	}
} 
} else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { 
WikiPageList * * pages = NULL ; 
int n_pages , i ; 
char * expr = http_request_param_get ( req , ""expr"" ) ; 
if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; 
pages = wiki_get_pages ( & n_pages , expr ) ; 
if ( pages ) { 
for ( i = 0 ; i < n_pages ; i ++ ) { 
struct tm * pTm ; 
char datebuf [ 64 ] ; 
pTm = localtime ( & pages [ i ] -> mtime ) ; 
strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d %H:%M"" , pTm ) ; 
http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; 
} 
http",1000,-57.062616043084276,-0.057062616043084276
