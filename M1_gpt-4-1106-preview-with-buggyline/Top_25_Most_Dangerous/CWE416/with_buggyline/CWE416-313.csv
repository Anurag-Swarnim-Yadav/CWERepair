Original code,Plausible Program,Number of Bugs Present,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,871,-5.527151185337958,-0.006345753370078023
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,887,-10.091650979304639,-0.011377284080388544
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; } <EndBug>",12,905,-12.13075995459392,-0.013404154645960132
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> running ) { <EndBug> <StartBug> mutex_lock ( & fanout_mutex ) ; <EndBug> match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> } else { <EndBug> <StartBug> err = - EINVAL ; <EndBug> <StartBug> } <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,787,-11.723619554323662,-0.014896594096980511
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,879,-4.934765062673364,-0.005614067193029993
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running )  return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,888,-11.516766609185662,-0.012969331767100972
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,879,-4.934765062673364,-0.005614067193029993
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } 
if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; }

mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( po->running && match->type == type && match->prot_hook.type == po->prot_hook.type && match->prot_hook.dev == po->prot_hook.dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,844,-19.950022852553108,-0.023637467834778565
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; goto out ; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,881,-6.048217599238214,-0.006865173211394114
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) <EndBug> <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,909,-8.200249136095515,-0.009021176167321798
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( po -> running ) <EndBug>{ <StartBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> } <StartBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; } <EndBug>",12,911,-19.1511001213824,-0.0210220637995416
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,879,-5.195067986280961,-0.005910202487236588
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,879,-4.934765062673364,-0.005614067193029993
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { if ( po -> running ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } else { err = - EINVAL ; } } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,868,-12.088354689887831,-0.013926675910009022
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; <EndBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } <StartBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,897,-13.728451615344962,-0.015304851299158264
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; kref_get ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kref_put ( & match -> sk_ref , fanout_release_sock ) ; } return err ; }",12,885,-15.225991381816838,-0.01720451003595123
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) { return - EINVAL ; } <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) <EndBug> <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,889,-14.436980280404082,-0.016239572868845985
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po || ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,872,-6.207983568995854,-0.0071192472121512085
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) { goto free_rollover ; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { free_rollover : kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,873,-11.795693144443069,-0.013511675995925624
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> running ) { if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; } return err ; }",12,863,-7.836410692497291,-0.009080429539394311
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:"," 
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( po -> running ) { <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) <EndBug> <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { kfree ( po -> fanout ) ; po -> fanout = NULL ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,962,-13.87297120940064,-0.014420967993139959
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( po -> running ) { <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> //if ( !po->running ) <EndBug> <StartBug> //return -EINVAL; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,960,-20.615858151890208,-0.0214748522415523
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; <StartBug> if ( ! match ) { <EndBug> err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; <StartBug> } <EndBug> err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; } <EndBug> return err ; }",12,917,-14.115838497609259,-0.015393498906880326
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running || po -> fanout ) { <EndBug> <StartBug> return - EINVAL ; <EndBug> } if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,950,-11.525522200583907,-0.012132128632193586
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( po -> running ) { mutex_lock ( & fanout_mutex ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } <StartBug> mutex_lock ( & fanout_mutex ) ; <EndBug> match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,886,-7.303615299999762,-0.008243358126410567
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) <EndBug> <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,935,-7.442252626114248,-0.007959628477127539
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:"," 
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,880,-8.031280343242727,-0.0091264549355031
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","

static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) <EndBug> <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) { <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> goto out ; } if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) { <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> goto out ; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,1000,-14.243798520311321,-0.01424379852031132
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> running ) { return - EINVAL ; } if ( po -> fanout ) { return - EALREADY ; } if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; } return err ; }",12,872,-9.728955738602332,-0.011157059333259556
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po || ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err && po ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,964,-7.4917967566324695,-0.007771573398996337
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; return - EINVAL ; } <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,919,-11.261924300859924,-0.012254542220739852
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug>  <EndBug> <StartBug>  <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,959,-10.89755814217363,-0.011363460002266559
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( po -> running ) { <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; } <StartBug> } <EndBug>",12,946,-13.019086992636264,-0.013762248406592245
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) { mutex_unlock ( & fanout_mutex ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; return - ENOMEM ; } write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,898,-6.708831288506137,-0.007470858895886567
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ;  if ( po -> running ) { <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug>  if ( po -> fanout ) <EndBug> <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,953,-14.837319787270442,-0.015569065883809487
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> } <StartBug> mutex_lock ( & fanout_mutex ) ; <EndBug> match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,919,-11.888379082206663,-0.012936212276612256
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po || ! po -> running ) <EndBug> return - EINVAL ;  <StartBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; }  mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,888,-17.266578024186835,-0.019444344621832022
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( po -> running ) <EndBug> { <StartBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,873,-12.80809257855903,-0.014671354614615155
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; } return err ; }",12,877,-7.490020830095621,-0.008540502656893524
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,895,-6.769303627611305,-0.007563467740347826
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } 
if ( ! po -> running ) 
return - EINVAL ; 
if ( po -> fanout ) 
return - EALREADY ; 
if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; 
if ( ! po -> rollover ) 
return - ENOMEM ; 
atomic_long_set ( & po -> rollover -> num , 0 ) ; 
atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; 
atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; 
} 
mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( match ) ; 
kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,895,-15.581269931392077,-0.01740924014680679
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,879,-5.677887398643956,-0.006459485095158085
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po ) { return - EINVAL ; } <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) return - EINVAL ; if ( po -> fanout ) return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> } <StartBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; kfree ( match ) ; } <EndBug> return err ; }",12,918,-17.508464392843585,-0.019072401299393884
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; return - EINVAL ; } if ( po -> fanout ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; return - EALREADY ; } if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( match ) ; kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,905,-9.884409398560935,-0.010921999335426447
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) <EndBug> <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,911,-10.505066089265403,-0.011531356848809444
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( ! po -> running )  return - EINVAL ; if ( po -> fanout ) return - EALREADY ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out_unlock ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out_unlock ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out_unlock: mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,873,-12.104722062585623,-0.013865661010980095
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) { 
    kfree ( po -> rollover ) ; 
    po -> rollover = NULL ; 
    return - EINVAL ; 
} <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }",12,980,-14.013787339427122,-0.014299782999415431
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return - EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) <EndBug> <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return - ENOMEM ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> } mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( po -> rollover ) ; po -> rollover = NULL ; } <EndBug> return err ; }",12,903,-8.724734808637272,-0.009661943309675828
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } if ( po -> running ) { mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : mutex_unlock ( & fanout_mutex ) ; if ( err ) { kfree ( match ) ; } return err ; }",12,702,-8.749162027898599,-0.012463193771935326
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( ! po -> running ) <EndBug> <StartBug> return - EINVAL ; <EndBug> if ( po -> fanout ) <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <EndBug> <StartBug> if ( ! po -> rollover ) <EndBug> return - ENOMEM ; <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> <StartBug> if ( err ) { <EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
Fixed code:","
static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <StartBug> struct packet_sock * po = pkt_sk ( sk ) ; if ( ! po -> running ) return -EINVAL ; <EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <StartBug> if ( po -> fanout ) <EndBug> <StartBug> return - EALREADY ; <EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; if ( ! po -> rollover ) return -ENOMEM ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <EndBug> <StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <EndBug> <StartBug> } <EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <StartBug> mutex_unlock ( & fanout_mutex ) ; <EndBug> return err ; }",12,913,-13.425305223097737,-0.014704605939866087
