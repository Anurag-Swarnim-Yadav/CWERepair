Original code,Plausible Program,Number of Bugs Present,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-4.427715699065301,-0.004467927042447327
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-4.932254037712638,-0.004977047464896708
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> port -> port . count = 0 ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,999,-12.089139491063106,-0.012101240731794902
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; usb_autopm_put_interface ( serial -> interface ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,983,-5.584806985409438,-0.005681390626052328
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","

static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) <StartBug> goto error_get_interface ; <EndBug> tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,1000,-11.808594730727636,-0.011808594730727637
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-4.932254037712638,-0.004977047464896708
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; usb_autopm_put_interface ( serial -> interface ) ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,968,-4.363541561388115,-0.004507790869202598
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } usb_autopm_put_interface ( serial -> interface ) ; -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,968,-5.272490109563847,-0.005446787303268437
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,976,-3.221250588721843,-0.0033004616687723797
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,976,-4.081568883637581,-0.004181935331595882
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) { usb_autopm_put_interface ( serial -> interface ) ; goto error_get_interface ; } tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,985,-4.410378151992525,-0.004477541271058401
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; <StartBug> // Add call to release interface if open fails usb_autopm_put_interface ( serial -> interface ) ; <EndBug> } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,988,-24.650673542038017,-0.024950074435261153
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup(struct console *co, char *options) {
 struct usbcons_info *info = &usbcons_info;
 int baud = 9600;
 int bits = 8;
 int parity = 'n';
 int doflow = 0;
 int cflag = CREAD | HUPCL | CLOCAL;
 char *s;
 struct usb_serial *serial;
 struct usb_serial_port *port;
 int retval;
 struct tty_struct *tty = NULL;
 struct ktermios dummy;
 
 if (options) {
  baud = simple_strtoul(options, NULL, 10);
  s = options;
  while (*s >= '0' && *s <= '9')
   s++;
  if (*s)
   parity = *s++;
  if (*s)
   bits = *s++ - '0';
  if (*s)
   doflow = (*s++ == 'r');
 }
 if (baud == 0)
  baud = 9600;
 switch (bits) {
 case 7:
  cflag |= CS7;
  break;
 default:
 case 8:
  cflag |= CS8;
  break;
 }
 switch (parity) {
 case 'o':
 case 'O':
  cflag |= PARODD;
  break;
 case 'e':
 case 'E':
  cflag |= PARENB;
  break;
 }
 co->cflag = cflag;
 port = usb_serial_port_get_by_minor(co->index);
 if (port == NULL) {
  pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
  return -ENODEV;
 }
 serial = port->serial;
 retval = usb_autopm_get_interface(serial->interface);
 if (retval)
  goto error_get_interface;
 tty_port_tty_set(&port->port, NULL);
 info->port = port;
++port->port.count;
 if (!tty_port_initialized(&port->port)) {
  if (serial->type->set_termios) {
   tty = kzalloc(sizeof(*tty), GFP_KERNEL);
   if (!tty) {
    retval = -ENOMEM;
    goto reset_open_count;
   }
   kref_init(&tty->kref);
   tty->driver = usb_serial_tty_driver;
   tty->index = co->index;
   init_ldsem(&tty->ldisc_sem);
   spin_lock_init(&tty->files_lock);
   INIT_LIST_HEAD(&tty->tty_files);
   kref_get(&tty->driver->kref);
   __module_get(tty->driver->owner);
   tty->ops = &usb_console_fake_tty_ops;
   tty_init_termios(tty);
   tty_port_tty_set(&port->port, tty);
  }
  retval = serial->type->open(NULL, port);
  if (retval) {
   dev_err(&port->dev, ""could not open USB console port\n"");
   goto fail;
  }
  if (serial->type->set_termios) {
   tty->termios.c_cflag = cflag;
   tty_termios_encode_baud_rate(&tty->termios, baud, baud);
   memset(&dummy, 0, sizeof(struct ktermios));
   serial->type->set_termios(tty, port, &dummy);
   tty_port_tty_set(&port->port, NULL);
   tty_kref_put(tty);
  }
  tty_port_set_initialized(&port->port, 1);
 }
--port->port.count;
port->port.console = 1;
mutex_unlock(&serial->disc_mutex);
<StartBug> usb_autopm_put_interface(serial->interface); 
if (tty) {
 kref_put(&tty->kref, tty_free);
}
<EndBug>
error_get",1,1000,-27.96969357495377,-0.02796969357495377
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> tty_kref_put ( tty ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; usb_autopm_put_interface ( serial -> interface ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> tty_kref_put ( tty ) ; <EndBug> reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,999,-7.204838260635405,-0.007212050310946351
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; <StartBug> tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,999,-8.705620490847794,-0.008714334825673468
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","

static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; usb_autopm_put_interface ( serial -> interface ) ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,969,-6.852778534480819,-0.007072010871497234
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; tty_kref_put ( tty ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,987,-8.136436163671563,-0.00824360300270675
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; usb_autopm_put_interface ( serial -> interface ) ; goto fail ; } 
if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,970,-12.05638834568775,-0.012429266335760568
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto error_put_interface ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; error_put_interface : usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,960,-7.557409473949096,-0.007872301535363642
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,979,-5.275142217410041,-0.005388296442706886
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:"," 
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) { usb_autopm_put_interface ( serial -> interface ) ; goto error_get_interface ; } tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,986,-6.497328631873941,-0.006589582790947202
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; } tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-6.735612669160981,-0.006796783722664965
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-5.076705389922407,-0.0051228106860972825
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; } // <StartBug> tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; // <EndBug> tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; usb_autopm_put_interface ( serial -> interface ) ; // <StartBug> error_get_interface : <EndBug> usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,982,-23.905236823727186,-0.024343418354101004
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-4.638440488005098,-0.004680565578208978
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto error_get_interface ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; error_get_interface : usb_autopm_put_interface ( serial -> interface ) ; usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,954,-6.007595080837241,-0.006297269476768596
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","

static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ;<StartBug> usb_autopm_put_interface ( serial -> interface ) ;<EndBug> goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,977,-11.457861663425712,-0.011727596380169613
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> tty_kref_put ( tty ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,976,-7.839743531576305,-0.008032524110221624
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) { usb_autopm_put_interface ( serial -> interface ) ; goto error_get_interface ; } tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : usb_autopm_put_interface ( serial -> interface ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,985,-7.414998058534753,-0.00752791681069518
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,979,-5.275142217410041,-0.005388296442706886
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,976,-6.007952581354532,-0.006155689120240299
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; goto reset_open_count ; <EndBug> } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-5.885030077969575,-0.005938476365256887
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-4.638440488005098,-0.004680565578208978
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; <StartBug> if (serial->interface) { usb_autopm_put_interface(serial->interface); } <EndBug> mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,986,-12.87868628825984,-0.013061547959695578
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; tty_kref_put ( tty ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,964,-6.746693111348382,-0.006998644306377989
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:"," 
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; <StartBug> tty_kref_put(tty); <EndBug> tty_port_tty_set ( & port -> port , NULL ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> tty_kref_put ( tty ) ; usb_autopm_put_interface ( serial -> interface ) ; <EndBug> reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,983,-13.284379475447336,-0.013514119507067483
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> port -> port . count = 0 ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> return retval ; }",1,1000,-12.202402112907254,-0.012202402112907254
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-4.9730479145301905,-0.005018211820918456
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; } port -> port . console = 1 ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,966,-12.944771906165137,-0.013400384996030162
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ;  <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug>  } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ;",1,1000,-16.059566716307593,-0.016059566716307594
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,976,-5.30144712670563,-0.005431810580641014
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> port -> port . count = 0 ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,976,-9.216749206145995,-0.009443390580067617
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:"," 
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; <StartBug> goto reset_open_count ; <EndBug> } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,1000,-8.637530278545086,-0.008637530278545085
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; } <StartBug> if ( serial -> interface ) { usb_autopm_put_interface ( serial -> interface ) ; serial -> interface = NULL ; } <EndBug> tty_kref_put ( tty ) ; port -> port . count = 0 ; tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : <StartBug> if ( serial -> interface ) { usb_autopm_put_interface ( serial -> interface ) ; serial -> interface = NULL ; } <EndBug> port -> port . count = 0 ;",1,1000,-16.07811820712023,-0.01607811820712023
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; <StartBug> tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; <EndBug> if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } <StartBug> ++ port -> port . count ; <EndBug> port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : <StartBug> port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,985,-15.818886127152224,-0.016059782870205302
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; <StartBug> tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,964,-9.524177787860378,-0.009879852477033588
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-5.076705389922407,-0.0051228106860972825
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,991,-3.739757984213786,-0.0037737214775113883
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { 
 struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; 

if ( options ) { 
 baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; 
 } 

if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } 

serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; 

if ( ! tty_port_initialized ( & port -> port ) ) { 
 if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto error_put_interface ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; 
} 

-- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; 

error_put_interface:
    usb_autopm_put_interface ( serial -> interface ) ;
fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; 
reset_open_count : port -> port . count = 0 ; 

error_get_interface : usb_serial_put ( serial ) ; mutex_unlock (",1,1000,-50.09615349313038,-0.05009615349313038
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; <EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
Fixed code:","
static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No USB device connected to ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could not open USB console port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; <StartBug> usb_autopm_put_interface ( serial -> interface ) ; tty_kref_put ( tty ) ; <EndBug> } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; reset_open_count : port -> port . count = 0 ; usb_autopm_put_interface ( serial -> interface ) ; error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",1,979,-6.185650932768251,-0.006318335988527325
