Original code,Plausible Program,Number of Bugs Present,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq && refcount_inc_not_zero(&bfqq->ref)) { <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec(&bfqq->ref); <EndBug> return HRTIMER_NORESTART ; }  return HRTIMER_NORESTART; }",1,160,-12.572266481827791,-0.0785766655114237
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> if (atomic_read(&bfqq->ref) > 0) { bfq_idle_slice_timer_body ( bfqq ) ; } <EndBug> return HRTIMER_NORESTART ; }",1,139,-6.763181501624793,-0.04865598202607765
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd -> in_service_queue ) { bfqq = bfqd -> in_service_queue ; <StartBug> if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> } return HRTIMER_NORESTART ; }",1,142,-6.3203056656898315,-0.04450919482880163
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq && atomic_read(&bfqq->ref) > 0 ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,135,-4.61305585177322,-0.034170784087209034
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> if (refcount_inc_not_zero(&bfqq->ref)) { bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec(&bfqq->ref); } <EndBug> return HRTIMER_NORESTART ; }",1,151,-4.93117725843873,-0.032656803036018076
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq , * bfqq_temp ; <StartBug> bfqq_temp = bfqd -> in_service_queue ; if ( bfqq_temp ) { bfqq = bfqq_temp ; bfq_idle_slice_timer_body ( bfqq ) ; } <EndBug> return HRTIMER_NORESTART ; }",1,150,-10.822158947762995,-0.07214772631841997
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { 
<StartBug> if (!refcount_inc_not_zero(&bfqq->ref)) return HRTIMER_NORESTART; <EndBug> 
bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec(&bfqq->ref); } return HRTIMER_NORESTART ; }",1,164,-16.355123876172875,-0.0997263650986151
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> if (bfqq->ref) bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,130,-5.748031721918732,-0.04421562863014409
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd ) { bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_get_queue ( bfqd , bfqq -> pid ) ; bfq_idle_slice_timer_body ( bfqq ) ; bfq_put_queue ( bfqq ) ; <EndBug> } return HRTIMER_NORESTART ; }",1,169,-9.625072418677892,-0.05695309123478042
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> kref_get(&bfqq->ref); <EndBug> bfq_idle_slice_timer_body ( bfqq ) ; kref_put(&bfqq->ref); } return HRTIMER_NORESTART ; }",1,145,-5.703335195784891,-0.039333346177826835
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> struct bfq_queue *bfqq_tmp = bfqq; 
							  bfqq = NULL; 
							  bfq_idle_slice_timer_body ( bfqq_tmp ) ; 
							  kfree ( bfqq_tmp ) ; 
							  <EndBug> return HRTIMER_NORESTART ; }
}",1,200,-32.0878803841834,-0.160439401920917
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd ) bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,134,-8.38752091903039,-0.06259343969425664
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ;  <StartBug> bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ;  <EndBug> return HRTIMER_NORESTART ; }",1,129,-10.785540125694688,-0.08360883818367974
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> kref_get(&bfqq->ref); <EndBug> bfq_idle_slice_timer_body ( bfqq ) ; kref_put(&bfqq->ref); } return HRTIMER_NORESTART ; }",1,145,-5.703335195784891,-0.039333346177826835
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> kref_get(&bfqq->ref); <EndBug> bfq_idle_slice_timer_body ( bfqq ) ; kref_put(&bfqq->ref); } return HRTIMER_NORESTART ; }",1,145,-5.7156386443468925,-0.039418197547219945
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; <StartBug> bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,127,-4.760715167828094,-0.03748594620337082
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> if (!bfq_bfqq_busy(bfqq)) bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> } return HRTIMER_NORESTART ; }",1,139,-7.335764442815052,-0.05277528376125937
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { struct bfq_queue * bfqq_ref = bfqq ; <StartBug> if(bfqq_ref) { bfq_idle_slice_timer_body ( bfqq_ref ) ; } <EndBug> return HRTIMER_NORESTART ; } }",1,153,-13.025890748213799,-0.08513654083799868
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd -> in_service_queue ) { bfqq = bfqd -> in_service_queue ; <StartBug> if ( bfqq ) { bfq_idle_slice_timer_body ( bfqq ) ; } <EndBug> } return HRTIMER_NORESTART ; }",1,144,-6.4897062321578,-0.04506740438998472
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> if (!atomic_read(&bfqq->ref)) return HRTIMER_NORESTART;  <EndBug> bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",1,147,-11.585399387471329,-0.07881224073109748
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { /* * Check if bfqq has not been freed in the meantime; * otherwise a use-after-free condition might occur. */ if (refcount_read(&bfqq->ref) > 0) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> } return HRTIMER_NORESTART ; }",1,168,-31.225947048340544,-0.18586873243059848
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd ) { bfqq = bfqd -> in_service_queue ; <StartBug> if ( bfqq ) { bfq_idle_slice_timer_body ( bfqq ) ; } <EndBug> return HRTIMER_NORESTART ; } }",1,138,-5.7325077148431,-0.041539910977123916
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> if ( ! bfq_bfqq_busy ( bfqq ) ) bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }  }",1,144,-15.257331102111898,-0.1059536882091104
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd -> in_service_queue ) { <StartBug> bfqq = bfqd -> in_service_queue ; bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> } return HRTIMER_NORESTART ; }",1,136,-5.8843863806988,-0.04326754691690294
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd ) { bfqq = bfqd -> in_service_queue ; <StartBug> if ( bfqq ) { bfq_idle_slice_timer_body ( bfqq ) ; } <EndBug> } return HRTIMER_NORESTART ; }",1,138,-5.1109505094247005,-0.03703587325670073
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd ) <StartBug> bfqq = bfqd -> in_service_queue ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,134,-5.329252813042497,-0.03977054338091415
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd ) { bfqq = bfqd -> in_service_queue ; <StartBug> if ( bfqq ) { bfq_idle_slice_timer_body ( bfqq ) ; } <EndBug> return HRTIMER_NORESTART ; } }",1,138,-5.7516474880817,-0.04167860498609927
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { 
	if (!atomic_read(&bfqq->ref))
		return HRTIMER_NORESTART; 
<StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> 
	return HRTIMER_NORESTART ; 
}",1,158,-20.303984027616732,-0.12850622802289072
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> if(bfqq != NULL) { bfq_idle_slice_timer_body ( bfqq ) ; } <EndBug> } return HRTIMER_NORESTART ; }",1,134,-8.610847139258643,-0.06426005327804958
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> if (!refcount_inc_not_zero(&bfqq->ref)) 	return HRTIMER_NORESTART; <EndBug> bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec(&bfqq->ref); } return HRTIMER_NORESTART ; }",1,163,-14.428619311643157,-0.08851913688124637
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:"," 
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { if (!( kref_get_unless_zero ( &bfqq->ref ))) { <StartBug> return HRTIMER_NORESTART; <EndBug> } bfq_idle_slice_timer_body ( bfqq ) ; } return HRTIMER_NORESTART ; }",1,156,-27.77761263060141,-0.17806161942693213
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd -> in_service_queue ) <StartBug> bfqq = bfqd -> in_service_queue ; bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,134,-5.4814430263898055,-0.040906291241714965
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> if (refcount_read(&bfqq->ref) > 0) { bfq_idle_slice_timer_body ( bfqq ) ; } <EndBug> return HRTIMER_NORESTART ; } }",1,142,-7.980214258840492,-0.05619869196366544
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> kref_get(&bfqq->ref) ; <EndBug> bfq_idle_slice_timer_body ( bfqq ) ; kref_put(&bfqq->ref, bfq_put_queue); } return HRTIMER_NORESTART ; }",1,154,-10.706690103890187,-0.06952396171357264
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_get_queue ( bfqd , bfqq ) ; bfq_idle_slice_timer_body ( bfqq ) ; bfq_put_queue ( bfqd , bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,159,-9.04883288557543,-0.0569108986514178
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { kref_get (&bfqq->ref); <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> kref_put (&bfqq->ref); } return HRTIMER_NORESTART ; }",1,145,-8.764120443740193,-0.06044220995682892
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = NULL ; if ( bfqd ) bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,136,-9.69610953300219,-0.07129492303678081
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; 
if ( bfqd ) { bfqq = bfqd->in_service_queue; 
if ( bfqq ) <StartBug> bfq_get_ref(bfqq); bfq_idle_slice_timer_body ( bfqq ) ; bfq_put_ref(bfqq); <EndBug> 
}
return HRTIMER_NORESTART ; }",1,165,-18.826154723208152,-0.11409790741338274
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq &&atomic_read(&bfqq->ref) ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,133,-13.145467725308823,-0.0988381031978107
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd ) { bfqq = bfqd-> in_service_queue ; if ( bfqq ) <StartBug> bfq_get_queue ( bfqd, bfqq->pid ) ; bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> } return HRTIMER_NORESTART ; }",1,156,-17.80486168094375,-0.11413372872399839
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { 
    <StartBug> 
    if (refcount_read(&bfqq->ref) > 0)
       bfq_idle_slice_timer_body ( bfqq ) ; 
    <EndBug> 
} 
return HRTIMER_NORESTART ; 
}",1,157,-20.29252389462389,-0.1292517445517445
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> if (refcount_inc_not_zero(&bfqq->ref)) { bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec(&bfqq->ref); } <EndBug> return HRTIMER_NORESTART ; }",1,151,-4.879026982862952,-0.03231143697260233
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; if ( bfqd == NULL ) return HRTIMER_NORESTART ; bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfqq = kmemdup ( bfqq , sizeof ( struct bfq_queue ) , GFP_ATOMIC ) ; if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; kfree ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,191,-16.363686232255574,-0.08567374990709725
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> if (refcount_inc_not_zero(&bfqq->ref)) { bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec(&bfqq->ref); } <EndBug> return HRTIMER_NORESTART ; }",1,151,-4.879026982862952,-0.03231143697260233
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; <StartBug> if ( bfqd -> in_service_queue ) { bfqq = bfqd -> in_service_queue ; bfq_idle_slice_timer_body ( bfqq ) ; } <EndBug> return HRTIMER_NORESTART ; }",1,136,-4.796680654802094,-0.03526971069707422
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq && atomic_read(&bfqq->ref) > 0 ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,135,-4.652768517065682,-0.03446495197826431
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug>  if ( refcount_inc_not_zero( &bfqq->ref ) ) { bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec( &bfqq->ref ) ; } <EndBug> return HRTIMER_NORESTART ; }",1,156,-15.298793985090484,-0.09806919221211849
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:"," 
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { kref_get ( & bfqq -> ref ) ; bfq_idle_slice_timer_body ( bfqq ) ; kref_put ( & bfqq -> ref , bfq_put_queue ) ; } return HRTIMER_NORESTART ; }",1,152,-11.723309018535314,-0.0771270330166797
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq ; // add this line <StartBug> bfqq = bfqd -> in_service_queue ; // add this line if ( bfqq ) bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }",1,135,-12.766354504521695,-0.09456558892238293
"The Original Code is vulnerable to CWE-416: Use After Free. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code:
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <EndBug> return HRTIMER_NORESTART ; }
Fixed code:","
static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) { <StartBug> if (refcount_inc_not_zero(&bfqq->ref)) { bfq_idle_slice_timer_body ( bfqq ) ; refcount_dec(&bfqq->ref); } <EndBug> } return HRTIMER_NORESTART ; }",1,153,-5.217810630336449,-0.0341033374531794
