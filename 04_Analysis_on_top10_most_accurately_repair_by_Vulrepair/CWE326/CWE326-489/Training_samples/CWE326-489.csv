cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
CWE-326,"CWE-326 void Init_ossl_cipher ( void ) { # if 0 mOSSL = rb_define_module ( ""OpenSSL"" ) ; eOSSLError = rb_define_class_under ( mOSSL , ""OpenSSLError"" , rb_eStandardError ) ; # endif cCipher = rb_define_class_under ( mOSSL , ""Cipher"" , rb_cObject ) ; eCipherError = rb_define_class_under ( cCipher , ""CipherError"" , eOSSLError ) ; rb_define_alloc_func ( cCipher , ossl_cipher_alloc ) ; rb_define_copy_func ( cCipher , ossl_cipher_copy ) ; rb_define_module_function ( cCipher , ""ciphers"" , ossl_s_ciphers , 0 ) ; rb_define_method ( cCipher , ""initialize"" , ossl_cipher_initialize , 1 ) ; rb_define_method ( cCipher , ""reset"" , ossl_cipher_reset , 0 ) ; rb_define_method ( cCipher , ""encrypt"" , ossl_cipher_encrypt , - 1 ) ; rb_define_method ( cCipher , ""decrypt"" , ossl_cipher_decrypt , - 1 ) ; rb_define_method ( cCipher , ""pkcs5_keyivgen"" , ossl_cipher_pkcs5_keyivgen , - 1 ) ; rb_define_method ( cCipher , ""update"" , ossl_cipher_update , - 1 ) ; rb_define_method ( cCipher , ""final"" , ossl_cipher_final , 0 ) ; rb_define_method ( cCipher , ""name"" , ossl_cipher_name , 0 ) ; rb_define_method ( cCipher , ""key="" , ossl_cipher_set_key , 1 ) ; rb_define_method ( cCipher , ""auth_data="" , ossl_cipher_set_auth_data , 1 ) ; rb_define_method ( cCipher , ""auth_tag="" , ossl_cipher_set_auth_tag , 1 ) ; rb_define_method ( cCipher , ""auth_tag"" , ossl_cipher_get_auth_tag , - 1 ) ; rb_define_method ( cCipher , ""auth_tag_len="" , ossl_cipher_set_auth_tag_len , 1 ) ; rb_define_method ( cCipher , ""authenticated?"" , ossl_cipher_is_authenticated , 0 ) ; rb_define_method ( cCipher , ""key_len="" , ossl_cipher_set_key_length , 1 ) ; rb_define_method ( cCipher , ""key_len"" , ossl_cipher_key_length , 0 ) ; rb_define_method ( cCipher , ""iv="" , ossl_cipher_set_iv , 1 ) ; rb_define_method ( cCipher , ""iv_len="" , ossl_cipher_set_iv_length , 1 ) ; rb_define_method ( cCipher , ""iv_len"" , ossl_cipher_iv_length , 0 ) ; rb_define_method ( cCipher , ""block_size"" , ossl_cipher_block_size , 0 ) ; rb_define_method ( cCipher , ""padding="" , ossl_cipher_set_padding , 1 ) ; id_auth_tag_len = rb_intern_const ( ""auth_tag_len"" ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ""auth_tag_len"" ) ; id_key_set = rb_intern_const ( ""key_set"" ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-326,"CWE-326 static VALUE ossl_cipher_initialize ( VALUE self , VALUE str ) { EVP_CIPHER_CTX * ctx ; const EVP_CIPHER * cipher ; <S2SV_StartBug> char * name ; <S2SV_EndBug> unsigned char dummy_key [ EVP_MAX_KEY_LENGTH ] = { 0 } ; name = StringValueCStr ( str ) ; GetCipherInit ( self , ctx ) ; if ( ctx ) { ossl_raise ( rb_eRuntimeError , ""Cipher<S2SV_blank>already<S2SV_blank>inititalized!"" ) ; } AllocCipher ( self , ctx ) ; if ( ! ( cipher = EVP_get_cipherbyname ( name ) ) ) { ossl_raise ( rb_eRuntimeError , ""unsupported<S2SV_blank>cipher<S2SV_blank>algorithm<S2SV_blank>(%"" PRIsVALUE "")"" , str ) ; } <S2SV_StartBug> if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) <S2SV_EndBug> ossl_raise ( eCipherError , NULL ) ; return self ; }
","<S2SV_ModStart> char * name <S2SV_ModEnd> ; name = <S2SV_ModStart> , NULL , NULL <S2SV_ModEnd> , NULL ,
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-326,"CWE-326 static VALUE ossl_cipher_set_key ( VALUE self , VALUE key ) { EVP_CIPHER_CTX * ctx ; int key_len ; StringValue ( key ) ; GetCipher ( self , ctx ) ; key_len = EVP_CIPHER_CTX_key_length ( ctx ) ; if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , ""key<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes"" , key_len ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; <S2SV_StartBug> return key ; <S2SV_EndBug> }
","<S2SV_ModStart> NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-326,"CWE-326 static VALUE ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; unsigned char * in ; long in_len , out_len ; VALUE data , str ; rb_scan_args ( argc , argv , ""11"" , & data , & str ) ; <S2SV_StartBug> StringValue ( data ) ; <S2SV_EndBug> in = ( unsigned char * ) RSTRING_PTR ( data ) ; if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) ossl_raise ( rb_eArgError , ""data<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty"" ) ; GetCipher ( self , ctx ) ; out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ; if ( out_len <= 0 ) { ossl_raise ( rb_eRangeError , ""data<S2SV_blank>too<S2SV_blank>big<S2SV_blank>to<S2SV_blank>make<S2SV_blank>output<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>bytes"" , in_len ) ; } if ( NIL_P ( str ) ) { str = rb_str_new ( 0 , out_len ) ; } else { StringValue ( str ) ; rb_str_resize ( str , out_len ) ; } if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) ossl_raise ( eCipherError , NULL ) ; assert ( out_len < RSTRING_LEN ( str ) ) ; rb_str_set_len ( str , out_len ) ; return str ; }
","<S2SV_ModStart> str ) ; if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-326,"CWE-326 static VALUE ossl_cipher_pkcs5_keyivgen ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; const EVP_MD * digest ; VALUE vpass , vsalt , viter , vdigest ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , iv [ EVP_MAX_IV_LENGTH ] , * salt = NULL ; int iter ; rb_scan_args ( argc , argv , ""13"" , & vpass , & vsalt , & viter , & vdigest ) ; StringValue ( vpass ) ; if ( ! NIL_P ( vsalt ) ) { StringValue ( vsalt ) ; if ( RSTRING_LEN ( vsalt ) != PKCS5_SALT_LEN ) ossl_raise ( eCipherError , ""salt<S2SV_blank>must<S2SV_blank>be<S2SV_blank>an<S2SV_blank>8-octet<S2SV_blank>string"" ) ; salt = ( unsigned char * ) RSTRING_PTR ( vsalt ) ; } iter = NIL_P ( viter ) ? 2048 : NUM2INT ( viter ) ; digest = NIL_P ( vdigest ) ? EVP_md5 ( ) : GetDigestPtr ( vdigest ) ; GetCipher ( self , ctx ) ; EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , digest , salt , ( unsigned char * ) RSTRING_PTR ( vpass ) , RSTRING_LENINT ( vpass ) , iter , key , iv ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , key , iv , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; OPENSSL_cleanse ( key , sizeof key ) ; OPENSSL_cleanse ( iv , sizeof iv ) ; <S2SV_StartBug> return Qnil ; <S2SV_EndBug> }
","<S2SV_ModStart> iv ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-310,"CWE-310 static VALUE ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; unsigned char * in ; long in_len , out_len ; VALUE data , str ; rb_scan_args ( argc , argv , ""11"" , & data , & str ) ; <S2SV_StartBug> StringValue ( data ) ; <S2SV_EndBug> in = ( unsigned char * ) RSTRING_PTR ( data ) ; if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) ossl_raise ( rb_eArgError , ""data<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty"" ) ; GetCipher ( self , ctx ) ; out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ; if ( out_len <= 0 ) { ossl_raise ( rb_eRangeError , ""data<S2SV_blank>too<S2SV_blank>big<S2SV_blank>to<S2SV_blank>make<S2SV_blank>output<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>bytes"" , in_len ) ; } if ( NIL_P ( str ) ) { str = rb_str_new ( 0 , out_len ) ; } else { StringValue ( str ) ; rb_str_resize ( str , out_len ) ; } if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) ossl_raise ( eCipherError , NULL ) ; assert ( out_len < RSTRING_LEN ( str ) ) ; rb_str_set_len ( str , out_len ) ; return str ; }
","<S2SV_ModStart> str ) ; if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-326,"CWE-326 static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) { EVP_CIPHER_CTX * ctx ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , * p_key = NULL ; unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ; VALUE pass , init_v ; if ( rb_scan_args ( argc , argv , ""02"" , & pass , & init_v ) > 0 ) { VALUE cname = rb_class_path ( rb_obj_class ( self ) ) ; rb_warn ( ""arguments<S2SV_blank>for<S2SV_blank>%"" PRIsVALUE ""#encrypt<S2SV_blank>and<S2SV_blank>%"" PRIsVALUE ""#decrypt<S2SV_blank>were<S2SV_blank>deprecated;<S2SV_blank>"" ""use<S2SV_blank>%"" PRIsVALUE ""#pkcs5_keyivgen<S2SV_blank>to<S2SV_blank>derive<S2SV_blank>key<S2SV_blank>and<S2SV_blank>IV"" , cname , cname , cname ) ; StringValue ( pass ) ; GetCipher ( self , ctx ) ; if ( NIL_P ( init_v ) ) memcpy ( iv , ""OpenSSL<S2SV_blank>for<S2SV_blank>Ruby<S2SV_blank>rulez!"" , sizeof ( iv ) ) ; else { StringValue ( init_v ) ; if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) { memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ; memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ; } else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ; } EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ; p_key = key ; p_iv = iv ; } else { GetCipher ( self , ctx ) ; } if ( EVP_CipherInit_ex ( ctx , NULL , NULL , p_key , p_iv , mode ) != 1 ) { ossl_raise ( eCipherError , NULL ) ; } <S2SV_StartBug> return self ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; } if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-310,"CWE-310 static VALUE ossl_cipher_set_key ( VALUE self , VALUE key ) { EVP_CIPHER_CTX * ctx ; int key_len ; StringValue ( key ) ; GetCipher ( self , ctx ) ; key_len = EVP_CIPHER_CTX_key_length ( ctx ) ; if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , ""key<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes"" , key_len ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; <S2SV_StartBug> return key ; <S2SV_EndBug> }
","<S2SV_ModStart> NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-310,"CWE-310 static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) { EVP_CIPHER_CTX * ctx ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , * p_key = NULL ; unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ; VALUE pass , init_v ; if ( rb_scan_args ( argc , argv , ""02"" , & pass , & init_v ) > 0 ) { VALUE cname = rb_class_path ( rb_obj_class ( self ) ) ; rb_warn ( ""arguments<S2SV_blank>for<S2SV_blank>%"" PRIsVALUE ""#encrypt<S2SV_blank>and<S2SV_blank>%"" PRIsVALUE ""#decrypt<S2SV_blank>were<S2SV_blank>deprecated;<S2SV_blank>"" ""use<S2SV_blank>%"" PRIsVALUE ""#pkcs5_keyivgen<S2SV_blank>to<S2SV_blank>derive<S2SV_blank>key<S2SV_blank>and<S2SV_blank>IV"" , cname , cname , cname ) ; StringValue ( pass ) ; GetCipher ( self , ctx ) ; if ( NIL_P ( init_v ) ) memcpy ( iv , ""OpenSSL<S2SV_blank>for<S2SV_blank>Ruby<S2SV_blank>rulez!"" , sizeof ( iv ) ) ; else { StringValue ( init_v ) ; if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) { memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ; memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ; } else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ; } EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ; p_key = key ; p_iv = iv ; } else { GetCipher ( self , ctx ) ; } if ( EVP_CipherInit_ex ( ctx , NULL , NULL , p_key , p_iv , mode ) != 1 ) { ossl_raise ( eCipherError , NULL ) ; } <S2SV_StartBug> return self ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; } if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-310,"CWE-310 static VALUE ossl_cipher_pkcs5_keyivgen ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; const EVP_MD * digest ; VALUE vpass , vsalt , viter , vdigest ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , iv [ EVP_MAX_IV_LENGTH ] , * salt = NULL ; int iter ; rb_scan_args ( argc , argv , ""13"" , & vpass , & vsalt , & viter , & vdigest ) ; StringValue ( vpass ) ; if ( ! NIL_P ( vsalt ) ) { StringValue ( vsalt ) ; if ( RSTRING_LEN ( vsalt ) != PKCS5_SALT_LEN ) ossl_raise ( eCipherError , ""salt<S2SV_blank>must<S2SV_blank>be<S2SV_blank>an<S2SV_blank>8-octet<S2SV_blank>string"" ) ; salt = ( unsigned char * ) RSTRING_PTR ( vsalt ) ; } iter = NIL_P ( viter ) ? 2048 : NUM2INT ( viter ) ; digest = NIL_P ( vdigest ) ? EVP_md5 ( ) : GetDigestPtr ( vdigest ) ; GetCipher ( self , ctx ) ; EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , digest , salt , ( unsigned char * ) RSTRING_PTR ( vpass ) , RSTRING_LENINT ( vpass ) , iter , key , iv ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , key , iv , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; OPENSSL_cleanse ( key , sizeof key ) ; OPENSSL_cleanse ( iv , sizeof iv ) ; <S2SV_StartBug> return Qnil ; <S2SV_EndBug> }
","<S2SV_ModStart> iv ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-310,"CWE-310 static VALUE ossl_cipher_initialize ( VALUE self , VALUE str ) { EVP_CIPHER_CTX * ctx ; const EVP_CIPHER * cipher ; <S2SV_StartBug> char * name ; <S2SV_EndBug> unsigned char dummy_key [ EVP_MAX_KEY_LENGTH ] = { 0 } ; name = StringValueCStr ( str ) ; GetCipherInit ( self , ctx ) ; if ( ctx ) { ossl_raise ( rb_eRuntimeError , ""Cipher<S2SV_blank>already<S2SV_blank>inititalized!"" ) ; } AllocCipher ( self , ctx ) ; if ( ! ( cipher = EVP_get_cipherbyname ( name ) ) ) { ossl_raise ( rb_eRuntimeError , ""unsupported<S2SV_blank>cipher<S2SV_blank>algorithm<S2SV_blank>(%"" PRIsVALUE "")"" , str ) ; } <S2SV_StartBug> if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) <S2SV_EndBug> ossl_raise ( eCipherError , NULL ) ; return self ; }
","<S2SV_ModStart> char * name <S2SV_ModEnd> ; name = <S2SV_ModStart> , NULL , NULL <S2SV_ModEnd> , NULL ,
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
