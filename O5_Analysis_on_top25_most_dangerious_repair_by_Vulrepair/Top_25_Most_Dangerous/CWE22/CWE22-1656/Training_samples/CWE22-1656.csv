cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
CWE-22,"CWE-22 static int cleanup_pathname ( struct archive_write_disk * a ) { char * dest , * src ; char separator = '\\0' ; dest = src = a -> name ; if ( * src == '\\0' ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ; return ( ARCHIVE_FAILED ) ; } # if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ; # endif if ( * src == '/' ) <S2SV_StartBug> separator = * src ++ ; <S2SV_EndBug> for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\'..\'"" ) ; return ( ARCHIVE_FAILED ) ; } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }
","<S2SV_ModStart> == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ;
",libarchive@libarchive/59357157706d47c365b2227739e17daba3607526,CVE-2015-2304,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,2015-03-15T19:59Z
CWE-22,"CWE-22 DEFINE_TEST ( test_write_disk_secure ) { # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) skipping ( ""archive_write_disk<S2SV_blank>security<S2SV_blank>checks<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>Windows"" ) ; # else struct archive * a ; struct archive_entry * ae ; struct stat st ; assertUmask ( UMASK ) ; assert ( ( a = archive_write_disk_new ( ) ) != NULL ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""dir"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir/filea"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir/fileb"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_SYMLINKS ) ; failure ( ""Extracting<S2SV_blank>a<S2SV_blank>file<S2SV_blank>through<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir2"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir2/filec"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_SYMLINKS | ARCHIVE_EXTRACT_UNLINK ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir3"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir3"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertEqualInt ( 0 , lstat ( ""link_to_dir3"" , & st ) ) ; assert ( S_ISLNK ( st . st_mode ) ) ; archive_entry_free ( ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir4"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""nonexistent_dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir4"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertEqualInt ( 0 , lstat ( ""link_to_dir4"" , & st ) ) ; assert ( S_ISDIR ( st . st_mode ) ) ; archive_entry_free ( ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""non_dir"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; archive_entry_copy_pathname ( ae , ""link_to_dir5"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""non_dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir5"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertEqualInt ( 0 , lstat ( ""link_to_dir5"" , & st ) ) ; assert ( S_ISDIR ( st . st_mode ) ) ; archive_entry_free ( ae ) ; <S2SV_StartBug> assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ; <S2SV_EndBug> assert ( 0 == lstat ( ""dir"" , & st ) ) ; failure ( ""dir:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 0777 ) == 0755 ) ; assert ( 0 == lstat ( ""link_to_dir"" , & st ) ) ; failure ( ""link_to_dir:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( S_ISLNK ( st . st_mode ) ) ; # if HAVE_LCHMOD failure ( ""link_to_dir:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 07777 ) == 0755 ) ; # endif assert ( 0 == lstat ( ""dir/filea"" , & st ) ) ; failure ( ""dir/filea:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 07777 ) == 0755 ) ; failure ( ""dir/fileb:<S2SV_blank>This<S2SV_blank>file<S2SV_blank>should<S2SV_blank>not<S2SV_blank>have<S2SV_blank>been<S2SV_blank>created"" ) ; assert ( 0 != lstat ( ""dir/fileb"" , & st ) ) ; assert ( 0 == lstat ( ""link_to_dir2"" , & st ) ) ; failure ( ""link_to_dir2<S2SV_blank>should<S2SV_blank>have<S2SV_blank>been<S2SV_blank>re-created<S2SV_blank>as<S2SV_blank>a<S2SV_blank>true<S2SV_blank>dir"" ) ; assert ( S_ISDIR ( st . st_mode ) ) ; failure ( ""link_to_dir2:<S2SV_blank>Implicit<S2SV_blank>dir<S2SV_blank>creation<S2SV_blank>should<S2SV_blank>obey<S2SV_blank>umask,<S2SV_blank>but<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 0777 ) == 0755 ) ; assert ( 0 == lstat ( ""link_to_dir2/filec"" , & st ) ) ; assert ( S_ISREG ( st . st_mode ) ) ; failure ( ""link_to_dir2/filec:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 07777 ) == 0755 ) ; # endif }
","<S2SV_ModStart> ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;
",libarchive@libarchive/59357157706d47c365b2227739e17daba3607526,CVE-2015-2304,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,2015-03-15T19:59Z
CWE-22,"CWE-22 int main ( int argc , char * argv [ ] ) { static char buff [ 16384 ] ; struct cpio _cpio ; struct cpio * cpio ; const char * errmsg ; int uid , gid ; int opt ; cpio = & _cpio ; memset ( cpio , 0 , sizeof ( * cpio ) ) ; cpio -> buff = buff ; cpio -> buff_size = sizeof ( buff ) ; # if defined ( HAVE_SIGACTION ) && defined ( SIGPIPE ) { struct sigaction sa ; sigemptyset ( & sa . sa_mask ) ; sa . sa_flags = 0 ; sa . sa_handler = SIG_IGN ; sigaction ( SIGPIPE , & sa , NULL ) ; } # endif lafe_setprogname ( * argv , ""bsdcpio"" ) ; # if HAVE_SETLOCALE if ( setlocale ( LC_ALL , """" ) == NULL ) lafe_warnc ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>default<S2SV_blank>locale"" ) ; # endif cpio -> uid_override = - 1 ; cpio -> gid_override = - 1 ; cpio -> argv = argv ; cpio -> argc = argc ; cpio -> mode = '\\0' ; cpio -> verbose = 0 ; cpio -> compress = '\\0' ; cpio -> extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR ; cpio -> extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ; cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS ; cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_StartBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ; <S2SV_EndBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ; cpio -> extract_flags |= ARCHIVE_EXTRACT_ACL ; # if ! defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( geteuid ( ) == 0 ) cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ; # endif cpio -> bytes_per_block = 512 ; cpio -> filename = NULL ; cpio -> matching = archive_match_new ( ) ; if ( cpio -> matching == NULL ) lafe_errc ( 1 , 0 , ""Out<S2SV_blank>of<S2SV_blank>memory"" ) ; while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) { switch ( opt ) { case '0' : cpio -> option_null = 1 ; break ; case 'A' : cpio -> option_append = 1 ; break ; case 'a' : cpio -> option_atime_restore = 1 ; break ; case 'B' : cpio -> bytes_per_block = 5120 ; break ; case OPTION_B64ENCODE : cpio -> add_filter = opt ; break ; case 'C' : cpio -> bytes_per_block = atoi ( cpio -> argument ) ; if ( cpio -> bytes_per_block <= 0 ) lafe_errc ( 1 , 0 , ""Invalid<S2SV_blank>blocksize<S2SV_blank>%s"" , cpio -> argument ) ; break ; case 'c' : cpio -> format = ""odc"" ; break ; case 'd' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_AUTODIR ; break ; case 'E' : if ( archive_match_include_pattern_from_file ( cpio -> matching , cpio -> argument , cpio -> option_null ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; break ; case 'F' : cpio -> filename = cpio -> argument ; break ; case 'f' : if ( archive_match_exclude_pattern ( cpio -> matching , cpio -> argument ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; break ; case OPTION_GRZIP : cpio -> compress = opt ; break ; case 'H' : cpio -> format = cpio -> argument ; break ; case 'h' : long_help ( ) ; break ; case 'I' : cpio -> filename = cpio -> argument ; break ; case 'i' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-i<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; break ; case 'J' : cpio -> compress = opt ; break ; case 'j' : cpio -> compress = opt ; break ; case OPTION_INSECURE : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_SYMLINKS ; <S2SV_StartBug> cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_EndBug> break ; case 'L' : cpio -> option_follow_links = 1 ; break ; case 'l' : cpio -> option_link = 1 ; break ; case OPTION_LRZIP : case OPTION_LZ4 : case OPTION_LZMA : case OPTION_LZOP : cpio -> compress = opt ; break ; case 'm' : cpio -> extract_flags |= ARCHIVE_EXTRACT_TIME ; break ; case 'n' : cpio -> option_numeric_uid_gid = 1 ; break ; case OPTION_NO_PRESERVE_OWNER : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_OWNER ; break ; case 'O' : cpio -> filename = cpio -> argument ; break ; case 'o' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-o<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; break ; case 'p' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-p<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; break ; case OPTION_PASSPHRASE : cpio -> passphrase = cpio -> argument ; break ; case OPTION_PRESERVE_OWNER : cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ; break ; case OPTION_QUIET : cpio -> quiet = 1 ; break ; case 'R' : errmsg = owner_parse ( cpio -> argument , & uid , & gid ) ; if ( errmsg ) { lafe_warnc ( - 1 , ""%s"" , errmsg ) ; usage ( ) ; } if ( uid != - 1 ) { cpio -> uid_override = uid ; cpio -> uname_override = NULL ; } if ( gid != - 1 ) { cpio -> gid_override = gid ; cpio -> gname_override = NULL ; } break ; case 'r' : cpio -> option_rename = 1 ; break ; case 't' : cpio -> option_list = 1 ; break ; case 'u' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ; break ; case OPTION_UUENCODE : cpio -> add_filter = opt ; break ; case 'v' : cpio -> verbose ++ ; break ; case 'V' : cpio -> dot ++ ; break ; case OPTION_VERSION : version ( ) ; break ; # if 0 case 'W' : break ; # endif case 'y' : cpio -> compress = opt ; break ; case 'Z' : cpio -> compress = opt ; break ; case 'z' : cpio -> compress = opt ; break ; default : usage ( ) ; } } if ( cpio -> option_list && cpio -> mode == '\\0' ) cpio -> mode = 'i' ; if ( cpio -> option_list && cpio -> mode != 'i' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-t<S2SV_blank>requires<S2SV_blank>-i"" ) ; if ( cpio -> option_numeric_uid_gid && ! cpio -> option_list ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-n<S2SV_blank>requires<S2SV_blank>-it"" ) ; if ( cpio -> format != NULL && cpio -> mode != 'o' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>--format<S2SV_blank>requires<S2SV_blank>-o"" ) ; if ( cpio -> option_link && cpio -> mode != 'p' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-l<S2SV_blank>requires<S2SV_blank>-p"" ) ; if ( cpio -> dot && cpio -> verbose ) cpio -> dot = 0 ; switch ( cpio -> mode ) { case 'o' : if ( cpio -> format == NULL ) cpio -> format = ""odc"" ; mode_out ( cpio ) ; break ; case 'i' : while ( * cpio -> argv != NULL ) { if ( archive_match_include_pattern ( cpio -> matching , * cpio -> argv ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; -- cpio -> argc ; ++ cpio -> argv ; } if ( cpio -> option_list ) mode_list ( cpio ) ; else mode_in ( cpio ) ; break ; case 'p' : if ( * cpio -> argv == NULL || * * cpio -> argv == '\\0' ) lafe_errc ( 1 , 0 , ""-p<S2SV_blank>mode<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>target<S2SV_blank>directory"" ) ; mode_pass ( cpio , * cpio -> argv ) ; break ; default : lafe_errc ( 1 , 0 , ""Must<S2SV_blank>specify<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>of<S2SV_blank>-i,<S2SV_blank>-o,<S2SV_blank>or<S2SV_blank>-p"" ) ; } archive_match_free ( cpio -> matching ) ; free_cache ( cpio -> gname_cache ) ; free_cache ( cpio -> uname_cache ) ; free ( cpio -> destdir ) ; passphrase_free ( cpio -> ppbuff ) ; return ( cpio -> return_value ) ; }
","<S2SV_ModStart> -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
",libarchive@libarchive/59357157706d47c365b2227739e17daba3607526,CVE-2015-2304,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,2015-03-15T19:59Z
CWE-22,"CWE-22 static int cleanup_pathname ( struct archive_write_disk * a ) { char * dest , * src ; char separator = '\\0' ; dest = src = a -> name ; if ( * src == '\\0' ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ; return ( ARCHIVE_FAILED ) ; } # if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ; # endif if ( * src == '/' ) <S2SV_StartBug> separator = * src ++ ; <S2SV_EndBug> for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\'..\'"" ) ; return ( ARCHIVE_FAILED ) ; } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }
","<S2SV_ModStart> == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ;
",libarchive@libarchive/59357157706d47c365b2227739e17daba3607526,CVE-2015-2304,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,2015-03-15T19:59Z
