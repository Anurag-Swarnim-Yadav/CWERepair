cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
CWE-22,"CWE-22 static int msg_cache_check ( const char * id , struct BodyCache * bcache , void * data ) { struct Context * ctx = ( struct Context * ) data ; if ( ! ctx ) return - 1 ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; if ( ! pop_data ) return - 1 ; # ifdef USE_HCACHE if ( strcmp ( HC_FNAME ""."" HC_FEXT , id ) == 0 ) return 0 ; # endif for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> data && ( mutt_str_strcmp ( ctx -> hdrs [ i ] -> data , id ) == 0 ) ) return 0 ; } <S2SV_StartBug> return mutt_bcache_del ( bcache , id ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( bcache , cache_id ( id ) <S2SV_ModEnd> ) ; }
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
CWE-22,"CWE-22 static int msg_cache_check ( const char * id , struct BodyCache * bcache , void * data ) { struct Context * ctx = ( struct Context * ) data ; if ( ! ctx ) return - 1 ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; if ( ! pop_data ) return - 1 ; # ifdef USE_HCACHE if ( strcmp ( HC_FNAME ""."" HC_FEXT , id ) == 0 ) return 0 ; # endif for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> data && ( mutt_str_strcmp ( ctx -> hdrs [ i ] -> data , id ) == 0 ) ) return 0 ; } <S2SV_StartBug> return mutt_bcache_del ( bcache , id ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( bcache , cache_id ( id ) <S2SV_ModEnd> ) ; }
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
CWE-22,"CWE-22 static int pop_fetch_message ( struct Context * ctx , struct Message * msg , int msgno ) { void * uidl = NULL ; char buf [ LONG_STRING ] ; char path [ PATH_MAX ] ; struct Progress progressbar ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct PopCache * cache = NULL ; struct Header * h = ctx -> hdrs [ msgno ] ; unsigned short bcache = 1 ; <S2SV_StartBug> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> if ( msg -> fp ) return 0 ; cache = & pop_data -> cache [ h -> index % POP_CACHE_LEN ] ; if ( cache -> path ) { if ( cache -> index == h -> index ) { msg -> fp = fopen ( cache -> path , ""r"" ) ; if ( msg -> fp ) return 0 ; mutt_perror ( cache -> path ) ; return - 1 ; } else { unlink ( cache -> path ) ; FREE ( & cache -> path ) ; } } while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; if ( h -> refno < 0 ) { mutt_error ( _ ( ""The<S2SV_blank>message<S2SV_blank>index<S2SV_blank>is<S2SV_blank>incorrect.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" ) ) ; return - 1 ; } mutt_progress_init ( & progressbar , _ ( ""Fetching<S2SV_blank>message..."" ) , MUTT_PROGRESS_SIZE , NetInc , h -> content -> length + h -> content -> offset - 1 ) ; <S2SV_StartBug> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> if ( ! msg -> fp ) { bcache = 0 ; mutt_mktemp ( path , sizeof ( path ) ) ; msg -> fp = mutt_file_fopen ( path , ""w+"" ) ; if ( ! msg -> fp ) { mutt_perror ( path ) ; return - 1 ; } } snprintf ( buf , sizeof ( buf ) , ""RETR<S2SV_blank>%d\\r\\n"" , h -> refno ) ; const int ret = pop_fetch_data ( pop_data , buf , & progressbar , fetch_message , msg -> fp ) ; if ( ret == 0 ) break ; mutt_file_fclose ( & msg -> fp ) ; if ( ! bcache ) unlink ( path ) ; if ( ret == - 2 ) { mutt_error ( ""%s"" , pop_data -> err_msg ) ; return - 1 ; } if ( ret == - 3 ) { mutt_error ( _ ( ""Can\'t<S2SV_blank>write<S2SV_blank>message<S2SV_blank>to<S2SV_blank>temporary<S2SV_blank>file!"" ) ) ; return - 1 ; } } if ( bcache ) <S2SV_StartBug> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> else { cache -> index = h -> index ; cache -> path = mutt_str_strdup ( path ) ; } rewind ( msg -> fp ) ; uidl = h -> data ; if ( ctx -> subj_hash && h -> env -> real_subj ) mutt_hash_delete ( ctx -> subj_hash , h -> env -> real_subj , h ) ; mutt_label_hash_remove ( ctx , h ) ; mutt_env_free ( & h -> env ) ; h -> env = mutt_rfc822_read_header ( msg -> fp , h , 0 , 0 ) ; if ( ctx -> subj_hash && h -> env -> real_subj ) mutt_hash_insert ( ctx -> subj_hash , h -> env -> real_subj , h ) ; mutt_label_hash_add ( ctx , h ) ; h -> data = uidl ; h -> lines = 0 ; fgets ( buf , sizeof ( buf ) , msg -> fp ) ; while ( ! feof ( msg -> fp ) ) { ctx -> hdrs [ msgno ] -> lines ++ ; fgets ( buf , sizeof ( buf ) , msg -> fp ) ; } h -> content -> length = ftello ( msg -> fp ) - h -> content -> offset ; if ( ! WithCrypto ) h -> security = crypt_query ( h -> content ) ; mutt_clear_error ( ) ; rewind ( msg -> fp ) ; return 0 ; }
","<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data ) <S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data ) <S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data )
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
CWE-22,"CWE-22 static int pop_fetch_message ( struct Context * ctx , struct Message * msg , int msgno ) { void * uidl = NULL ; char buf [ LONG_STRING ] ; char path [ PATH_MAX ] ; struct Progress progressbar ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct PopCache * cache = NULL ; struct Header * h = ctx -> hdrs [ msgno ] ; unsigned short bcache = 1 ; <S2SV_StartBug> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> if ( msg -> fp ) return 0 ; cache = & pop_data -> cache [ h -> index % POP_CACHE_LEN ] ; if ( cache -> path ) { if ( cache -> index == h -> index ) { msg -> fp = fopen ( cache -> path , ""r"" ) ; if ( msg -> fp ) return 0 ; mutt_perror ( cache -> path ) ; return - 1 ; } else { unlink ( cache -> path ) ; FREE ( & cache -> path ) ; } } while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; if ( h -> refno < 0 ) { mutt_error ( _ ( ""The<S2SV_blank>message<S2SV_blank>index<S2SV_blank>is<S2SV_blank>incorrect.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" ) ) ; return - 1 ; } mutt_progress_init ( & progressbar , _ ( ""Fetching<S2SV_blank>message..."" ) , MUTT_PROGRESS_SIZE , NetInc , h -> content -> length + h -> content -> offset - 1 ) ; <S2SV_StartBug> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> if ( ! msg -> fp ) { bcache = 0 ; mutt_mktemp ( path , sizeof ( path ) ) ; msg -> fp = mutt_file_fopen ( path , ""w+"" ) ; if ( ! msg -> fp ) { mutt_perror ( path ) ; return - 1 ; } } snprintf ( buf , sizeof ( buf ) , ""RETR<S2SV_blank>%d\\r\\n"" , h -> refno ) ; const int ret = pop_fetch_data ( pop_data , buf , & progressbar , fetch_message , msg -> fp ) ; if ( ret == 0 ) break ; mutt_file_fclose ( & msg -> fp ) ; if ( ! bcache ) unlink ( path ) ; if ( ret == - 2 ) { mutt_error ( ""%s"" , pop_data -> err_msg ) ; return - 1 ; } if ( ret == - 3 ) { mutt_error ( _ ( ""Can\'t<S2SV_blank>write<S2SV_blank>message<S2SV_blank>to<S2SV_blank>temporary<S2SV_blank>file!"" ) ) ; return - 1 ; } } if ( bcache ) <S2SV_StartBug> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> else { cache -> index = h -> index ; cache -> path = mutt_str_strdup ( path ) ; } rewind ( msg -> fp ) ; uidl = h -> data ; if ( ctx -> subj_hash && h -> env -> real_subj ) mutt_hash_delete ( ctx -> subj_hash , h -> env -> real_subj , h ) ; mutt_label_hash_remove ( ctx , h ) ; mutt_env_free ( & h -> env ) ; h -> env = mutt_rfc822_read_header ( msg -> fp , h , 0 , 0 ) ; if ( ctx -> subj_hash && h -> env -> real_subj ) mutt_hash_insert ( ctx -> subj_hash , h -> env -> real_subj , h ) ; mutt_label_hash_add ( ctx , h ) ; h -> data = uidl ; h -> lines = 0 ; fgets ( buf , sizeof ( buf ) , msg -> fp ) ; while ( ! feof ( msg -> fp ) ) { ctx -> hdrs [ msgno ] -> lines ++ ; fgets ( buf , sizeof ( buf ) , msg -> fp ) ; } h -> content -> length = ftello ( msg -> fp ) - h -> content -> offset ; if ( ! WithCrypto ) h -> security = crypt_query ( h -> content ) ; mutt_clear_error ( ) ; rewind ( msg -> fp ) ; return 0 ; }
","<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data ) <S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data ) <S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data )
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
CWE-22,"CWE-22 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( ""Marking<S2SV_blank>messages<S2SV_blank>deleted..."" ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , ""DELE<S2SV_blank>%d\\r\\n"" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , ""QUIT\\r\\n"" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( ""%s"" , pop_data -> err_msg ) ; return - 1 ; } } }
","<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
CWE-22,"CWE-22 static int pop_fetch_headers ( struct Context * ctx ) { struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif time ( & pop_data -> check_time ) ; pop_data -> clear_cache = false ; for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) ctx -> hdrs [ i ] -> refno = - 1 ; const int old_count = ctx -> msgcount ; int ret = pop_fetch_data ( pop_data , ""UIDL\\r\\n"" , NULL , fetch_uidl , ctx ) ; const int new_count = ctx -> msgcount ; ctx -> msgcount = old_count ; if ( pop_data -> cmd_uidl == 2 ) { if ( ret == 0 ) { pop_data -> cmd_uidl = 1 ; mutt_debug ( 1 , ""set<S2SV_blank>UIDL<S2SV_blank>capability\\n"" ) ; } if ( ret == - 2 && pop_data -> cmd_uidl == 2 ) { pop_data -> cmd_uidl = 0 ; mutt_debug ( 1 , ""unset<S2SV_blank>UIDL<S2SV_blank>capability\\n"" ) ; snprintf ( pop_data -> err_msg , sizeof ( pop_data -> err_msg ) , ""%s"" , _ ( ""Command<S2SV_blank>UIDL<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server."" ) ) ; } } if ( ! ctx -> quiet ) { mutt_progress_init ( & progress , _ ( ""Fetching<S2SV_blank>message<S2SV_blank>headers..."" ) , MUTT_PROGRESS_MSG , ReadInc , new_count - old_count ) ; } if ( ret == 0 ) { int i , deleted ; for ( i = 0 , deleted = 0 ; i < old_count ; i ++ ) { if ( ctx -> hdrs [ i ] -> refno == - 1 ) { ctx -> hdrs [ i ] -> deleted = true ; deleted ++ ; } } if ( deleted > 0 ) { mutt_error ( ngettext ( ""%d<S2SV_blank>message<S2SV_blank>has<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" , ""%d<S2SV_blank>messages<S2SV_blank>have<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" , deleted ) , deleted ) ; } bool hcached = false ; for ( i = old_count ; i < new_count ; i ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & progress , i + 1 - old_count , - 1 ) ; # ifdef USE_HCACHE void * data = mutt_hcache_fetch ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; if ( data ) { char * uidl = mutt_str_strdup ( ctx -> hdrs [ i ] -> data ) ; int refno = ctx -> hdrs [ i ] -> refno ; int index = ctx -> hdrs [ i ] -> index ; struct Header * h = mutt_hcache_restore ( ( unsigned char * ) data ) ; mutt_hcache_free ( hc , & data ) ; mutt_header_free ( & ctx -> hdrs [ i ] ) ; ctx -> hdrs [ i ] = h ; ctx -> hdrs [ i ] -> refno = refno ; ctx -> hdrs [ i ] -> index = index ; ctx -> hdrs [ i ] -> data = uidl ; ret = 0 ; hcached = true ; } else # endif if ( ( ret = pop_read_header ( pop_data , ctx -> hdrs [ i ] ) ) < 0 ) break ; # ifdef USE_HCACHE else { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif const bool bcached = <S2SV_StartBug> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <S2SV_EndBug> ctx -> hdrs [ i ] -> old = false ; ctx -> hdrs [ i ] -> read = false ; if ( hcached ) { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; else if ( MarkOld ) ctx -> hdrs [ i ] -> old = true ; } else { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; } ctx -> msgcount ++ ; } if ( i > old_count ) mx_update_context ( ctx , i - old_count ) ; } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret < 0 ) { for ( int i = ctx -> msgcount ; i < new_count ; i ++ ) mutt_header_free ( & ctx -> hdrs [ i ] ) ; return ret ; } if ( MessageCacheClean ) mutt_bcache_list ( pop_data -> bcache , msg_cache_check , ( void * ) ctx ) ; mutt_clear_error ( ) ; return ( new_count - old_count ) ; }
","<S2SV_ModStart> -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> ) == 0
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
CWE-22,"CWE-22 static int pop_fetch_headers ( struct Context * ctx ) { struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif time ( & pop_data -> check_time ) ; pop_data -> clear_cache = false ; for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) ctx -> hdrs [ i ] -> refno = - 1 ; const int old_count = ctx -> msgcount ; int ret = pop_fetch_data ( pop_data , ""UIDL\\r\\n"" , NULL , fetch_uidl , ctx ) ; const int new_count = ctx -> msgcount ; ctx -> msgcount = old_count ; if ( pop_data -> cmd_uidl == 2 ) { if ( ret == 0 ) { pop_data -> cmd_uidl = 1 ; mutt_debug ( 1 , ""set<S2SV_blank>UIDL<S2SV_blank>capability\\n"" ) ; } if ( ret == - 2 && pop_data -> cmd_uidl == 2 ) { pop_data -> cmd_uidl = 0 ; mutt_debug ( 1 , ""unset<S2SV_blank>UIDL<S2SV_blank>capability\\n"" ) ; snprintf ( pop_data -> err_msg , sizeof ( pop_data -> err_msg ) , ""%s"" , _ ( ""Command<S2SV_blank>UIDL<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server."" ) ) ; } } if ( ! ctx -> quiet ) { mutt_progress_init ( & progress , _ ( ""Fetching<S2SV_blank>message<S2SV_blank>headers..."" ) , MUTT_PROGRESS_MSG , ReadInc , new_count - old_count ) ; } if ( ret == 0 ) { int i , deleted ; for ( i = 0 , deleted = 0 ; i < old_count ; i ++ ) { if ( ctx -> hdrs [ i ] -> refno == - 1 ) { ctx -> hdrs [ i ] -> deleted = true ; deleted ++ ; } } if ( deleted > 0 ) { mutt_error ( ngettext ( ""%d<S2SV_blank>message<S2SV_blank>has<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" , ""%d<S2SV_blank>messages<S2SV_blank>have<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" , deleted ) , deleted ) ; } bool hcached = false ; for ( i = old_count ; i < new_count ; i ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & progress , i + 1 - old_count , - 1 ) ; # ifdef USE_HCACHE void * data = mutt_hcache_fetch ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; if ( data ) { char * uidl = mutt_str_strdup ( ctx -> hdrs [ i ] -> data ) ; int refno = ctx -> hdrs [ i ] -> refno ; int index = ctx -> hdrs [ i ] -> index ; struct Header * h = mutt_hcache_restore ( ( unsigned char * ) data ) ; mutt_hcache_free ( hc , & data ) ; mutt_header_free ( & ctx -> hdrs [ i ] ) ; ctx -> hdrs [ i ] = h ; ctx -> hdrs [ i ] -> refno = refno ; ctx -> hdrs [ i ] -> index = index ; ctx -> hdrs [ i ] -> data = uidl ; ret = 0 ; hcached = true ; } else # endif if ( ( ret = pop_read_header ( pop_data , ctx -> hdrs [ i ] ) ) < 0 ) break ; # ifdef USE_HCACHE else { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif const bool bcached = <S2SV_StartBug> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <S2SV_EndBug> ctx -> hdrs [ i ] -> old = false ; ctx -> hdrs [ i ] -> read = false ; if ( hcached ) { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; else if ( MarkOld ) ctx -> hdrs [ i ] -> old = true ; } else { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; } ctx -> msgcount ++ ; } if ( i > old_count ) mx_update_context ( ctx , i - old_count ) ; } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret < 0 ) { for ( int i = ctx -> msgcount ; i < new_count ; i ++ ) mutt_header_free ( & ctx -> hdrs [ i ] ) ; return ret ; } if ( MessageCacheClean ) mutt_bcache_list ( pop_data -> bcache , msg_cache_check , ( void * ) ctx ) ; mutt_clear_error ( ) ; return ( new_count - old_count ) ; }
","<S2SV_ModStart> -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> ) == 0
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
