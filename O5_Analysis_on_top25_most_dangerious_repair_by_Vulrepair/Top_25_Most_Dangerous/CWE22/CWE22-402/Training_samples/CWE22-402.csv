cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
CWE-22,"CWE-22 local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>"" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , ""<S2SV_blank>too<S2SV_blank>large<S2SV_blank>--<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>large<S2SV_blank>file<S2SV_blank>support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>special<S2SV_blank>file<S2SV_blank>or<S2SV_blank>device<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>directory<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path<S2SV_blank>too<S2SV_blank>long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>"" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s<S2SV_blank>ends<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>--<S2SV_blank>skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>compressed<S2SV_blank>suffix<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>compressed<S2SV_blank>--<S2SV_blank>skipping"" : ""%s<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>data<S2SV_blank>to<S2SV_blank>a<S2SV_blank>terminal"" , ""<S2SV_blank>(use<S2SV_blank>-f<S2SV_blank>to<S2SV_blank>force)"" ) ; } else { <S2SV_StartBug> char * to , * repl ; <S2SV_EndBug> to = g . inf ; <S2SV_StartBug> if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { <S2SV_EndBug> <S2SV_StartBug> to = g . hname ; <S2SV_EndBug> <S2SV_StartBug> len = strlen ( g . hname ) ; <S2SV_EndBug> } <S2SV_StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; <S2SV_EndBug> <S2SV_StartBug> g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <S2SV_EndBug> if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; <S2SV_StartBug> memcpy ( g . outf , to , len ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <S2SV_EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s<S2SV_blank>exists<S2SV_blank>--<S2SV_blank>overwrite<S2SV_blank>(y/n)?<S2SV_blank>"" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != '<S2SV_blank>' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s<S2SV_blank>exists<S2SV_blank>--<S2SV_blank>skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
","<S2SV_ModStart> char * to = g . inf , * sufx = """" ; size_t pre = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> g . decode ) { if ( <S2SV_ModEnd> ( g . <S2SV_ModStart> NULL ) { pre = justname ( g . inf ) - g . inf ; to = justname ( <S2SV_ModEnd> g . hname <S2SV_ModStart> g . hname ) <S2SV_ModStart> = strlen ( to ) ; } else if ( <S2SV_ModEnd> strcmp ( to <S2SV_ModStart> , "".tgz"" ) == 0 ) sufx = "".tar"" ; } else sufx = g . sufx ; <S2SV_ModEnd> g . outf <S2SV_ModStart> = MALLOC ( pre + len + strlen ( sufx ) <S2SV_ModEnd> + 1 ) <S2SV_ModStart> . outf , g . inf , pre ) ; memcpy <S2SV_ModEnd> ( g . <S2SV_ModStart> . outf + pre , to , len ) ; strcpy ( g . outf + pre + len , <S2SV_ModEnd> sufx ) ;
",madler@pigz/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,CVE-2015-1191,https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,2015-01-21T18:59Z
CWE-22,"CWE-22 local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>"" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , ""<S2SV_blank>too<S2SV_blank>large<S2SV_blank>--<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>large<S2SV_blank>file<S2SV_blank>support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>special<S2SV_blank>file<S2SV_blank>or<S2SV_blank>device<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>directory<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path<S2SV_blank>too<S2SV_blank>long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>"" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s<S2SV_blank>ends<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>--<S2SV_blank>skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>compressed<S2SV_blank>suffix<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>compressed<S2SV_blank>--<S2SV_blank>skipping"" : ""%s<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>data<S2SV_blank>to<S2SV_blank>a<S2SV_blank>terminal"" , ""<S2SV_blank>(use<S2SV_blank>-f<S2SV_blank>to<S2SV_blank>force)"" ) ; } else { <S2SV_StartBug> char * to , * repl ; <S2SV_EndBug> to = g . inf ; <S2SV_StartBug> if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { <S2SV_EndBug> <S2SV_StartBug> to = g . hname ; <S2SV_EndBug> <S2SV_StartBug> len = strlen ( g . hname ) ; <S2SV_EndBug> } <S2SV_StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; <S2SV_EndBug> <S2SV_StartBug> g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <S2SV_EndBug> if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; <S2SV_StartBug> memcpy ( g . outf , to , len ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <S2SV_EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s<S2SV_blank>exists<S2SV_blank>--<S2SV_blank>overwrite<S2SV_blank>(y/n)?<S2SV_blank>"" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != '<S2SV_blank>' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s<S2SV_blank>exists<S2SV_blank>--<S2SV_blank>skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
","<S2SV_ModStart> char * to = g . inf , * sufx = """" ; size_t pre = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> g . decode ) { if ( <S2SV_ModEnd> ( g . <S2SV_ModStart> NULL ) { pre = justname ( g . inf ) - g . inf ; to = justname ( <S2SV_ModEnd> g . hname <S2SV_ModStart> g . hname ) <S2SV_ModStart> = strlen ( to ) ; } else if ( <S2SV_ModEnd> strcmp ( to <S2SV_ModStart> , "".tgz"" ) == 0 ) sufx = "".tar"" ; } else sufx = g . sufx ; <S2SV_ModEnd> g . outf <S2SV_ModStart> = MALLOC ( pre + len + strlen ( sufx ) <S2SV_ModEnd> + 1 ) <S2SV_ModStart> . outf , g . inf , pre ) ; memcpy <S2SV_ModEnd> ( g . <S2SV_ModStart> . outf + pre , to , len ) ; strcpy ( g . outf + pre + len , <S2SV_ModEnd> sufx ) ;
",madler@pigz/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,CVE-2015-1191,https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,2015-01-21T18:59Z
