cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
CWE-22,"CWE-22 static int target_xcopy_parse_target_descriptors ( struct se_cmd * se_cmd , struct xcopy_op * xop , unsigned char * p , unsigned short tdll , sense_reason_t * sense_ret ) { struct se_device * local_dev = se_cmd -> se_dev ; unsigned char * desc = p ; int offset = tdll % XCOPY_TARGET_DESC_LEN , rc ; unsigned short cscd_index = 0 ; unsigned short start = 0 ; * sense_ret = TCM_INVALID_PARAMETER_LIST ; if ( offset != 0 ) { pr_err ( ""XCOPY<S2SV_blank>target<S2SV_blank>descriptor<S2SV_blank>list<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not"" ""<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>%d\\n"" , XCOPY_TARGET_DESC_LEN ) ; * sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE ; return - EINVAL ; } if ( tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN ) { pr_err ( ""XCOPY<S2SV_blank>target<S2SV_blank>descriptor<S2SV_blank>supports<S2SV_blank>a<S2SV_blank>maximum"" ""<S2SV_blank>two<S2SV_blank>src/dest<S2SV_blank>descriptors,<S2SV_blank>tdll:<S2SV_blank>%hu<S2SV_blank>too<S2SV_blank>large..\\n"" , tdll ) ; * sense_ret = TCM_TOO_MANY_TARGET_DESCS ; return - EINVAL ; } memset ( & xop -> local_dev_wwn [ 0 ] , 0 , XCOPY_NAA_IEEE_REGEX_LEN ) ; target_xcopy_gen_naa_ieee ( local_dev , & xop -> local_dev_wwn [ 0 ] ) ; while ( start < tdll ) { switch ( desc [ 0 ] ) { case 0xe4 : rc = target_xcopy_parse_tiddesc_e4 ( se_cmd , xop , & desc [ 0 ] , cscd_index ) ; if ( rc != 0 ) goto out ; start += XCOPY_TARGET_DESC_LEN ; desc += XCOPY_TARGET_DESC_LEN ; cscd_index ++ ; break ; default : pr_err ( ""XCOPY<S2SV_blank>unsupported<S2SV_blank>descriptor<S2SV_blank>type<S2SV_blank>code:"" ""<S2SV_blank>0x%02x\\n"" , desc [ 0 ] ) ; * sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE ; goto out ; } } switch ( xop -> op_origin ) { case XCOL_SOURCE_RECV_OP : <S2SV_StartBug> rc = target_xcopy_locate_se_dev_e4 ( xop -> dst_tid_wwn , <S2SV_EndBug> <S2SV_StartBug> & xop -> dst_dev ) ; <S2SV_EndBug> break ; case XCOL_DEST_RECV_OP : <S2SV_StartBug> rc = target_xcopy_locate_se_dev_e4 ( xop -> src_tid_wwn , <S2SV_EndBug> <S2SV_StartBug> & xop -> src_dev ) ; <S2SV_EndBug> break ; default : pr_err ( ""XCOPY<S2SV_blank>CSCD<S2SV_blank>descriptor<S2SV_blank>IDs<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>CSCD<S2SV_blank>list<S2SV_blank>-<S2SV_blank>"" ""stdi:<S2SV_blank>%hu<S2SV_blank>dtdi:<S2SV_blank>%hu\\n"" , xop -> stdi , xop -> dtdi ) ; rc = - EINVAL ; break ; } if ( rc < 0 ) { * sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE ; goto out ; } pr_debug ( ""XCOPY<S2SV_blank>TGT<S2SV_blank>desc:<S2SV_blank>Source<S2SV_blank>dev:<S2SV_blank>%p<S2SV_blank>NAA<S2SV_blank>IEEE<S2SV_blank>WWN:<S2SV_blank>0x%16phN\\n"" , xop -> src_dev , & xop -> src_tid_wwn [ 0 ] ) ; pr_debug ( ""XCOPY<S2SV_blank>TGT<S2SV_blank>desc:<S2SV_blank>Dest<S2SV_blank>dev:<S2SV_blank>%p<S2SV_blank>NAA<S2SV_blank>IEEE<S2SV_blank>WWN:<S2SV_blank>0x%16phN\\n"" , xop -> dst_dev , & xop -> dst_tid_wwn [ 0 ] ) ; return cscd_index ; out : return - EINVAL ; }
","<S2SV_ModStart> = target_xcopy_locate_se_dev_e4 ( se_cmd -> se_sess , <S2SV_ModStart> xop -> dst_dev , & xop -> remote_lun_ref <S2SV_ModStart> = target_xcopy_locate_se_dev_e4 ( se_cmd -> se_sess , <S2SV_ModStart> xop -> src_dev , & xop -> remote_lun_ref
",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z
CWE-22,"CWE-22 static int target_xcopy_locate_se_dev_e4_iter ( struct se_device * se_dev , <S2SV_StartBug> void * data ) <S2SV_EndBug> { struct xcopy_dev_search_info * info = data ; unsigned char tmp_dev_wwn [ XCOPY_NAA_IEEE_REGEX_LEN ] ; int rc ; <S2SV_StartBug> if ( ! se_dev -> dev_attrib . emulate_3pc ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> memset ( & tmp_dev_wwn [ 0 ] , 0 , XCOPY_NAA_IEEE_REGEX_LEN ) ; target_xcopy_gen_naa_ieee ( se_dev , & tmp_dev_wwn [ 0 ] ) ; <S2SV_StartBug> rc = memcmp ( & tmp_dev_wwn [ 0 ] , info -> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc != 0 ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> info -> found_dev = se_dev ; <S2SV_EndBug> pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" , se_dev ) ; <S2SV_StartBug> rc = target_depend_item ( & se_dev -> dev_group . cg_item ) ; <S2SV_EndBug> if ( rc != 0 ) { pr_err ( ""configfs_depend_item<S2SV_blank>attempt<S2SV_blank>failed:<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" , rc , se_dev ) ; return rc ; } pr_debug ( ""Called<S2SV_blank>configfs_depend_item<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n"" , se_dev , & se_dev -> dev_group ) ; return 1 ; }
","<S2SV_ModStart> * se_dev , const unsigned char * dev_wwn ) { <S2SV_ModEnd> unsigned char tmp_dev_wwn <S2SV_ModStart> . emulate_3pc ) { pr_debug ( ""XCOPY:<S2SV_blank>emulate_3pc<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>se_dev<S2SV_blank>%p\\n"" , se_dev ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> 0 ] , <S2SV_ModEnd> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN <S2SV_ModStart> != 0 ) { pr_debug ( ""XCOPY:<S2SV_blank>skip<S2SV_blank>non-matching:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , tmp_dev_wwn ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModEnd> pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" <S2SV_ModStart> se_dev ) ; <S2SV_ModEnd> return 1 ;
",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z
CWE-22,"CWE-22 <S2SV_StartBug> static int target_xcopy_locate_se_dev_e4 ( const unsigned char * dev_wwn , <S2SV_EndBug> <S2SV_StartBug> struct se_device * * found_dev ) <S2SV_EndBug> { <S2SV_StartBug> struct xcopy_dev_search_info info ; <S2SV_EndBug> int ret ; memset ( & info , 0 , sizeof ( info ) ) ; info . dev_wwn = dev_wwn ; ret = target_for_each_device ( target_xcopy_locate_se_dev_e4_iter , & info ) ; if ( ret == 1 ) { * found_dev = info . found_dev ; return 0 ; <S2SV_StartBug> } else { <S2SV_EndBug> pr_debug_ratelimited ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\n"" ) ; return - EINVAL ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> int target_xcopy_locate_se_dev_e4 ( struct se_session * sess , <S2SV_ModStart> se_device * * _found_dev , struct percpu_ref * * _found_lun_ref <S2SV_ModEnd> ) { struct <S2SV_ModStart> ) { struct se_dev_entry * deve ; struct se_node_acl * nacl ; struct se_lun * this_lun = NULL ; struct se_device * found_dev = NULL ; if ( ! sess ) goto err_out ; pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>searching<S2SV_blank>for:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , dev_wwn ) ; nacl = sess -> se_node_acl ; rcu_read_lock ( ) ; hlist_for_each_entry_rcu ( deve , & nacl -> lun_entry_hlist , link ) { struct se_device * this_dev ; int rc ; this_lun = rcu_dereference ( deve -> se_lun ) ; this_dev = rcu_dereference_raw ( this_lun -> lun_se_dev ) ; rc = target_xcopy_locate_se_dev_e4_iter ( this_dev , dev_wwn ) ; if ( rc ) { if ( percpu_ref_tryget_live ( & this_lun -> lun_ref ) ) found_dev = this_dev ; break ; } } rcu_read_unlock ( ) ; if ( found_dev == NULL ) goto err_out ; pr_debug ( ""lun_ref<S2SV_blank>held<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n"" , found_dev , & found_dev -> dev_group ) ; * _found_dev = found_dev ; * _found_lun_ref = & this_lun -> lun_ref <S2SV_ModEnd> ; return 0 <S2SV_ModStart> return 0 ; err_out : <S2SV_ModEnd> pr_debug_ratelimited ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\n"" <S2SV_ModStart> EINVAL ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z
CWE-22,"CWE-22 static void xcopy_pt_undepend_remotedev ( struct xcopy_op * xop ) { <S2SV_StartBug> struct se_device * remote_dev ; <S2SV_EndBug> if ( xop -> op_origin == XCOL_SOURCE_RECV_OP ) <S2SV_StartBug> remote_dev = xop -> dst_dev ; <S2SV_EndBug> else <S2SV_StartBug> remote_dev = xop -> src_dev ; <S2SV_EndBug> pr_debug ( ""Calling<S2SV_blank>configfs_undepend_item<S2SV_blank>for"" ""<S2SV_blank>remote_dev:<S2SV_blank>%p<S2SV_blank>remote_dev->dev_group:<S2SV_blank>%p\\n"" , remote_dev , & remote_dev -> dev_group . cg_item ) ; target_undepend_item ( & remote_dev -> dev_group . cg_item ) ; }
","<S2SV_ModStart> xop ) { <S2SV_ModEnd> if ( xop <S2SV_ModStart> == XCOL_SOURCE_RECV_OP ) pr_debug ( ""putting<S2SV_blank>dst<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> xop -> dst_dev <S2SV_ModStart> xop -> dst_dev ) ; else pr_debug ( ""putting<S2SV_blank>src<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> xop -> src_dev <S2SV_ModStart> xop -> src_dev ) ; percpu_ref_put ( xop -> remote_lun_ref <S2SV_ModEnd> ) ; }
",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z
