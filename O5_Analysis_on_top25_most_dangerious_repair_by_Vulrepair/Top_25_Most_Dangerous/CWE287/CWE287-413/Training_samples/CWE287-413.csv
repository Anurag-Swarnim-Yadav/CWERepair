cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
CWE-287,"CWE-287 static int _c2s_sx_sasl_callback ( int cb , void * arg , void * * res , sx_t s , void * cbarg ) { c2s_t c2s = ( c2s_t ) cbarg ; const char * my_realm , * mech ; sx_sasl_creds_t creds ; static char buf [ 3072 ] ; char mechbuf [ 256 ] ; struct jid_st jid ; jid_static_buf jid_buf ; int i , r ; sess_t sess ; char skey [ 44 ] ; host_t host ; jid_static ( & jid , & jid_buf ) ; assert ( s != NULL ) ; sprintf ( skey , ""%d"" , s -> tag ) ; sess = xhash_get ( c2s -> sessions , skey ) ; switch ( cb ) { case sx_sasl_cb_GET_REALM : if ( s -> req_to == NULL ) my_realm = """" ; else { host = xhash_get ( c2s -> hosts , s -> req_to ) ; if ( host == NULL ) { log_write ( c2s -> log , LOG_ERR , ""SASL<S2SV_blank>callback<S2SV_blank>for<S2SV_blank>non-existing<S2SV_blank>host:<S2SV_blank>%s"" , s -> req_to ) ; * res = ( void * ) NULL ; return sx_sasl_ret_FAIL ; } my_realm = host -> realm ; if ( my_realm == NULL ) my_realm = s -> req_to ; } strncpy ( buf , my_realm , 256 ) ; * res = ( void * ) buf ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>get<S2SV_blank>realm:<S2SV_blank>realm<S2SV_blank>is<S2SV_blank>\'%s\'"" , buf ) ; return sx_sasl_ret_OK ; break ; case sx_sasl_cb_GET_PASS : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>get<S2SV_blank>pass<S2SV_blank>(authnid=%s,<S2SV_blank>realm=%s)"" , creds -> authnid , creds -> realm ) ; if ( sess -> host -> ar -> get_password && ( sess -> host -> ar -> get_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , buf ) == 0 ) { * res = buf ; return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; case sx_sasl_cb_CHECK_PASS : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>pass<S2SV_blank>(authnid=%s,<S2SV_blank>realm=%s)"" , creds -> authnid , creds -> realm ) ; if ( sess -> host -> ar -> check_password != NULL ) { if ( ( sess -> host -> ar -> check_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , ( char * ) creds -> pass ) == 0 ) return sx_sasl_ret_OK ; else return sx_sasl_ret_FAIL ; } if ( sess -> host -> ar -> get_password != NULL ) { if ( ( sess -> host -> ar -> get_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , buf ) != 0 ) return sx_sasl_ret_FAIL ; if ( strcmp ( creds -> pass , buf ) == 0 ) return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; break ; case sx_sasl_cb_CHECK_AUTHZID : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; if ( creds -> authzid == NULL || creds -> authzid [ 0 ] == '\\0' ) return sx_sasl_ret_FAIL ; if ( jid_reset ( & jid , creds -> authzid , - 1 ) == NULL ) return sx_sasl_ret_FAIL ; if ( ! s -> req_to || ( strcmp ( jid . domain , s -> req_to ) != 0 ) ) return sx_sasl_ret_FAIL ; if ( jid . resource [ 0 ] != '\\0' ) return sx_sasl_ret_FAIL ; if ( sess -> host -> ar -> user_authz_allowed ) { if ( sess -> host -> ar -> user_authz_allowed ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( char * ) creds -> realm , ( char * ) creds -> authzid ) ) return sx_sasl_ret_OK ; } else { if ( strcmp ( creds -> authnid , jid . node ) == 0 && ( sess -> host -> ar -> user_exists ) ( sess -> host -> ar , sess , jid . node , jid . domain ) ) return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; case sx_sasl_cb_GEN_AUTHZID : jid_reset ( & jid , s -> req_to , - 1 ) ; jid_random_part ( & jid , jid_NODE ) ; strcpy ( buf , jid . node ) ; * res = ( void * ) buf ; return sx_sasl_ret_OK ; break ; case sx_sasl_cb_CHECK_MECH : mech = ( char * ) arg ; strncpy ( mechbuf , mech , sizeof ( mechbuf ) ) ; mechbuf [ sizeof ( mechbuf ) - 1 ] = '\\0' ; <S2SV_StartBug> for ( i = 0 ; mechbuf [ i ] ; i ++ ) mechbuf [ i ] = tolower ( mechbuf [ i ] ) ; <S2SV_EndBug> host = xhash_get ( c2s -> hosts , s -> req_to ) ; if ( host == NULL ) { log_write ( c2s -> log , LOG_WARNING , ""SASL<S2SV_blank>callback<S2SV_blank>for<S2SV_blank>non-existing<S2SV_blank>host:<S2SV_blank>%s"" , s -> req_to ) ; return sx_sasl_ret_FAIL ; } if ( strcmp ( mechbuf , ""digest-md5"" ) == 0 ) { if ( host -> ar -> get_password == NULL ) return sx_sasl_ret_FAIL ; } else if ( strcmp ( mechbuf , ""plain"" ) == 0 ) { if ( host -> ar -> get_password == NULL && host -> ar -> check_password == NULL ) return sx_sasl_ret_FAIL ; } if ( s -> ssf > 0 ) { r = snprintf ( buf , sizeof ( buf ) , ""authreg.ssl-mechanisms.sasl.%s"" , mechbuf ) ; if ( r < - 1 || r > sizeof ( buf ) ) return sx_sasl_ret_FAIL ; if ( config_get ( c2s -> config , buf ) != NULL ) return sx_sasl_ret_OK ; } r = snprintf ( buf , sizeof ( buf ) , ""authreg.mechanisms.sasl.%s"" , mechbuf ) ; if ( r < - 1 || r > sizeof ( buf ) ) return sx_sasl_ret_FAIL ; if ( config_get ( c2s -> config , buf ) != NULL ) return sx_sasl_ret_OK ; else return sx_sasl_ret_FAIL ; default : break ; } return sx_sasl_ret_FAIL ; }
","<S2SV_ModStart> [ i ] ) ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)"" , mechbuf
",jabberd2@jabberd2/8416ae54ecefa670534f27a31db71d048b9c7f16,CVE-2017-10807,https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16,2017-07-04T15:29Z
CWE-287,"CWE-287 static int _c2s_sx_sasl_callback ( int cb , void * arg , void * * res , sx_t s , void * cbarg ) { c2s_t c2s = ( c2s_t ) cbarg ; const char * my_realm , * mech ; sx_sasl_creds_t creds ; static char buf [ 3072 ] ; char mechbuf [ 256 ] ; struct jid_st jid ; jid_static_buf jid_buf ; int i , r ; sess_t sess ; char skey [ 44 ] ; host_t host ; jid_static ( & jid , & jid_buf ) ; assert ( s != NULL ) ; sprintf ( skey , ""%d"" , s -> tag ) ; sess = xhash_get ( c2s -> sessions , skey ) ; switch ( cb ) { case sx_sasl_cb_GET_REALM : if ( s -> req_to == NULL ) my_realm = """" ; else { host = xhash_get ( c2s -> hosts , s -> req_to ) ; if ( host == NULL ) { log_write ( c2s -> log , LOG_ERR , ""SASL<S2SV_blank>callback<S2SV_blank>for<S2SV_blank>non-existing<S2SV_blank>host:<S2SV_blank>%s"" , s -> req_to ) ; * res = ( void * ) NULL ; return sx_sasl_ret_FAIL ; } my_realm = host -> realm ; if ( my_realm == NULL ) my_realm = s -> req_to ; } strncpy ( buf , my_realm , 256 ) ; * res = ( void * ) buf ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>get<S2SV_blank>realm:<S2SV_blank>realm<S2SV_blank>is<S2SV_blank>\'%s\'"" , buf ) ; return sx_sasl_ret_OK ; break ; case sx_sasl_cb_GET_PASS : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>get<S2SV_blank>pass<S2SV_blank>(authnid=%s,<S2SV_blank>realm=%s)"" , creds -> authnid , creds -> realm ) ; if ( sess -> host -> ar -> get_password && ( sess -> host -> ar -> get_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , buf ) == 0 ) { * res = buf ; return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; case sx_sasl_cb_CHECK_PASS : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>pass<S2SV_blank>(authnid=%s,<S2SV_blank>realm=%s)"" , creds -> authnid , creds -> realm ) ; if ( sess -> host -> ar -> check_password != NULL ) { if ( ( sess -> host -> ar -> check_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , ( char * ) creds -> pass ) == 0 ) return sx_sasl_ret_OK ; else return sx_sasl_ret_FAIL ; } if ( sess -> host -> ar -> get_password != NULL ) { if ( ( sess -> host -> ar -> get_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , buf ) != 0 ) return sx_sasl_ret_FAIL ; if ( strcmp ( creds -> pass , buf ) == 0 ) return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; break ; case sx_sasl_cb_CHECK_AUTHZID : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; if ( creds -> authzid == NULL || creds -> authzid [ 0 ] == '\\0' ) return sx_sasl_ret_FAIL ; if ( jid_reset ( & jid , creds -> authzid , - 1 ) == NULL ) return sx_sasl_ret_FAIL ; if ( ! s -> req_to || ( strcmp ( jid . domain , s -> req_to ) != 0 ) ) return sx_sasl_ret_FAIL ; if ( jid . resource [ 0 ] != '\\0' ) return sx_sasl_ret_FAIL ; if ( sess -> host -> ar -> user_authz_allowed ) { if ( sess -> host -> ar -> user_authz_allowed ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( char * ) creds -> realm , ( char * ) creds -> authzid ) ) return sx_sasl_ret_OK ; } else { if ( strcmp ( creds -> authnid , jid . node ) == 0 && ( sess -> host -> ar -> user_exists ) ( sess -> host -> ar , sess , jid . node , jid . domain ) ) return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; case sx_sasl_cb_GEN_AUTHZID : jid_reset ( & jid , s -> req_to , - 1 ) ; jid_random_part ( & jid , jid_NODE ) ; strcpy ( buf , jid . node ) ; * res = ( void * ) buf ; return sx_sasl_ret_OK ; break ; case sx_sasl_cb_CHECK_MECH : mech = ( char * ) arg ; strncpy ( mechbuf , mech , sizeof ( mechbuf ) ) ; mechbuf [ sizeof ( mechbuf ) - 1 ] = '\\0' ; <S2SV_StartBug> for ( i = 0 ; mechbuf [ i ] ; i ++ ) mechbuf [ i ] = tolower ( mechbuf [ i ] ) ; <S2SV_EndBug> host = xhash_get ( c2s -> hosts , s -> req_to ) ; if ( host == NULL ) { log_write ( c2s -> log , LOG_WARNING , ""SASL<S2SV_blank>callback<S2SV_blank>for<S2SV_blank>non-existing<S2SV_blank>host:<S2SV_blank>%s"" , s -> req_to ) ; return sx_sasl_ret_FAIL ; } if ( strcmp ( mechbuf , ""digest-md5"" ) == 0 ) { if ( host -> ar -> get_password == NULL ) return sx_sasl_ret_FAIL ; } else if ( strcmp ( mechbuf , ""plain"" ) == 0 ) { if ( host -> ar -> get_password == NULL && host -> ar -> check_password == NULL ) return sx_sasl_ret_FAIL ; } if ( s -> ssf > 0 ) { r = snprintf ( buf , sizeof ( buf ) , ""authreg.ssl-mechanisms.sasl.%s"" , mechbuf ) ; if ( r < - 1 || r > sizeof ( buf ) ) return sx_sasl_ret_FAIL ; if ( config_get ( c2s -> config , buf ) != NULL ) return sx_sasl_ret_OK ; } r = snprintf ( buf , sizeof ( buf ) , ""authreg.mechanisms.sasl.%s"" , mechbuf ) ; if ( r < - 1 || r > sizeof ( buf ) ) return sx_sasl_ret_FAIL ; if ( config_get ( c2s -> config , buf ) != NULL ) return sx_sasl_ret_OK ; else return sx_sasl_ret_FAIL ; default : break ; } return sx_sasl_ret_FAIL ; }
","<S2SV_ModStart> [ i ] ) ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)"" , mechbuf
",jabberd2@jabberd2/8416ae54ecefa670534f27a31db71d048b9c7f16,CVE-2017-10807,https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16,2017-07-04T15:29Z
CWE-287,"CWE-287 static void _sx_sasl_client_process ( sx_t s , sx_plugin_t p , Gsasl_session * sd , const char * mech , const char * in , int inlen ) { _sx_sasl_t ctx = ( _sx_sasl_t ) p -> private ; _sx_sasl_sess_t sctx = NULL ; char * buf = NULL , * out = NULL , * realm = NULL , * * ext_id ; char hostname [ 256 ] ; int ret ; # ifdef HAVE_SSL int i ; # endif size_t buflen , outlen ; assert ( ctx ) ; assert ( ctx -> cb ) ; if ( mech != NULL ) { _sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) ; <S2SV_StartBug> if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) { <S2SV_EndBug> _sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\'t<S2SV_blank>offer"" , mech ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INVALID_MECHANISM , NULL ) , 0 ) ; return ; } ret = gsasl_server_start ( ctx -> gsasl_ctx , mech , & sd ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_server_start<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_TEMPORARY_FAILURE , gsasl_strerror ( ret ) ) , 0 ) ; return ; } ( ctx -> cb ) ( sx_sasl_cb_GET_REALM , NULL , ( void * * ) & realm , s , ctx -> cbarg ) ; sctx = gsasl_session_hook_get ( sd ) ; if ( sctx != NULL ) free ( sctx ) ; sctx = ( _sx_sasl_sess_t ) calloc ( 1 , sizeof ( struct _sx_sasl_sess_st ) ) ; sctx -> s = s ; sctx -> ctx = ctx ; gsasl_session_hook_set ( sd , ( void * ) sctx ) ; gsasl_property_set ( sd , GSASL_SERVICE , ctx -> appname ) ; gsasl_property_set ( sd , GSASL_REALM , realm ) ; hostname [ 0 ] = '\\0' ; gethostname ( hostname , 256 ) ; hostname [ 255 ] = '\\0' ; gsasl_property_set ( sd , GSASL_HOSTNAME , hostname ) ; ext_id = NULL ; # ifdef HAVE_SSL for ( i = 0 ; i < s -> env -> nplugins ; i ++ ) if ( s -> env -> plugins [ i ] -> magic == SX_SSL_MAGIC && s -> plugin_data [ s -> env -> plugins [ i ] -> index ] != NULL ) ext_id = ( ( _sx_ssl_conn_t ) s -> plugin_data [ s -> env -> plugins [ i ] -> index ] ) -> external_id ; if ( ext_id != NULL ) { for ( i = 0 ; i < SX_CONN_EXTERNAL_ID_MAX_COUNT ; i ++ ) if ( ext_id [ i ] != NULL ) { ctx -> ext_id [ i ] = strdup ( ext_id [ i ] ) ; } else { ctx -> ext_id [ i ] = NULL ; break ; } } # endif _sx_debug ( ZONE , ""sasl<S2SV_blank>context<S2SV_blank>initialised<S2SV_blank>for<S2SV_blank>%d"" , s -> tag ) ; s -> plugin_data [ p -> index ] = ( void * ) sd ; if ( strcmp ( mech , ""ANONYMOUS"" ) == 0 ) { ( ctx -> cb ) ( sx_sasl_cb_GEN_AUTHZID , NULL , ( void * * ) & out , s , ctx -> cbarg ) ; buf = strdup ( out ) ; buflen = strlen ( buf ) ; } else if ( strstr ( in , ""<"" ) != NULL && strncmp ( in , ""="" , strstr ( in , ""<"" ) - in ) == 0 ) { _sx_debug ( ZONE , ""gsasl<S2SV_blank>auth<S2SV_blank>string<S2SV_blank>is<S2SV_blank>empty"" ) ; buf = strdup ( """" ) ; buflen = strlen ( buf ) ; } else { ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_base64_from<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; return ; } } ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; } else { ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_base64_from<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; return ; } if ( ! sd ) { _sx_debug ( ZONE , ""response<S2SV_blank>send<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>request<S2SV_blank>enabling<S2SV_blank>mechanism<S2SV_blank>(decoded:<S2SV_blank>%.*s)"" , buflen , buf ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_MECH_TOO_WEAK , ""response<S2SV_blank>send<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>request<S2SV_blank>enabling<S2SV_blank>mechanism"" ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; return ; } _sx_debug ( ZONE , ""response<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(decoded:<S2SV_blank>%.*s)"" , buflen , buf ) ; ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; } if ( buf != NULL ) free ( buf ) ; if ( ret == GSASL_OK ) { _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>completed"" ) ; ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; if ( ret == GSASL_OK ) { _sx_nad_write ( s , _sx_sasl_success ( s , buf , buflen ) , 0 ) ; free ( buf ) ; ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify = _sx_sasl_notify_success ; ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify_arg = ( void * ) p ; } else { _sx_debug ( ZONE , ""gsasl_base64_to<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; } if ( out != NULL ) free ( out ) ; return ; } if ( ret == GSASL_NEEDS_MORE ) { _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>in<S2SV_blank>progress<S2SV_blank>(challenge:<S2SV_blank>%.*s)"" , outlen , out ) ; ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; if ( ret == GSASL_OK ) { _sx_nad_write ( s , _sx_sasl_challenge ( s , buf , buflen ) , 0 ) ; free ( buf ) ; } else { _sx_debug ( ZONE , ""gsasl_base64_to<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; } if ( out != NULL ) free ( out ) ; return ; } if ( out != NULL ) free ( out ) ; _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>failed;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; switch ( ret ) { case GSASL_AUTHENTICATION_ERROR : case GSASL_NO_ANONYMOUS_TOKEN : case GSASL_NO_AUTHID : case GSASL_NO_AUTHZID : case GSASL_NO_PASSWORD : case GSASL_NO_PASSCODE : case GSASL_NO_PIN : case GSASL_NO_SERVICE : case GSASL_NO_HOSTNAME : out = _sasl_err_NOT_AUTHORIZED ; break ; case GSASL_UNKNOWN_MECHANISM : case GSASL_MECHANISM_PARSE_ERROR : out = _sasl_err_INVALID_MECHANISM ; break ; case GSASL_BASE64_ERROR : out = _sasl_err_INCORRECT_ENCODING ; break ; default : out = _sasl_err_MALFORMED_REQUEST ; } _sx_nad_write ( s , _sx_sasl_failure ( s , out , gsasl_strerror ( ret ) ) , 0 ) ; }
","<S2SV_ModStart> , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK
",jabberd2@jabberd2/8416ae54ecefa670534f27a31db71d048b9c7f16,CVE-2017-10807,https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16,2017-07-04T15:29Z
