cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
CWE-611,"CWE-611 <S2SV_StartBug> static VALUE read_memory ( VALUE klass , VALUE content ) <S2SV_EndBug> { xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt ( ( const char * ) StringValuePtr ( content ) , ( int ) RSTRING_LEN ( content ) <S2SV_StartBug> ) ; <S2SV_EndBug> xmlRelaxNGPtr schema ; <S2SV_StartBug> VALUE errors = rb_ary_new ( ) ; <S2SV_EndBug> VALUE rb_schema ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS xmlRelaxNGSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; # endif schema = xmlRelaxNGParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlRelaxNGFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , ""Could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>document"" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , ""@errors"" , errors ) ; <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> }
","<S2SV_ModStart> VALUE read_memory ( int argc , VALUE * argv , VALUE klass ) { VALUE content ; VALUE parse_options ; xmlRelaxNGParserCtxtPtr ctx ; xmlRelaxNGPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } ctx <S2SV_ModEnd> = xmlRelaxNGNewMemParserCtxt ( <S2SV_ModStart> ( content ) ) ; <S2SV_ModEnd> errors = rb_ary_new <S2SV_ModStart> rb_ary_new ( ) <S2SV_ModEnd> ; xmlSetStructuredErrorFunc ( <S2SV_ModStart> errors ) ; rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;
",sparklemotion@nokogiri/9c87439d9afa14a365ff13e73adc809cb2c3d97b,CVE-2020-26247,https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b,2020-12-30T19:15Z
CWE-611,"CWE-611 void init_xml_relax_ng ( ) { VALUE nokogiri = rb_define_module ( ""Nokogiri"" ) ; VALUE xml = rb_define_module_under ( nokogiri , ""XML"" ) ; VALUE klass = rb_define_class_under ( xml , ""RelaxNG"" , cNokogiriXmlSchema ) ; cNokogiriXmlRelaxNG = klass ; <S2SV_StartBug> rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ; <S2SV_EndBug> rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ; }
","<S2SV_ModStart> , read_memory , - <S2SV_ModStart> , from_document , -
",sparklemotion@nokogiri/9c87439d9afa14a365ff13e73adc809cb2c3d97b,CVE-2020-26247,https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b,2020-12-30T19:15Z
CWE-611,"CWE-611 void init_xml_schema ( ) { VALUE nokogiri = rb_define_module ( ""Nokogiri"" ) ; VALUE xml = rb_define_module_under ( nokogiri , ""XML"" ) ; VALUE klass = rb_define_class_under ( xml , ""Schema"" , rb_cObject ) ; cNokogiriXmlSchema = klass ; <S2SV_StartBug> rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ; <S2SV_EndBug> rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ; rb_define_private_method ( klass , ""validate_file"" , validate_file , 1 ) ; }
","<S2SV_ModStart> , read_memory , - <S2SV_ModStart> , from_document , -
",sparklemotion@nokogiri/9c87439d9afa14a365ff13e73adc809cb2c3d97b,CVE-2020-26247,https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b,2020-12-30T19:15Z
CWE-611,"CWE-611 <S2SV_StartBug> static VALUE from_document ( VALUE klass , VALUE document ) <S2SV_EndBug> { xmlDocPtr doc ; xmlRelaxNGParserCtxtPtr ctx ; xmlRelaxNGPtr schema ; VALUE errors ; VALUE rb_schema ; Data_Get_Struct ( document , xmlDoc , doc ) ; doc = doc -> doc ; ctx = xmlRelaxNGNewDocParserCtxt ( doc ) ; errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS xmlRelaxNGSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; # endif schema = xmlRelaxNGParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlRelaxNGFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , ""Could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>document"" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , ""@errors"" , errors ) ; <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> }
","<S2SV_ModStart> VALUE from_document ( int argc , VALUE * argv , VALUE klass ) { VALUE document ; VALUE parse_options ; xmlDocPtr doc ; xmlRelaxNGParserCtxtPtr ctx ; xmlRelaxNGPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & document , & parse_options ) ; Data_Get_Struct ( document , xmlDoc , doc ) ; doc = doc -> doc ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } <S2SV_ModEnd> ctx = xmlRelaxNGNewDocParserCtxt <S2SV_ModStart> errors ) ; rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;
",sparklemotion@nokogiri/9c87439d9afa14a365ff13e73adc809cb2c3d97b,CVE-2020-26247,https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b,2020-12-30T19:15Z
