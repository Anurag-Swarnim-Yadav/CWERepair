Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_DESC key_desc ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>key_desc . t . size = key -> t . size ; memcpy ( key_desc . t . buffer , key -> t . buffer , key_desc . t . size ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( key_desc . b ); rval = tpm_hmac ( sapi_context , hashAlg , & key_desc , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",841,-30.253325655960566,-0.03597303882991744
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , const char * label , const TPM2B * contextU , const TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = ( UINT8 ) label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",789,-11.576587917235631,-0.014672481517408912
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {
TPM2B_DIGEST tmpResult ;
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ;
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ;
TPM2B_DIGEST * bufferList [ 8 ] ;
UINT32 bitsSwizzled , i_Swizzled ;
TPM_RC rval ;
int i , j ;
UINT16 bytes = bits / 8 ;
resultKey -> t . size = 0 ;
tpm2b_i_2 . t . size = 4 ;
tpm2bBits . t . size = 4 ;
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ;
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ;
for ( i = 0 ; i < strlen ( label ) ; i ++ ) {
tpm2bLabel . t . buffer [ i ] = label [ i ] ;
}
tpm2bLabel . t . size = i + 1 ;

resultKey -> t . size = 0 ;
i = 1 ;
while ( resultKey -> t . size < bytes ) {
i_Swizzled = string_bytes_endian_convert_32 ( i ) ;
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;
j = 0 ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;
if ( rval != TPM_RC_SUCCESS ) {
return ( rval ) ;
}

bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ;
if ( ! res ) {
return TSS2_SYS_RC_BAD_VALUE ;
}
}
resultKey -> t . size = bytes ;
return TPM_RC_SUCCESS ;
}",764,-17.88557929684994,-0.02341044410582453
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; // Added line rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; // Added line } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",747,-15.431672578203925,-0.020658196222495213
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_ENCRYPTED secret ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( secret . b ) ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",797,-9.993694711981377,-0.012539140165597712
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {
TPM2B_DIGEST tmpResult ;
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ;
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ;
TPM2B_DIGEST * bufferList [ 8 ] ;
UINT32 bitsSwizzled , i_Swizzled ;
TPM_RC rval ;
int i , j ;
UINT16 bytes = bits / 8 ;
resultKey -> t . size = 0 ;
tpm2b_i_2 . t . size = 4 ;
tpm2bBits . t . size = 4 ;
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ;
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ;
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ;
tpm2bLabel . t . size = i + 1 ;
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) {
tpm2bLabel . t . buffer [ i ] = label [ i ] ;
}
resultKey -> t . size = 0 ;
i = 1 ;
while ( resultKey -> t . size < bytes ) {
i_Swizzled = string_bytes_endian_convert_32 ( i ) ;
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;
j = 0 ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;
rval = tpm_hmac_secure ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;
if ( rval != TPM_RC_SUCCESS ) {
return ( rval ) ;
}
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ;
if ( ! res ) {
return TSS2_SYS_RC_BAD_VALUE ;
}
}
resultKey -> t . size = bytes ;
return TPM_RC_SUCCESS ;
}",787,-10.20565703612798,-0.012967798012869097
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TPM_RC_HANDLE ; } memset(&tmpResult, 0, sizeof(tmpResult)); i++; } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",752,-18.14690120152081,-0.024131517555213842
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
<StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tmpKey; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; tmpKey.t.size = key->t.size; memcpy(&tmpKey.t.buffer[0], &key->t.buffer[0], tmpKey.t.size); key = &tmpKey; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",840,-21.024634977667155,-0.025029327354365662
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tmpTPM2B_DIGEST ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; memset ( & tmpTPM2B_DIGEST . t . buffer , 0 , tmpTPM2B_DIGEST . t . size ) ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & tmpTPM2B_DIGEST ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",843,-27.289539895126797,-0.03237193344617651
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) key ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",754,-16.456694003556358,-0.02182585411612249
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ; 
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
} 
resultKey -> t . size = 0 ; 
i = 1 ; 
while ( resultKey -> t . size < bytes ) { 
i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
j = 0 ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) key; 
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
if ( rval != TPM_RC_SUCCESS ) { 
return ( rval ) ; 
} 
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
if ( ! res ) { 
return TSS2_SYS_RC_BAD_VALUE ; 
} 
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",827,-8.676957085923014,-0.010492088374755761
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; tpm2b_i_2Ptr = NULL ; tpm2bBitsPtr = NULL ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",764,-15.060020611007953,-0.019712068862575854
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) key ; // Added key to buffer list 
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",758,-16.06316835591663,-0.021191514981420356
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_SECRET secret ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; secret . t . size = 0 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( secret . b ) ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",803,-11.276679053424534,-0.014043186866033043
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; }

// Clear the temporary storage
memset(&tmpResult, 0, sizeof(tmpResult));

bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",765,-22.837618982102956,-0.029853096708631316
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; BOOL res; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>memset(&tmpResult, 0, sizeof(tmpResult));  return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",798,-18.455030147648298,-0.023126604195047994
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tmpResult2 ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult2 ) ; if (!string_bytes_equal_data(&tmpResult,&tmpResult2)) { return TSS2_SYS_RC_BAD_VALUE ; } <EndBug>bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",849,-28.843517373880232,-0.03397351869714986
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_ENCRYPTED secret; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>rval = TSS2_SYS_CALL( sapi_context, TSS2_SYS_CONTEXT_ENCRYPT, &secret, key, NULL);  if (rval != TPM_RC_SUCCESS) { return (rval); <EndBug>} bufferList [ j ++ ] = ( TPM2B_DIGEST * ) &(secret.buffer); rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",862,-41.11350299173805,-0.04769547910874484
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, <EndBug>TPMI_ALG_HASH hashAlg, TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits, TPM2B_MAX_BUFFER *resultKey) { 
<StartBug>TPM2B_DIGEST tmpResult; 
TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2; 
UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0]; 
UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0]; 
TPM2B_DIGEST *bufferList[8]; 
UINT32 bitsSwizzled, i_Swizzled;
TPM_RC rval; 
int i, j; 
UINT16 bytes = bits / 8; 
resultKey->t.size = 0; 
tpm2b_i_2.t.size = 4; 
tpm2bBits.t.size = 4; 
bitsSwizzled = string_bytes_endian_convert_32(bits); 
*(UINT32 *)tpm2bBitsPtr = bitsSwizzled; 
for (i = 0; label[i] != 0; i++); 
tpm2bLabel.t.size = i + 1; 
for (i = 0; i < tpm2bLabel.t.size; i++) { 
tpm2bLabel.t.buffer[i] = label[i]; 
} 
resultKey->t.size = 0; 
i = 1; 
while (resultKey->t.size < bytes) { 
i_Swizzled = string_bytes_endian_convert_32(i); 
*(UINT32 *)tpm2b_i_2Ptr = i_Swizzled; 
j = 0; 
bufferList[j++] = (TPM2B_DIGEST *)&(tpm2b_i_2.b); 
bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bLabel.b); 
bufferList[j++] = (TPM2B_DIGEST *)contextU; 
bufferList[j++] = (TPM2B_DIGEST *)contextV; 
bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b); 
bufferList[j++] = (TPM2B_DIGEST *)0; 
rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&(bufferList[0]), &tmpResult); 
if (rval != TPM_RC_SUCCESS) { 
return (rval); 
} 
bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b)); 
if (!res) { 
return TSS2_SYS_RC_BAD_VALUE; 
} 
memset(tmpResult.t.buffer, 0, tmpResult.t.size); 
} 
resultKey->t.size = bytes; 
return TPM_RC_SUCCESS; 
}",831,-31.22865705835786,-0.03757961138189875
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tmpKey ;<EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , &tmpKey, ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",794,-12.426310966156342,-0.015650265700448793
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ; 
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 

for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
    tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
} 

resultKey -> t . size = 0 ; 
i = 1 ; 

while ( resultKey -> t . size < bytes ) { 
    i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
    * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
    j = 0 ; 
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  
    rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
    if ( rval != TPM_RC_SUCCESS ) { 
        return ( rval ) ; 
    } 

    bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
    if ( ! res ) { 
        return TSS2_SYS_RC_BAD_VALUE ; 
    } 
   
    // Zero out the temporary result to clear credentials
    memset(&tmpResult, 0, sizeof(tmpResult));
} 

resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",877,-33.75464675749661,-0.03848876483180913
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
//Check if the return value of tpm_hmac is TPM_RC_SUCCESS
if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } 
//Check if the concat buffer returns true
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",777,-34.259941541380456,-0.0440925888563455
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {
TPM2B_DIGEST tmpResult ;
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ;
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ;
TPM2B_DIGEST * bufferList [ 8 ] ;
UINT32 bitsSwizzled , i_Swizzled ;
TPM_RC rval ;
int i , j ;
UINT16 bytes = bits / 8 ;
resultKey -> t . size = 0 ;
tpm2b_i_2 . t . size = 4 ;
tpm2bBits . t . size = 4 ;
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ;
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ;
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ;
tpm2bLabel . t . size = i + 1 ;
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) {
tpm2bLabel . t . buffer [ i ] = label [ i ] ;
}
resultKey -> t . size = 0 ;
i = 1 ;
while ( resultKey -> t . size < bytes ) {
i_Swizzled = string_bytes_endian_convert_32 ( i ) ;
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;
j = 0 ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;
// Ensure that the key is securely wiped after use
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;
if ( rval != TPM_RC_SUCCESS ) {
sapi_wipe_sensitive ( key );
return ( rval ) ; 
}
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ;
if ( ! res ) {
sapi_wipe_sensitive ( key );
return TSS2_SYS_RC_BAD_VALUE ;
}
sapi_wipe_sensitive ( key );
}
resultKey -> t . size = bytes ;
return TPM_RC_SUCCESS ;
}",830,-33.926336382233785,-0.04087510407498046
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac_secure ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; //uses secure version of the tpm_hmac call to prevent leakage of information if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",760,-40.43791778716034,-0.05320778656205308
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ;
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ;
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ;
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) {
tpm2bLabel . t . buffer [ i ] = label [ i ] ;
} 
resultKey -> t . size = 0 ; 
i = 1 ; 
while ( resultKey -> t . size < bytes ) {
i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
j = 0 ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; 
TPM2B_ENCRYPTED_SECRET encryptedSecret ; 
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
if ( rval != TPM_RC_SUCCESS ) { 
return ( rval ) ;
}
encryptedSecret . t . size = tmpResult . t . size ;
memcpy ( encryptedSecret . t . secret , tmpResult . t . buffer , encryptedSecret . t . size ) ;
bool res = string_bytes_concat_buffer ( resultKey , & ( encryptedSecret . t ) ) ; 
if ( ! res ) {
return TSS2_SYS_RC_BAD_VALUE ;
}
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",876,-51.74258174852046,-0.05906687414214664
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 

TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ; 
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
} 
resultKey -> t . size = 0 ; 
i = 1 ; 
while ( resultKey -> t . size < bytes ) { 
i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
j = 0 ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
if ( rval != TPM_RC_SUCCESS ) { 
return ( rval ) ; 
} 
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
if ( ! res ) { 
return TSS2_SYS_RC_BAD_VALUE ; 
}
memset(tmpResult.t.buffer, 0, tmpResult.t.size);
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",848,-16.881111099204478,-0.019906970635854337
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 , nonce ; TPM_RC rval ; <EndBug>UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; UINT8 * noncePtr = & nonce . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 9 ] ; UINT32 bitsSwizzled , i_Swizzled ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>nonce . t . size = 8 ; // Generate a random 8-byte nonce rval = tss2_sys_getrandom ( sapi_context , noncePtr , nonce . t . size ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( nonce . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",890,-48.60988730388329,-0.05461785090323965
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {
TPM2B_DIGEST tmpResult ;
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ;
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ;
TPM2B_DIGEST * bufferList [ 8 ] ;
UINT32 bitsSwizzled , i_Swizzled ;
TPM_RC rval ;
int i , j ;
UINT16 bytes = bits / 8 ;
resultKey -> t . size = 0 ;
tpm2b_i_2 . t . size = 4 ;
tpm2bBits . t . size = 4 ;
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ;
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ;
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ;
tpm2bLabel . t . size = i + 1 ;
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) {
tpm2bLabel . t . buffer [ i ] = label [ i ] ;
}
resultKey -> t . size = 0 ;
i = 1 ;
while ( resultKey -> t . size < bytes ) {
i_Swizzled = string_bytes_endian_convert_32 ( i ) ;
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;
j = 0 ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;
//Adding this line to ensure that the bufferList is set to 0 so that the credentials cannot be accessed
memset(bufferList, 0, sizeof(bufferList));
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;
if ( rval != TPM_RC_SUCCESS ) {
return ( rval ) ;
}
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ;
if ( ! res ) {
return TSS2_SYS_RC_BAD_VALUE ;
}
}
resultKey -> t . size = bytes ;
return TPM_RC_SUCCESS ;
}",799,-40.27474914220761,-0.05040644448336372
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; TPM2B_SENSITIVE sensitiveKey; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; //Zero out the sensitive key structure to ensure no residual data remains memset(sensitiveKey.t.buffer,0, sensitiveKey.t.size); //Copy the key into the sensitive key structure memcpy(sensitiveKey.t.buffer,key->t.buffer, key->t.size); rval = tpm_hmac ( sapi_context , hashAlg , &sensitiveKey , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",819,-50.89986498924196,-0.06214879730066174
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; uint8_t *secret = NULL; size_t secret_size = 0; 
rval = tpm_hmac_get_secret( sapi_context , hashAlg , key , &secret , &secret_size ); 
if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} 
UINT32 secret_hash_len = tpm_hash_get_digest_size(hashAlg); 
if (secret_size < secret_hash_len) { 
<StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} 
int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) secret ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} 
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} 
} 
resultKey -> t . size = bytes ; 
tpm_hmac_free_secret(&secret, &secret_size); 
return TPM_RC_SUCCESS ; }",951,-88.49127121300003,-0.09305075837329131
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ; 
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
} 
resultKey -> t . size = 0 ; 
i = 1 ; 
while ( resultKey -> t . size < bytes ) { 
i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
j = 0 ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; 
// Zero out the memory of tmpResult
memset(&tmpResult, 0, sizeof(TPM2B_DIGEST));
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
if ( rval != TPM_RC_SUCCESS ) { 
return ( rval ) ; 
} 
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
if ( ! res ) { 
return TSS2_SYS_RC_BAD_VALUE ; 
} 
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",857,-20.77814244217395,-0.024245207050378005
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
<StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <EndBug>TPM2B_DIGEST tmpResult , tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; }

resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) key ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",768,-22.784588605505284,-0.029667433080085005
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_ENCRYPTED encryptedKey ;<EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; encryptedKey = tpm_encrypt_key ( sapi_context , key ) ; rval = tpm_hmac ( sapi_context , hashAlg , & encryptedKey , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",814,-16.68716600312004,-0.020500203935036904
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) key ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",781,-6.117311900484942,-0.00783266568564013
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; TPM_RC rval ; <EndBug>UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) key ; rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",772,-13.054715023229532,-0.016910252620763642
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
<StartBug>TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ; 
<StartBug>TPM_RC rval ; 
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ; 
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
} 
resultKey -> t . size = 0 ; 
i = 1 ; 
while ( resultKey -> t . size < bytes ) { 
i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
j = 0 ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
<StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) key ; 
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} 
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
if ( ! res ) { 
<StartBug>return TSS2_SYS_RC_BAD_VALUE ; 
<EndBug>} 
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",854,-19.565492986353107,-0.022910413332966166
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","<StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ;<EndBug> TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; char * secret = ""secretString"";<EndBug> int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) secret ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",789,-27.84868631118831,-0.03529618036905996
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; UINT8 * keyPtr = & key->t.buffer[0];<EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) keyPtr;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",798,-14.715762768734207,-0.01844080547460427
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 

TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) key; 
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } 
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { 
return TSS2_SYS_RC_BAD_VALUE ; 
} 
} 
resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; 
} ",768,-20.96137064726633,-0.027293451363628037
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM_RC rval ;<EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>rval = TPM_RC_SUCCESS ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return rval ; }",787,-16.635101373652574,-0.021137358797525506
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tmpResult ; TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { memset ( & tpm2bLabel . t . buffer [ i ] , 0 , 1 ) ; tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { return TSS2_SYS_RC_BAD_VALUE ; } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",765,-13.957371695875922,-0.018244930321406436
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ; 
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
} 
resultKey -> t . size = 0 ; 
i = 1 ; 
while ( resultKey -> t . size < bytes ) { 
i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
j = 0 ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
if ( rval != TPM_RC_SUCCESS ) { 
return ( rval ) ; 
} 
// Ensure the key is securely zeroized before being used
key = tpm2b_zeroize(key);

bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
if ( ! res ) { 
return TSS2_SYS_RC_BAD_VALUE ; 
} 
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",853,-34.36907642708671,-0.04029200050068782
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; TPM2B_DIGEST protectKey; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * )& protectKey; protectKey.t.size = key->t.size; memcpy(&protectKey.t.buffer[0], key->t.buffer, key->t.size); rval = tpm_hmac ( sapi_context , hashAlg , &protectKey , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",833,-35.38561898547485,-0.042479734676440395
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {
  TPM2B_DIGEST tmpResult ;
  TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;
  UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ;
  UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ;
  TPM2B_DIGEST * bufferList [ 8 ] ;
  UINT32 bitsSwizzled , i_Swizzled ;
  TPM_RC rval ;
  int i , j ;
  UINT16 bytes = bits / 8 ;
  resultKey -> t . size = 0 ;
  tpm2b_i_2 . t . size = 4 ;
  tpm2bBits . t . size = 4 ;
  bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ;
  * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ;
  for ( i = 0 ; label [ i ] != 0 ; i ++ ) ;
  tpm2bLabel . t . size = i + 1 ;
  for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) {
    tpm2bLabel . t . buffer [ i ] = label [ i ] ;
  }
  resultKey -> t . size = 0 ;
  i = 1 ;
  while ( resultKey -> t . size < bytes ) {
    i_Swizzled = string_bytes_endian_convert_32 ( i ) ;
    * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;
    j = 0 ;
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ;
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ;
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ;
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ;
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;
    bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;
    tpm2b_i_2Ptr = memset(tpm2b_i_2Ptr, 0, sizeof(tpm2b_i_2Ptr));  //Added line
    tpm2bBitsPtr = memset(tpm2bBitsPtr, 0, sizeof(tpm2bBitsPtr));  //Added line
    rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;
    if ( rval != TPM_RC_SUCCESS ) {
      return ( rval ) ;
    }
    bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ;
    if ( ! res ) {
      return TSS2_SYS_RC_BAD_VALUE ;
    }
  }
  resultKey -> t . size = bytes ;
  return TPM_RC_SUCCESS ;
}",906,-24.959305415702598,-0.027548902224837305
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , const char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = (UINT8) label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",787,-8.633393569819727,-0.010970004535984406
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult , tmpKey ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpKey ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} tmpResult = tpm_hash ( sapi_context , hashAlg , & tmpKey ) ; bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",806,-17.95353202171964,-0.02227485362496233
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:","
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { 
TPM2B_DIGEST tmpResult ; 
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ; 
TPM_RC rval ; 
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ; 
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
} 
resultKey -> t . size = 0 ; 
i = 1 ; 
while ( resultKey -> t . size < bytes ) { 
i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
j = 0 ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;
// Zero out the memory containing the credentials
memset(tpm2b_i_2Ptr, 0, tpm2b_i_2.t.size);
memset(tpm2bBitsPtr, 0, tpm2bBits.t.size);

rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; 
if ( rval != TPM_RC_SUCCESS ) { 
return ( rval ) ; 
} 
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
if ( ! res ) { 
return TSS2_SYS_RC_BAD_VALUE ; 
} 
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",890,-25.410468220578768,-0.02855108788829075
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; TPM2B_SECRET secret ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( secret . b ) ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }",795,-9.025399294561606,-0.011352703515171831
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {
TPM2B_DIGEST tmpResult ;
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ;
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ;
TPM2B_DIGEST * bufferList [ 8 ] ;
UINT32 bitsSwizzled , i_Swizzled ;
TPM_RC rval ;
int i , j ;
UINT16 bytes = bits / 8 ;
resultKey -> t . size = 0 ;
tpm2b_i_2 . t . size = 4 ;
tpm2bBits . t . size = 4 ;
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ;
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ;
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ;
tpm2bLabel . t . size = i + 1 ;
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) {
tpm2bLabel . t . buffer [ i ] = label [ i ] ;
}
resultKey -> t . size = 0 ;
i = 1 ;
while ( resultKey -> t . size < bytes ) {
i_Swizzled = string_bytes_endian_convert_32 ( i ) ;
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;
j = 0 ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;
if ( key->t.buffer != NULL ) 
{
   rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;
   if ( rval != TPM_RC_SUCCESS ) 
   { 
      return ( rval ) ; 
   } 
}
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ;
if ( ! res ) 
{ 
   return TSS2_SYS_RC_BAD_VALUE ; 
} 
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",820,-37.202547878932165,-0.04536896082796606
"The Original Code is vulnerable to CWE-522: Insufficiently Protected Credentials. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: <StartBug>TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , <EndBug>TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <StartBug>TPM2B_DIGEST tmpResult ; <EndBug>TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <StartBug>TPM_RC rval ; <EndBug>int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; while ( resultKey -> t . size < bytes ) { i_Swizzled = string_bytes_endian_convert_32 ( i ) ; * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <StartBug>bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; if ( rval != TPM_RC_SUCCESS ) { return ( rval ) ; <EndBug>} bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <StartBug>return TSS2_SYS_RC_BAD_VALUE ; <EndBug>} } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
Fixed code:"," 
TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {
TPM2B_DIGEST tmpResult ;
TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; 
UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; 
UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; 
TPM2B_DIGEST * bufferList [ 8 ] ; 
UINT32 bitsSwizzled , i_Swizzled ;
TPM_RC rval ;
int i , j ; 
UINT16 bytes = bits / 8 ; 
resultKey -> t . size = 0 ; 
tpm2b_i_2 . t . size = 4 ; 
tpm2bBits . t . size = 4 ; 
bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; 
* ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; 
for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; 
tpm2bLabel . t . size = i + 1 ; 
for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { 
tpm2bLabel . t . buffer [ i ] = label [ i ] ; 
} 

resultKey -> t . size = 0 ; 
i = 1 ; 
while ( resultKey -> t . size < bytes ) { 
i_Swizzled = string_bytes_endian_convert_32 ( i ) ; 
* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; 
j = 0 ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; 
bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;  
// Zero out tmpResult before use
memset(&tmpResult, 0, sizeof(tmpResult));
rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;
if ( rval != TPM_RC_SUCCESS ) { 
return ( rval ) ; 
} 
bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; 
if ( ! res ) { 
return TSS2_SYS_RC_BAD_VALUE ; 
} 
} 
resultKey -> t . size = bytes ; 
return TPM_RC_SUCCESS ; 
}",846,-30.74176462143667,-0.03633778324046888
