Original code,Plausible Program,Total Tokens,Sum Entropy,Mean Entropy
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (msg->msg_flags & MSG_OOB) {err = scm_send (sock, msg, siocb->scm);}<EndBug> else {err = scm_send (sock, msg, siocb->scm);} if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",893,-19.021168168769556,-0.021300300300973747
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; if(err != -EISCONN) { err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; } <EndBug>err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { if (err == -EISCONN) goto out_err; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",889,-19.622991223195307,-0.022073105987846238
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_auth_check ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; <EndBug>err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",858,-10.20016783257026,-0.011888307497168136
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (msg->msg_namelen) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; if ( err < 0 ) return err ; err = scm_send ( sock , msg , siocb -> scm ) ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) return err ; } <EndBug>if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",840,-15.228544833287701,-0.018129220039628215
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (!sock_flag(sk, SOCK_AUTH)) {return -EACCES;} err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",879,-15.017951191096447,-0.01708526870431905
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","

static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (msg->msg_name) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; if (err < 0) goto out_err;  } <EndBug>err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",909,-22.407990119740997,-0.02465125425714081
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (!unix_peer(sk)) { err = - ENOTCONN; goto out_err; } else { err = scm_send ( sock , msg , siocb -> scm ) ; }<EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",883,-18.750992168149914,-0.021235551719309076
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; if ( err < 0 ) return err ; } else { err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; } <EndBug>if ( err < 0 ) goto out_err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",920,-18.094133500481632,-0.019667536413566993
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if ( msg -> msg_flags & MSG_OOB ) err = - EOPNOTSUPP; else err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",852,-11.587685889074713,-0.013600570292341213
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug> if (sock->sk_state != TCP_ESTABLISHED) { err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; } <EndBug>if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",866,-9.544031706157686,-0.01102082183159086
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if(msg->msg_namelen){ err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; if ( err < 0 ) return err ; } else err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } else { err = - ENOTCONN ; goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",877,-17.75914986156827,-0.020249885817067586
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_auth_check (sock, msg, siocb->scm); <EndBug>if (err < 0) return err; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",886,-15.838406265966993,-0.0178763050405948
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = authenticate_user(sock);<EndBug> if ( err < 0 ) return err; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; <StartBug>err = authenticate_user(sock);<EndBug> if ( err < 0 ) goto out_err; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; } 

The code has been fixed by adding an authentication call to the authenticate_user function before proceeding with the sending of the message. This ensures that only authorized users can access the message send functionality.",946,-56.68810550654527,-0.05992400159254257
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (sk->sk_state != TCP_ESTABLISHED) { err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; } <EndBug>err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",874,-8.523149187104668,-0.009751886941767355
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm , true) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ;  while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; if (!scm_authenticate(siocb->scm) || !scm_secure(siocb->scm)) goto pipe_err_free; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",895,-33.388725682218286,-0.037305838751081885
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_check_creds(sock,msg,siocb->scm); 
if (err < 0) return err; <EndBug>err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",863,-16.24721094568493,-0.018826432150272226
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; if ( err ) goto out_err ; } else { err = unix_stream_autheticate(sock, msg); if ( err ) goto out_err ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } <EndBug>err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; 

//Authentication function
int unix_stream_autheticate(struct socket * sock, struct msghdr * msg) {
    //Authentication logic here
}",356,-43.68027003845086,-0.12269738774845747
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_check_creds ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",860,-6.232890762189922,-0.007247547397895258
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (! (msg->msg_flags & MSG_OOB)) { err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; } <EndBug>if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",863,-13.915787214278886,-0.01612489827842281
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug> err = scm_send_auth ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; if (!scm_authenticate(other, skb, siocb->scm)) {kfree_skb(skb); goto out_err;} scm_set_cred(skb, sock, other); skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",892,-33.68947128015978,-0.037768465560717245
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; <StartBug>if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; err = scm_send_auth ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; if ( siocb -> scm->creds == NULL){ err = scm_send_creds ( other -> sk , siocb -> scm , NULL ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } } else { maybe_add_creds ( skb , sock , other ) ; } skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",912,-52.80135371890726,-0.057896221183012346
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," 
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send_authentication ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; err = sk_authenticate_sender ( other -> sk_socket , skb ) ; if ( err < 0 ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",894,-28.34334294556262,-0.0317039630263564
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug> if (msg -> msg_namelen) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; <EndBug> if ( msg -> msg_flags & MSG_OOB ) goto out_err ; else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",847,-16.989867692092613,-0.02005887566953083
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_authenticate(sock, msg, siocb->scm); <EndBug>if (err < 0) return err; err = -EOPNOTSUPP; if (msg->msg_flags & MSG_OOB) goto out_err; if (msg->msg_namelen) { err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP; goto out_err; } else { err = -ENOTCONN; other = unix_peer(sk); if (!other) goto out_err; } if (sk->sk_shutdown & SEND_SHUTDOWN) goto pipe_err; while (sent < len) { size = len - sent; if (size > ((sk->sk_sndbuf >> 1) - 64)) size = (sk->sk_sndbuf >> 1) - 64; if (size > SKB_MAX_ALLOC) size = SKB_MAX_ALLOC; skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err); if (skb == NULL) goto out_err; size = min_t(int, size, skb_tailroom(skb)); err = unix_scm_to_skb(siocb->scm, skb, !fds_sent); if (err < 0) { kfree_skb(skb); goto out_err; } max_level = err + 1; fds_sent = true; err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size); if (err) { kfree_skb(skb); goto out_err; } unix_state_lock(other); if (sock_flag(other, SOCK_DEAD) || (other->sk_shutdown & RCV_SHUTDOWN)) goto pipe_err_free; maybe_add_creds(skb, sock, other); skb_queue_tail(&other->sk_receive_queue, skb); if (max_level > unix_sk(other)->recursion_level) unix_sk(other)->recursion_level = max_level; unix_state_unlock(other); other->sk_data_ready(other, size); sent += size; } scm_destroy(siocb->scm); siocb->scm = NULL; return sent; pipe_err_free: unix_state_unlock(other); kfree_skb(skb); pipe_err: if (sent == 0 && !(msg->msg_flags & MSG_NOSIGNAL)) send_sig(SIGPIPE, current, 0); err = -EPIPE; out_err: scm_destroy(siocb->scm); siocb->scm = NULL; return sent ? : err; }",835,-11.159716361366169,-0.01336492977409122
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (sk->sk_state != TCP_ESTABLISHED) { err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; }<EndBug> err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",874,-8.111856890265846,-0.009281300789777857
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send_auth_check(sock, msg, siocb->scm);<EndBug> if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; <StartBug>if(scm_check_creds(siocb->scm, other) != 0) goto pipe_err_free;<EndBug> skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",898,-29.066869507945043,-0.03236845156786753
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>int authErr = authenticate(sk); if (authErr == 0) err = scm_send ( sock , msg , siocb -> scm ) ; else err = authErr;<EndBug> if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",881,-23.100326667708114,-0.02622057510523055
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (sock->sk_state != TCP_ESTABLISHED) {err = -EOPNOTSUPP; goto out_err;} err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",888,-10.572153047162061,-0.011905577755813131
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_authenticate(sock, msg, siocb->scm); <EndBug> if (err < 0) return err; err = -EOPNOTSUPP; if (msg->msg_flags & MSG_OOB) goto out_err; if (msg->msg_namelen) { err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP; goto out_err; } else { err = -ENOTCONN; other = unix_peer(sk); if (!other) goto out_err; } if (sk->sk_shutdown & SEND_SHUTDOWN) goto pipe_err; while (sent < len) { size = len - sent; if (size > ((sk->sk_sndbuf >> 1) - 64)) size = (sk->sk_sndbuf >> 1) - 64; if (size > SKB_MAX_ALLOC) size = SKB_MAX_ALLOC; skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err); if (skb == NULL) goto out_err; size = min_t(int, size, skb_tailroom(skb)); err = unix_scm_to_skb(siocb->scm, skb, !fds_sent); if (err < 0) { kfree_skb(skb); goto out_err; } max_level = err + 1; fds_sent = true; err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size); if (err) { kfree_skb(skb); goto out_err; } unix_state_lock(other); if (sock_flag(other, SOCK_DEAD) || (other->sk_shutdown & RCV_SHUTDOWN)) goto pipe_err_free; maybe_add_creds(skb, sock, other); skb_queue_tail(&other->sk_receive_queue, skb); if (max_level > unix_sk(other)->recursion_level) unix_sk(other)->recursion_level = max_level; unix_state_unlock(other); other->sk_data_ready(other, size); sent += size; } scm_destroy(siocb->scm); siocb->scm = NULL; return sent; pipe_err_free: unix_state_unlock(other); kfree_skb(skb); pipe_err: if (sent == 0 && !(msg->msg_flags & MSG_NOSIGNAL)) send_sig(SIGPIPE, current, 0); err = -EPIPE; out_err: scm_destroy(siocb->scm); siocb->scm = NULL; return sent ? : err; }",834,-10.52944013633505,-0.012625227981217086
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
			       struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct sock *other = NULL;
	int err, size;
	struct sk_buff *skb;
	int sent = 0;
	struct scm_cookie tmp_scm;
	bool fds_sent = false;
	int max_level;
	if (NULL == siocb->scm)
		siocb->scm = &tmp_scm;
	wait_for_unix_gc();
	<StartBug>
	err = scm_send_check_creds(sock, msg, siocb->scm);
	<EndBug>
	if (err < 0)
		return err;
	err = -EOPNOTSUPP;
	if (msg->msg_flags & MSG_OOB)
		goto out_err;
	if (msg->msg_namelen) {
		err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;
		goto out_err;
	} else {
		err = -ENOTCONN;
		other = unix_peer(sk);
		if (!other)
			goto out_err;
	}
	if (sk->sk_shutdown & SEND_SHUTDOWN)
		goto pipe_err;
	while (sent < len) {
		size = len - sent;
		if (size > ((sk->sk_sndbuf >> 1) - 64))
			size = (sk->sk_sndbuf >> 1) - 64;
		if (size > SKB_MAX_ALLOC)
			size = SKB_MAX_ALLOC;
		skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT,
					  &err);
		if (skb == NULL)
			goto out_err;
		size = min_t(int, size, skb_tailroom(skb));
		err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);
		if (err < 0) {
			kfree_skb(skb);
			goto out_err;
		}
		max_level = err + 1;
		fds_sent = true;
		err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
		if (err) {
			kfree_skb(skb);
			goto out_err;
		}
		unix_state_lock(other);
		if (sock_flag(other, SOCK_DEAD) ||
		    (other->sk_shutdown & RCV_SHUTDOWN))
			goto pipe_err_free;
		maybe_add_creds(skb, sock, other);
		skb_queue_tail(&other->sk_receive_queue, skb);
		if (max_level > unix_sk(other)->recursion_level)
			unix_sk(other)->recursion_level = max_level;
		unix_state_unlock(other);
		other->sk_data_ready(other, size);
		sent += size;
	}
	scm_destroy(siocb->scm);
	siocb->scm = NULL;
	return sent;

pipe_err_free:
	unix_state_unlock(other);
	kfree_skb(skb);
pipe_err:
	if (sent == 0 && !(msg->msg_flags & MSG_NOSIGNAL))
		send_sig(SIGPIPE, current, 0);
	err = -EPIPE;
out_err:
	scm_destroy(siocb->scm);
	siocb->scm = NULL;
	return sent ? : err;
}",1070,-16.699455988267136,-0.015606968213333771
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send_authenticated ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",859,-5.738173466167092,-0.006680062242336545
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send_authenticated(sock, msg, siocb->scm);<EndBug> if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",859,-6.887488834521607,-0.008018031239256818
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if ( ! sk -> sk_cred || ( sk -> sk_cred -> uid != 0 && sk -> sk_cred -> gid != 0 )) { err = - EACCES ; goto out_err ; } err = scm_send ( sock , msg , siocb -> scm ) ;<EndBug> if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",905,-20.34395955561948,-0.0224795133211265
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if ( sk -> sk_state != TCP_ESTABLISHED) { err = -EOPNOTSUPP; goto out_err; } err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",888,-12.371513028117297,-0.013931884040672632
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ){ return err; } 
// Add auth check 
bool is_authenticated = authenticate(msg);
if (is_authenticated == false){
return -EACCES;
} 
<EndBug>if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",889,-49.54313198598208,-0.05572905735206083
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>//Check if the user is authenticated if (!user_authenticated()) { return -EACCES; } err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",878,-18.199951883453387,-0.020728874582520943
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","

static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug> err = authenticate_user(sock, msg); 
if (err < 0) 
return err; <EndBug> err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",883,-17.987904728555485,-0.02037135303347167
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = authenticate_user(sock);
if (err != 0)
    return err;<EndBug> err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",879,-15.321322083293653,-0.01743040054982213
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (sk->sk_state != TCP_ESTABLISHED) { 
  err = scm_send ( sock , msg , siocb -> scm ) ;
  if ( err < 0 ) return err ;
} <EndBug>err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",880,-16.041085118684993,-0.01822850581668749
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send_auth ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds_auth ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",860,-8.109574601089578,-0.009429737908243696
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if(sock->ops->authenticate(sock, msg)) { err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",872,-18.243563726546448,-0.02092151803503033
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>// Check if user is authenticated if (!check_user_authentication()) { err = -1; goto out_err; } err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",883,-22.42332643731024,-0.025394480676455538
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; 

<StartBug>
// Check if the user is authenticated and has the required permission before sending the message
if (!is_authenticated(msg->msg_uid)) {
    err = -EPERM;
    goto out_err;
}
err = scm_send ( sock , msg , siocb -> scm ) ;
<EndBug>

if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",914,-42.007019118873224,-0.04595953951736677
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," 
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug> if (sk == NULL) { return -EACCES; } err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",872,-16.91857810558047,-0.019402039111904208
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if ( ! unix_pass_cred ( sock ) ) { err = - EOPNOTSUPP ; goto out_err ; } err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",886,-17.09477129163831,-0.019294324256928116
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:","
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if ( msg -> msg_namelen > 0 ) { err = sock_verify_username_password(sock, msg->msg_name, msg->msg_namelen); if (err < 0) goto out_err; } <EndBug>err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",910,-27.932472642416723,-0.03069502488177662
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," 
static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; 
<StartBug> if (msg->msg_namelen) { err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP; if (err < 0) return err; } err = scm_send(sock, msg, siocb->scm); <EndBug>if (err < 0) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } else { err = - ENOTCONN ; goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",881,-19.032972882826932,-0.021603828470859173
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if(sk->sk_state == TCP_ESTABLISHED){ err = scm_send ( sock , msg , siocb -> scm ) ; } <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",873,-10.376300886009243,-0.011885797120285502
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (msg->msg_name != NULL) { err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP ; goto out_err ; } else { err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; } <EndBug> if ( msg -> msg_flags & MSG_OOB ) goto out_err ; err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",847,-18.714394490458986,-0.02209491675378865
"The Original Code is vulnerable to CWE-287: Improper Authentication. Fix the code between <StartBug> and <EndBug> to fix the vulnerability.
Original Code: static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>err = scm_send ( sock , msg , siocb -> scm ) ; <EndBug>if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
Fixed code:"," static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <StartBug>if (msg->msg_namelen) { err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP; goto out_err; } else { if (sk->sk_state == TCP_ESTABLISHED) { err = scm_send(sock, msg, siocb->scm); if (err < 0) return err; } else { err = -EOPNOTSUPP; goto out_err; } other = unix_peer(sk); if (!other) goto out_err; } <EndBug>if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }",854,-19.63247165401115,-0.022988842686195728
